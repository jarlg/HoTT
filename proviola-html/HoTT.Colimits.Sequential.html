<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "1 subgoal (ID 5)	  	  A : Sequence	  a : A 0	  k : Graph.graph0 sequence_graph	  ============================	  A k	";
            responses[i]=data;
          

            i = 23;
            data = "";
            responses[i]=data;
          

            i = 24;
            data = "2 subgoals (ID 9)	  	  A : Sequence	  a : A 0	  ============================	  A 0		subgoal 2 (ID 12) is:	 A k.+1	";
            responses[i]=data;
          

            i = 25;
            data = "1 subgoal (ID 9)	  	  A : Sequence	  a : A 0	  ============================	  A 0	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 12)		subgoal 1 (ID 12) is:	 A k.+1	";
            responses[i]=data;
          

            i = 26;
            data = "1 subgoal (ID 12)	  	  A : Sequence	  a : A 0	  k : nat	  q : A k	  ============================	  A k.+1	No more subgoals.	";
            responses[i]=data;
          

            i = 27;
            data = "";
            responses[i]=data;
          

            i = 28;
            data = "";
            responses[i]=data;
          

            i = 29;
            data = "";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "";
            responses[i]=data;
          

            i = 32;
            data = "";
            responses[i]=data;
          

            i = 33;
            data = "1 subgoal (ID 10)	  	  A : Sequence	  x : {x : _ & A x}	  ============================	  {x : _ & A x}	";
            responses[i]=data;
          

            i = 34;
            data = "";
            responses[i]=data;
          

            i = 35;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 36;
            data = "";
            responses[i]=data;
          

            i = 37;
            data = "1 subgoal (ID 16)	  	  A : Sequence	  x : {x : _ & A x}	  k : nat	  ============================	  {x : _ & A x}	";
            responses[i]=data;
          

            i = 38;
            data = "";
            responses[i]=data;
          

            i = 39;
            data = "2 subgoals (ID 20)	  	  A : Sequence	  x : {x : _ & A x}	  ============================	  {x : _ & A x}		subgoal 2 (ID 23) is:	 {x : _ & A x}	";
            responses[i]=data;
          

            i = 40;
            data = "1 subgoal (ID 20)	  	  A : Sequence	  x : {x : _ & A x}	  ============================	  {x : _ & A x}	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 23)		subgoal 1 (ID 23) is:	 {x : _ & A x}	";
            responses[i]=data;
          

            i = 41;
            data = "1 subgoal (ID 23)	  	  A : Sequence	  x : {x : _ & A x}	  k : nat	  y : {x : _ & A x}	  ============================	  {x : _ & A x}	No more subgoals.	";
            responses[i]=data;
          

            i = 42;
            data = "";
            responses[i]=data;
          

            i = 43;
            data = "";
            responses[i]=data;
          

            i = 44;
            data = "";
            responses[i]=data;
          

            i = 45;
            data = "1 subgoal (ID 26)	  	  A : Sequence	  x : {x : _ & A x}	  k : nat	  ============================	  ((x) ^++) ^++ (k) = (x) ^++ (k.+1)	";
            responses[i]=data;
          

            i = 46;
            data = "";
            responses[i]=data;
          

            i = 47;
            data = "2 subgoals (ID 30)	  	  A : Sequence	  x : {x : _ & A x}	  ============================	  ((x) ^++) ^++ (0) = (x) ^++ (1)		subgoal 2 (ID 33) is:	 ((x) ^++) ^++ (k.+1) = (x) ^++ (k.+2)	";
            responses[i]=data;
          

            i = 48;
            data = "1 subgoal (ID 30)	  	  A : Sequence	  x : {x : _ & A x}	  ============================	  ((x) ^++) ^++ (0) = (x) ^++ (1)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 33)		subgoal 1 (ID 33) is:	 ((x) ^++) ^++ (k.+1) = (x) ^++ (k.+2)	";
            responses[i]=data;
          

            i = 49;
            data = "1 subgoal (ID 33)	  	  A : Sequence	  x : {x : _ & A x}	  k : nat	  q : ((x) ^++) ^++ (k) = (x) ^++ (k.+1)	  ============================	  ((x) ^++) ^++ (k.+1) = (x) ^++ (k.+2)	No more subgoals.	";
            responses[i]=data;
          

            i = 50;
            data = "";
            responses[i]=data;
          

            i = 51;
            data = "1 subgoal (ID 41)	  	  A : Sequence	  a : A 0	  k : nat	  ============================	  ((0; a)) ^++ (k) = (k; (a) ^+ (k))	";
            responses[i]=data;
          

            i = 52;
            data = "";
            responses[i]=data;
          

            i = 53;
            data = "2 subgoals (ID 45)	  	  A : Sequence	  a : A 0	  ============================	  ((0; a)) ^++ (0) = (0; (a) ^+ (0))		subgoal 2 (ID 48) is:	 ((0; a)) ^++ (k.+1) = (k.+1; (a) ^+ (k.+1))	";
            responses[i]=data;
          

            i = 54;
            data = "1 subgoal (ID 45)	  	  A : Sequence	  a : A 0	  ============================	  ((0; a)) ^++ (0) = (0; (a) ^+ (0))	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 48)		subgoal 1 (ID 48) is:	 ((0; a)) ^++ (k.+1) = (k.+1; (a) ^+ (k.+1))	";
            responses[i]=data;
          

            i = 55;
            data = "1 subgoal (ID 48)	  	  A : Sequence	  a : A 0	  k : nat	  q : ((0; a)) ^++ (k) = (k; (a) ^+ (k))	  ============================	  ((0; a)) ^++ (k.+1) = (k.+1; (a) ^+ (k.+1))	No more subgoals.	";
            responses[i]=data;
          

            i = 56;
            data = "";
            responses[i]=data;
          

            i = 57;
            data = "";
            responses[i]=data;
          

            i = 58;
            data = "";
            responses[i]=data;
          

            i = 59;
            data = "";
            responses[i]=data;
          

            i = 60;
            data = "";
            responses[i]=data;
          

            i = 61;
            data = "";
            responses[i]=data;
          

            i = 62;
            data = "";
            responses[i]=data;
          

            i = 63;
            data = "1 subgoal (ID 108)	  	  A : Sequence	  E : Type	  F, G : Colimit A -> E	  h : forall n : Graph.graph0 sequence_graph, F o inj A n == G o inj A n	  H : forall (n : Graph.graph0 sequence_graph) (a : A n),	      ap F (glue A n a) @ h n a = h n.+1 (a) ^+ @ ap G (glue A n a)	  ============================	  F == G	";
            responses[i]=data;
          

            i = 64;
            data = "";
            responses[i]=data;
          

            i = 65;
            data = "1 subgoal (ID 126)	  	  A : Sequence	  E : Type	  F, G : Colimit A -> E	  h : forall n : Graph.graph0 sequence_graph, F o inj A n == G o inj A n	  H : forall (n : Graph.graph0 sequence_graph) (a : A n),	      ap F (glue A n a) @ h n a = h n.+1 (a) ^+ @ ap G (glue A n a)	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  transport (fun w : Colimit A => F w = G w) (colimp n n.+1 1 a)	    (h n.+1 (a) ^+) = h n a	";
            responses[i]=data;
          

            i = 66;
            data = "1 subgoal (ID 142)	  	  A : Sequence	  E : Type	  F, G : Colimit A -> E	  h : forall n : Graph.graph0 sequence_graph, F o inj A n == G o inj A n	  H : forall (n : Graph.graph0 sequence_graph) (a : A n),	      ap F (glue A n a) @ h n a = h n.+1 (a) ^+ @ ap G (glue A n a)	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall p : F (inj A n.+1 (a) ^+) = G (inj A n.+1 (a) ^+),	  ap F 1 @ p = h n.+1 (a) ^+ @ ap G 1 ->	  transport (fun w : Colimit A => F w = G w) 1 (h n.+1 (a) ^+) = p	";
            responses[i]=data;
          

            i = 67;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 68;
            data = "";
            responses[i]=data;
          

            i = 69;
            data = "";
            responses[i]=data;
          

            i = 70;
            data = "";
            responses[i]=data;
          

            i = 71;
            data = "";
            responses[i]=data;
          

            i = 72;
            data = "";
            responses[i]=data;
          

            i = 73;
            data = "<infomsg>succ_seq is defined</infomsg>	";
            responses[i]=data;
          

            i = 74;
            data = "";
            responses[i]=data;
          

            i = 75;
            data = "";
            responses[i]=data;
          

            i = 76;
            data = "";
            responses[i]=data;
          

            i = 77;
            data = "";
            responses[i]=data;
          

            i = 78;
            data = "<infomsg>shift_seq is defined</infomsg>	";
            responses[i]=data;
          

            i = 79;
            data = "";
            responses[i]=data;
          

            i = 80;
            data = "";
            responses[i]=data;
          

            i = 81;
            data = "";
            responses[i]=data;
          

            i = 82;
            data = "";
            responses[i]=data;
          

            i = 83;
            data = "1 subgoal (ID 136)	  	  A : Sequence	  ============================	  Colimit (succ_seq A) -> Colimit A	";
            responses[i]=data;
          

            i = 84;
            data = "";
            responses[i]=data;
          

            i = 85;
            data = "2 subgoals (ID 168)	  	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, succ_seq A i -> Colimit A		subgoal 2 (ID 170) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 ?legs j o (succ_seq A) _f g == ?legs i	";
            responses[i]=data;
          

            i = 86;
            data = "1 subgoal (ID 168)	  	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, succ_seq A i -> Colimit A	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 170)		subgoal 1 (ID 170) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (n : Graph.graph0 sequence_graph) (a : succ_seq A n) => inj A n.+1 a) j	 o (succ_seq A) _f g ==	 (fun (n : Graph.graph0 sequence_graph) (a : succ_seq A n) => inj A n.+1 a) i	";
            responses[i]=data;
          

            i = 87;
            data = "1 subgoal (ID 170)	  	  A : Sequence	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (n : Graph.graph0 sequence_graph) (a : succ_seq A n) => inj A n.+1 a)	    j o (succ_seq A) _f g ==	  (fun (n : Graph.graph0 sequence_graph) (a : succ_seq A n) => inj A n.+1 a)	    i	No more subgoals.	";
            responses[i]=data;
          

            i = 88;
            data = "";
            responses[i]=data;
          

            i = 89;
            data = "1 subgoal (ID 155)	  	  A : Sequence	  n : Graph.graph0 sequence_graph	  a : succ_seq A n	  ============================	  ap (colim_succ_seq_to_colim_seq A) (glue (succ_seq A) n a) = glue A n.+1 a	";
            responses[i]=data;
          

            i = 90;
            data = "";
            responses[i]=data;
          

            i = 91;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 92;
            data = "";
            responses[i]=data;
          

            i = 93;
            data = "1 subgoal (ID 183)	  	  A : Sequence	  n : Graph.graph0 sequence_graph	  a1, a2 : succ_seq A n	  p : a1 = a2	  ============================	  ap (colim_succ_seq_to_colim_seq A) (ap (inj (succ_seq A) n) p) =	  ap (inj A n.+1) p	";
            responses[i]=data;
          

            i = 94;
            data = "";
            responses[i]=data;
          

            i = 95;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 96;
            data = "";
            responses[i]=data;
          

            i = 97;
            data = "1 subgoal (ID 188)	  	  A : Sequence	  ============================	  IsEquiv (colim_succ_seq_to_colim_seq A)	";
            responses[i]=data;
          

            i = 98;
            data = "";
            responses[i]=data;
          

            i = 99;
            data = "3 subgoals (ID 214)	  	  A : Sequence	  ============================	  Colimit A -> Colimit (succ_seq A)		subgoal 2 (ID 216) is:	 Sect ?g (colim_succ_seq_to_colim_seq A)	subgoal 3 (ID 218) is:	 Sect (colim_succ_seq_to_colim_seq A) ?g	";
            responses[i]=data;
          

            i = 100;
            data = "1 subgoal (ID 214)	  	  A : Sequence	  ============================	  Colimit A -> Colimit (succ_seq A)	2 subgoals (ID 250)	  	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> Colimit (succ_seq A)		subgoal 2 (ID 252) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j), ?legs j o A _f g == ?legs i	";
            responses[i]=data;
          

            i = 101;
            data = "1 subgoal (ID 250)	  	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> Colimit (succ_seq A)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 subgoals (ID 252)		subgoal 1 (ID 252) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	  inj (succ_seq A) n (a) ^+) j o A _f g ==	 (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	  inj (succ_seq A) n (a) ^+) i	subgoal 2 (ID 216) is:	 Sect	   (Colimit_rec (Colimit (succ_seq A))	      {|	      legs := fun (n : Graph.graph0 sequence_graph) (a : A n) =>	              inj (succ_seq A) n (a) ^+;	      legs_comm := ?legs_comm |}) (colim_succ_seq_to_colim_seq A)	subgoal 3 (ID 218) is:	 Sect (colim_succ_seq_to_colim_seq A)	   (Colimit_rec (Colimit (succ_seq A))	      {|	      legs := fun (n : Graph.graph0 sequence_graph) (a : A n) =>	              inj (succ_seq A) n (a) ^+;	      legs_comm := ?legs_comm |})	";
            responses[i]=data;
          

            i = 102;
            data = "1 subgoal (ID 252)	  	  A : Sequence	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	   inj (succ_seq A) n (a) ^+) j o A _f g ==	  (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	   inj (succ_seq A) n (a) ^+) i	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 216)		subgoal 1 (ID 216) is:	 Sect	   (Colimit_rec (Colimit (succ_seq A))	      {|	      legs := fun (n : Graph.graph0 sequence_graph) (a : A n) =>	              inj (succ_seq A) n (a) ^+;	      legs_comm := fun (n m : Graph.graph0 sequence_graph)	                     (p : Graph.graph1 sequence_graph n m) 	                     (a : A n) =>	                   match	                     p as p0 in (_ = y)	                     return	                       (inj (succ_seq A) y ((A _f p0) a) ^+ =	                        inj (succ_seq A) n (a) ^+)	                   with	                   | 1 => glue (succ_seq A) n (a) ^+	                   end |}) (colim_succ_seq_to_colim_seq A)	subgoal 2 (ID 218) is:	 Sect (colim_succ_seq_to_colim_seq A)	   (Colimit_rec (Colimit (succ_seq A))	      {|	      legs := fun (n : Graph.graph0 sequence_graph) (a : A n) =>	              inj (succ_seq A) n (a) ^+;	      legs_comm := fun (n m : Graph.graph0 sequence_graph)	                     (p : Graph.graph1 sequence_graph n m) 	                     (a : A n) =>	                   match	                     p as p0 in (_ = y)	                     return	                       (inj (succ_seq A) y ((A _f p0) a) ^+ =	                        inj (succ_seq A) n (a) ^+)	                   with	                   | 1 => glue (succ_seq A) n (a) ^+	                   end |})	";
            responses[i]=data;
          

            i = 103;
            data = "1 subgoal (ID 216)	  	  A : Sequence	  ============================	  Sect	    (Colimit_rec (Colimit (succ_seq A))	       {|	       legs := fun (n : Graph.graph0 sequence_graph) (a : A n) =>	               inj (succ_seq A) n (a) ^+;	       legs_comm := fun (n m : Graph.graph0 sequence_graph)	                      (p : Graph.graph1 sequence_graph n m) 	                      (a : A n) =>	                    match	                      p as p0 in (_ = y)	                      return	                        (inj (succ_seq A) y ((A _f p0) a) ^+ =	                         inj (succ_seq A) n (a) ^+)	                    with	                    | 1 => glue (succ_seq A) n (a) ^+	                    end |}) (colim_succ_seq_to_colim_seq A)	2 subgoals (ID 316)	  	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit A =>	   colim_succ_seq_to_colim_seq A	     (Colimit_rec (Colimit (succ_seq A))	        {|	        legs := fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	                inj (succ_seq A) n0 (a) ^+;	        legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                       (p : Graph.graph1 sequence_graph n0 m) 	                       (a : A n0) =>	                     match	                       p as p0 in (_ = y)	                       return	                         (inj (succ_seq A) y ((A _f p0) a) ^+ =	                          inj (succ_seq A) n0 (a) ^+)	                     with	                     | 1 => glue (succ_seq A) n0 (a) ^+	                     end |} x)) o inj A n == idmap o inj A n		subgoal 2 (ID 318) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n),	 ap	   (fun x : Colimit A =>	    colim_succ_seq_to_colim_seq A	      (Colimit_rec (Colimit (succ_seq A))	         {|	         legs := fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	                 inj (succ_seq A) n0 (a0) ^+;	         legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                        (p : Graph.graph1 sequence_graph n0 m) 	                        (a0 : A n0) =>	                      match	                        p as p0 in (_ = y)	                        return	                          (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                           inj (succ_seq A) n0 (a0) ^+)	                      with	                      | 1 => glue (succ_seq A) n0 (a0) ^+	                      end |} x)) (glue A n a) @ ?h n a =	 ?h n.+1 (a) ^+ @ ap idmap (glue A n a)	";
            responses[i]=data;
          

            i = 104;
            data = "1 subgoal (ID 316)	  	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit A =>	   colim_succ_seq_to_colim_seq A	     (Colimit_rec (Colimit (succ_seq A))	        {|	        legs := fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	                inj (succ_seq A) n0 (a) ^+;	        legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                       (p : Graph.graph1 sequence_graph n0 m) 	                       (a : A n0) =>	                     match	                       p as p0 in (_ = y)	                       return	                         (inj (succ_seq A) y ((A _f p0) a) ^+ =	                          inj (succ_seq A) n0 (a) ^+)	                     with	                     | 1 => glue (succ_seq A) n0 (a) ^+	                     end |} x)) o inj A n == idmap o inj A n	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 subgoals (ID 318)		subgoal 1 (ID 318) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n),	 ap	   (fun x : Colimit A =>	    colim_succ_seq_to_colim_seq A	      (Colimit_rec (Colimit (succ_seq A))	         {|	         legs := fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	                 inj (succ_seq A) n0 (a0) ^+;	         legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                        (p : Graph.graph1 sequence_graph n0 m) 	                        (a0 : A n0) =>	                      match	                        p as p0 in (_ = y)	                        return	                          (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                           inj (succ_seq A) n0 (a0) ^+)	                      with	                      | 1 => glue (succ_seq A) n0 (a0) ^+	                      end |} x)) (glue A n a) @	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) => glue A n0 a0) n a =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) => glue A n0 a0) n.+1	   (a) ^+ @ ap idmap (glue A n a)	subgoal 2 (ID 218) is:	 Sect (colim_succ_seq_to_colim_seq A)	   (Colimit_rec (Colimit (succ_seq A))	      {|	      legs := fun (n : Graph.graph0 sequence_graph) (a : A n) =>	              inj (succ_seq A) n (a) ^+;	      legs_comm := fun (n m : Graph.graph0 sequence_graph)	                     (p : Graph.graph1 sequence_graph n m) 	                     (a : A n) =>	                   match	                     p as p0 in (_ = y)	                     return	                       (inj (succ_seq A) y ((A _f p0) a) ^+ =	                        inj (succ_seq A) n (a) ^+)	                   with	                   | 1 => glue (succ_seq A) n (a) ^+	                   end |})	";
            responses[i]=data;
          

            i = 105;
            data = "1 subgoal (ID 318)	  	  A : Sequence	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n),	  ap	    (fun x : Colimit A =>	     colim_succ_seq_to_colim_seq A	       (Colimit_rec (Colimit (succ_seq A))	          {|	          legs := fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	                  inj (succ_seq A) n0 (a0) ^+;	          legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                         (p : Graph.graph1 sequence_graph n0 m) 	                         (a0 : A n0) =>	                       match	                         p as p0 in (_ = y)	                         return	                           (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                            inj (succ_seq A) n0 (a0) ^+)	                       with	                       | 1 => glue (succ_seq A) n0 (a0) ^+	                       end |} x)) (glue A n a) @	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) => glue A n0 a0) n a =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) => glue A n0 a0) n.+1	    (a) ^+ @ ap idmap (glue A n a)	1 subgoal (ID 344)	  	  A : Sequence	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  ap (colim_succ_seq_to_colim_seq A)	    (legs_comm	       {|	       legs := fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	               inj (succ_seq A) n0 (a0) ^+;	       legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                      (p : Graph.graph1 sequence_graph n0 m) 	                      (a0 : A n0) =>	                    match	                      p as p0 in (_ = y)	                      return	                        (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                         inj (succ_seq A) n0 (a0) ^+)	                    with	                    | 1 => colimp n0 n0.+1 1 (a0) ^+	                    end |} n n.+1 1 a) @ colimp n n.+1 1 a =	  colimp n.+1 n.+2 1 (a) ^+ @ colimp n n.+1 1 a	";
            responses[i]=data;
          

            i = 106;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 218)		subgoal 1 (ID 218) is:	 Sect (colim_succ_seq_to_colim_seq A)	   (Colimit_rec (Colimit (succ_seq A))	      {|	      legs := fun (n : Graph.graph0 sequence_graph) (a : A n) =>	              inj (succ_seq A) n (a) ^+;	      legs_comm := fun (n m : Graph.graph0 sequence_graph)	                     (p : Graph.graph1 sequence_graph n m) 	                     (a : A n) =>	                   match	                     p as p0 in (_ = y)	                     return	                       (inj (succ_seq A) y ((A _f p0) a) ^+ =	                        inj (succ_seq A) n (a) ^+)	                   with	                   | 1 => glue (succ_seq A) n (a) ^+	                   end |})	";
            responses[i]=data;
          

            i = 107;
            data = "1 subgoal (ID 218)	  	  A : Sequence	  ============================	  Sect (colim_succ_seq_to_colim_seq A)	    (Colimit_rec (Colimit (succ_seq A))	       {|	       legs := fun (n : Graph.graph0 sequence_graph) (a : A n) =>	               inj (succ_seq A) n (a) ^+;	       legs_comm := fun (n m : Graph.graph0 sequence_graph)	                      (p : Graph.graph1 sequence_graph n m) 	                      (a : A n) =>	                    match	                      p as p0 in (_ = y)	                      return	                        (inj (succ_seq A) y ((A _f p0) a) ^+ =	                         inj (succ_seq A) n (a) ^+)	                    with	                    | 1 => glue (succ_seq A) n (a) ^+	                    end |})	2 subgoals (ID 382)	  	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (succ_seq A) =>	   Colimit_rec (Colimit (succ_seq A))	     {|	     legs := fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	             inj (succ_seq A) n0 (a) ^+;	     legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                    (p : Graph.graph1 sequence_graph n0 m) 	                    (a : A n0) =>	                  match	                    p as p0 in (_ = y)	                    return	                      (inj (succ_seq A) y ((A _f p0) a) ^+ =	                       inj (succ_seq A) n0 (a) ^+)	                  with	                  | 1 => glue (succ_seq A) n0 (a) ^+	                  end |} (colim_succ_seq_to_colim_seq A x))	  o inj (succ_seq A) n == idmap o inj (succ_seq A) n		subgoal 2 (ID 384) is:	 forall (n : Graph.graph0 sequence_graph) (a : succ_seq A n),	 ap	   (fun x : Colimit (succ_seq A) =>	    Colimit_rec (Colimit (succ_seq A))	      {|	      legs := fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	              inj (succ_seq A) n0 (a0) ^+;	      legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                     (p : Graph.graph1 sequence_graph n0 m) 	                     (a0 : A n0) =>	                   match	                     p as p0 in (_ = y)	                     return	                       (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                        inj (succ_seq A) n0 (a0) ^+)	                   with	                   | 1 => glue (succ_seq A) n0 (a0) ^+	                   end |} (colim_succ_seq_to_colim_seq A x))	   (glue (succ_seq A) n a) @ ?h n a =	 ?h n.+1 (a) ^+ @ ap idmap (glue (succ_seq A) n a)	";
            responses[i]=data;
          

            i = 108;
            data = "1 subgoal (ID 382)	  	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (succ_seq A) =>	   Colimit_rec (Colimit (succ_seq A))	     {|	     legs := fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	             inj (succ_seq A) n0 (a) ^+;	     legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                    (p : Graph.graph1 sequence_graph n0 m) 	                    (a : A n0) =>	                  match	                    p as p0 in (_ = y)	                    return	                      (inj (succ_seq A) y ((A _f p0) a) ^+ =	                       inj (succ_seq A) n0 (a) ^+)	                  with	                  | 1 => glue (succ_seq A) n0 (a) ^+	                  end |} (colim_succ_seq_to_colim_seq A x))	  o inj (succ_seq A) n == idmap o inj (succ_seq A) n	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 subgoal (ID 384)		subgoal 1 (ID 384) is:	 forall (n : Graph.graph0 sequence_graph) (a : succ_seq A n),	 ap	   (fun x : Colimit (succ_seq A) =>	    Colimit_rec (Colimit (succ_seq A))	      {|	      legs := fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	              inj (succ_seq A) n0 (a0) ^+;	      legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                     (p : Graph.graph1 sequence_graph n0 m) 	                     (a0 : A n0) =>	                   match	                     p as p0 in (_ = y)	                     return	                       (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                        inj (succ_seq A) n0 (a0) ^+)	                   with	                   | 1 => glue (succ_seq A) n0 (a0) ^+	                   end |} (colim_succ_seq_to_colim_seq A x))	   (glue (succ_seq A) n a) @	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : succ_seq A n0) =>	  glue (succ_seq A) n0 a0) n a =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : succ_seq A n0) =>	  glue (succ_seq A) n0 a0) n.+1 (a) ^+ @ ap idmap (glue (succ_seq A) n a)	";
            responses[i]=data;
          

            i = 109;
            data = "1 subgoal (ID 384)	  	  A : Sequence	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : succ_seq A n),	  ap	    (fun x : Colimit (succ_seq A) =>	     Colimit_rec (Colimit (succ_seq A))	       {|	       legs := fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	               inj (succ_seq A) n0 (a0) ^+;	       legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                      (p : Graph.graph1 sequence_graph n0 m) 	                      (a0 : A n0) =>	                    match	                      p as p0 in (_ = y)	                      return	                        (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                         inj (succ_seq A) n0 (a0) ^+)	                    with	                    | 1 => glue (succ_seq A) n0 (a0) ^+	                    end |} (colim_succ_seq_to_colim_seq A x))	    (glue (succ_seq A) n a) @	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : succ_seq A n0) =>	   glue (succ_seq A) n0 a0) n a =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : succ_seq A n0) =>	   glue (succ_seq A) n0 a0) n.+1 (a) ^+ @ ap idmap (glue (succ_seq A) n a)	1 subgoal (ID 410)	  	  A : Sequence	  n : Graph.graph0 sequence_graph	  a : succ_seq A n	  ============================	  ap	    (Colimit_rec (Colimit (succ_seq A))	       {|	       legs := fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	               inj (succ_seq A) n0 (a0) ^+;	       legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                      (p : Graph.graph1 sequence_graph n0 m) 	                      (a0 : A n0) =>	                    match	                      p as p0 in (_ = y)	                      return	                        (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                         inj (succ_seq A) n0 (a0) ^+)	                    with	                    | 1 => colimp n0 n0.+1 1 (a0) ^+	                    end |})	    (legs_comm	       {|	       legs := fun (n0 : Graph.graph0 sequence_graph) (a0 : succ_seq A n0) =>	               inj A n0.+1 a0;	       legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                      (p : Graph.graph1 sequence_graph n0 m) =>	                    match	                      p as p0 in (_ = y)	                      return	                        ((fun x : succ_seq A n0 =>	                          inj A y.+1 (((succ_seq A) _f p0) x)) ==	                         (fun a0 : succ_seq A n0 => inj A n0.+1 a0))	                    with	                    | 1 => colimp n0.+1 n0.+2 1	                    end |} n n.+1 1 a) @ colimp n n.+1 1 a =	  colimp n.+1 n.+2 1 (a) ^+ @ colimp n n.+1 1 a	";
            responses[i]=data;
          

            i = 110;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 111;
            data = "";
            responses[i]=data;
          

            i = 112;
            data = "<infomsg>equiv_colim_succ_seq_to_colim_seq is defined</infomsg>	";
            responses[i]=data;
          

            i = 113;
            data = "";
            responses[i]=data;
          

            i = 114;
            data = "";
            responses[i]=data;
          

            i = 115;
            data = "";
            responses[i]=data;
          

            i = 116;
            data = "";
            responses[i]=data;
          

            i = 117;
            data = "1 subgoal (ID 204)	  	  A : Sequence	  n : nat	  ============================	  Colimit (shift_seq A n) -> Colimit A	";
            responses[i]=data;
          

            i = 118;
            data = "";
            responses[i]=data;
          

            i = 119;
            data = "2 subgoals (ID 236)	  	  A : Sequence	  n : nat	  ============================	  forall i : Graph.graph0 sequence_graph, shift_seq A n i -> Colimit A		subgoal 2 (ID 238) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 ?legs j o (shift_seq A n) _f g == ?legs i	";
            responses[i]=data;
          

            i = 120;
            data = "1 subgoal (ID 236)	  	  A : Sequence	  n : nat	  ============================	  forall i : Graph.graph0 sequence_graph, shift_seq A n i -> Colimit A	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 238)		subgoal 1 (ID 238) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (k : Graph.graph0 sequence_graph) (a : shift_seq A n k) =>	  inj A (k + n)%nat a) j o (shift_seq A n) _f g ==	 (fun (k : Graph.graph0 sequence_graph) (a : shift_seq A n k) =>	  inj A (k + n)%nat a) i	";
            responses[i]=data;
          

            i = 121;
            data = "1 subgoal (ID 238)	  	  A : Sequence	  n : nat	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (k : Graph.graph0 sequence_graph) (a : shift_seq A n k) =>	   inj A (k + n)%nat a) j o (shift_seq A n) _f g ==	  (fun (k : Graph.graph0 sequence_graph) (a : shift_seq A n k) =>	   inj A (k + n)%nat a) i	No more subgoals.	";
            responses[i]=data;
          

            i = 122;
            data = "";
            responses[i]=data;
          

            i = 123;
            data = "1 subgoal (ID 225)	  	  A : Sequence	  n : nat	  k : Graph.graph0 sequence_graph	  a : shift_seq A n k	  ============================	  ap (colim_shift_seq_to_colim_seq A n) (glue (shift_seq A n) k a) =	  glue A (k + n)%nat a	";
            responses[i]=data;
          

            i = 124;
            data = "";
            responses[i]=data;
          

            i = 125;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 126;
            data = "";
            responses[i]=data;
          

            i = 127;
            data = "1 subgoal (ID 255)	  	  A : Sequence	  n : nat	  k : Graph.graph0 sequence_graph	  a1, a2 : shift_seq A n k	  p : a1 = a2	  ============================	  ap (colim_shift_seq_to_colim_seq A n) (ap (inj (shift_seq A n) k) p) =	  ap (inj A (k + n)%nat) p	";
            responses[i]=data;
          

            i = 128;
            data = "";
            responses[i]=data;
          

            i = 129;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 130;
            data = "";
            responses[i]=data;
          

            i = 131;
            data = "1 subgoal (ID 287)	  	  X : Type	  Y : X -> Type	  Z : Type	  x1, x2 : X	  y : Y x2	  I : forall x : X, Y x -> Z	  p : x1 = x2	  ============================	  I x2 y = I x1 (coe (ap Y p^) y)	";
            responses[i]=data;
          

            i = 132;
            data = "";
            responses[i]=data;
          

            i = 133;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 134;
            data = "";
            responses[i]=data;
          

            i = 135;
            data = "1 subgoal (ID 340)	  	  X : Type	  Y : X -> Type	  x1, x2 : X	  y : Y x1	  F : X -> X	  G : forall x : X, Y x -> Y (F x)	  p : x1 = x2	  ============================	  G x2 (coe (ap Y p) y) = coe (ap Y (ap F p)) (G x1 y)	";
            responses[i]=data;
          

            i = 136;
            data = "";
            responses[i]=data;
          

            i = 137;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 138;
            data = "";
            responses[i]=data;
          

            i = 139;
            data = "1 subgoal (ID 471)	  	  X : Type	  Y : X -> Type	  Z : Type	  x1, x2 : X	  y : Y x2	  F : X -> X	  G : forall x : X, Y x -> Y (F x)	  I : forall x : X, Y x -> Z	  p : x1 = x2	  Q : forall (x : X) (y : Y x), I (F x) (G x y) = I x y	  ============================	  Q x2 y @ J p =	  J (ap F p) @	  (ap (I (F x1)) (K F G p^ @ ap10 (ap coe (ap (ap Y) (ap_V F p))) (G x2 y))^ @	   Q x1 (coe (ap Y p^) y))	";
            responses[i]=data;
          

            i = 140;
            data = "";
            responses[i]=data;
          

            i = 141;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 142;
            data = "";
            responses[i]=data;
          

            i = 143;
            data = "1 subgoal (ID 479)	  	  H : Funext	  A : Sequence	  n : nat	  ============================	  IsEquiv (colim_shift_seq_to_colim_seq A n)	";
            responses[i]=data;
          

            i = 144;
            data = "";
            responses[i]=data;
          

            i = 145;
            data = "4 subgoals (ID 502)	  	  H : Funext	  A : Sequence	  ============================	  Colimit (shift_seq A 0) <~> Colimit A		subgoal 2 (ID 506) is:	 ?f == colim_shift_seq_to_colim_seq A 0	subgoal 3 (ID 522) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	subgoal 4 (ID 526) is:	 ?f0 == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 146;
            data = "1 subgoal (ID 502)	  	  H : Funext	  A : Sequence	  ============================	  Colimit (shift_seq A 0) <~> Colimit A	2 subgoals (ID 612)	  	  H : Funext	  A : Sequence	  ============================	  DiagramMap (shift_seq A 0) A		subgoal 2 (ID 614) is:	 forall i : Graph.graph0 sequence_graph, IsEquiv (?m i)	";
            responses[i]=data;
          

            i = 147;
            data = "1 subgoal (ID 612)	  	  H : Funext	  A : Sequence	  ============================	  DiagramMap (shift_seq A 0) A	2 subgoals (ID 655)	  	  H : Funext	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, shift_seq A 0 i -> A i		subgoal 2 (ID 657) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : shift_seq A 0 i),	 (A _f g) (?DiagramMap_obj i x) =	 ?DiagramMap_obj j (((shift_seq A 0) _f g) x)	";
            responses[i]=data;
          

            i = 148;
            data = "1 subgoal (ID 655)	  	  H : Funext	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, shift_seq A 0 i -> A i	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	5 subgoals (ID 657)		subgoal 1 (ID 657) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : shift_seq A 0 i),	 (A _f g)	   ((fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_O k)^)) i x) =	 (fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_O k)^)) j	   (((shift_seq A 0) _f g) x)	subgoal 2 (ID 614) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	    DiagramMap_obj := fun k : Graph.graph0 sequence_graph =>	                      coe (ap A (nat_plus_n_O k)^);	    DiagramMap_comm := ?DiagramMap_comm |} i)	subgoal 3 (ID 506) is:	 equiv_functor_colimit	   {|	   diag_equiv_map := {|	                     DiagramMap_obj := fun k : Graph.graph0 sequence_graph =>	                                       coe (ap A (nat_plus_n_O k)^);	                     DiagramMap_comm := ?DiagramMap_comm |};	   diag_equiv_isequiv := ?H |} (iscolimit_colimit (shift_seq A 0))	   (iscolimit_colimit A) == colim_shift_seq_to_colim_seq A 0	subgoal 4 (ID 522) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	subgoal 5 (ID 526) is:	 ?f == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 149;
            data = "1 subgoal (ID 657)	  	  H : Funext	  A : Sequence	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : shift_seq A 0 i),	  (A _f g)	    ((fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_O k)^)) i	       x) =	  (fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_O k)^)) j	    (((shift_seq A 0) _f g) x)	1 subgoal (ID 702)	  	  H : Funext	  A : Sequence	  k : Graph.graph0 sequence_graph	  a : shift_seq A 0 k	  ============================	  coe (ap A (ap S (nat_plus_n_O k)^))	    ((fun (n : nat) (a0 : A n) => (a0) ^+) (k + 0)%nat a) =	  coe (ap A (nat_plus_n_O k.+1)^) (a) ^+	";
            responses[i]=data;
          

            i = 150;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	4 subgoals (ID 614)		subgoal 1 (ID 614) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	    DiagramMap_obj := fun k : Graph.graph0 sequence_graph =>	                      coe (ap A (nat_plus_n_O k)^);	    DiagramMap_comm := fun (k l : Graph.graph0 sequence_graph)	                         (p : Graph.graph1 sequence_graph k l)	                         (a : shift_seq A 0 k) =>	                       match	                         p as p0 in (_ = y)	                         return	                           ((A _f p0) (coe (ap A (nat_plus_n_O k)^) a) =	                            coe (ap A (nat_plus_n_O y)^)	                              (((shift_seq A 0) _f p0) a))	                       with	                       | 1 =>	                           K S (fun (n : nat) (a0 : A n) => (a0) ^+)	                             (nat_plus_n_O k)^ @	                           ap10	                             (ap coe (ap (ap A) (ap_V S (nat_plus_n_O k))))	                             (a) ^+	                       end |} i)	subgoal 2 (ID 506) is:	 equiv_functor_colimit	   {|	   diag_equiv_map := {|	                     DiagramMap_obj := fun k : Graph.graph0 sequence_graph =>	                                       coe (ap A (nat_plus_n_O k)^);	                     DiagramMap_comm := fun	                                          (k l : Graph.graph0 sequence_graph)	                                          (p : Graph.graph1 sequence_graph k	                                                 l) 	                                          (a : shift_seq A 0 k) =>	                                        match	                                          p as p0 in (_ = y)	                                          return	                                            ((A _f p0)	                                               (coe 	                                                 (ap A (nat_plus_n_O k)^) a) =	                                             coe (ap A (nat_plus_n_O y)^)	                                               (((shift_seq A 0) _f p0) a))	                                        with	                                        | 1 =>	                                            K S	                                              (fun (n : nat) (a0 : A n) =>	                                               (a0) ^+) 	                                              (nat_plus_n_O k)^ @	                                            ap10	                                              (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_O k))))	                                              (a) ^+	                                        end |};	   diag_equiv_isequiv := ?H |} (iscolimit_colimit (shift_seq A 0))	   (iscolimit_colimit A) == colim_shift_seq_to_colim_seq A 0	subgoal 3 (ID 522) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	subgoal 4 (ID 526) is:	 ?f == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 151;
            data = "1 subgoal (ID 614)	  	  H : Funext	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph,	  IsEquiv	    ({|	     DiagramMap_obj := fun k : Graph.graph0 sequence_graph =>	                       coe (ap A (nat_plus_n_O k)^);	     DiagramMap_comm := fun (k l : Graph.graph0 sequence_graph)	                          (p : Graph.graph1 sequence_graph k l)	                          (a : shift_seq A 0 k) =>	                        match	                          p as p0 in (_ = y)	                          return	                            ((A _f p0) (coe (ap A (nat_plus_n_O k)^) a) =	                             coe (ap A (nat_plus_n_O y)^)	                               (((shift_seq A 0) _f p0) a))	                        with	                        | 1 =>	                            K S (fun (n : nat) (a0 : A n) => (a0) ^+)	                              (nat_plus_n_O k)^ @	                            ap10	                              (ap coe (ap (ap A) (ap_V S (nat_plus_n_O k))))	                              (a) ^+	                        end |} i)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 subgoals (ID 506)		subgoal 1 (ID 506) is:	 equiv_functor_colimit	   {|	   diag_equiv_map := {|	                     DiagramMap_obj := fun k : Graph.graph0 sequence_graph =>	                                       coe (ap A (nat_plus_n_O k)^);	                     DiagramMap_comm := fun	                                          (k l : Graph.graph0 sequence_graph)	                                          (p : Graph.graph1 sequence_graph k	                                                 l) 	                                          (a : shift_seq A 0 k) =>	                                        match	                                          p as p0 in (_ = y)	                                          return	                                            ((A _f p0)	                                               (coe 	                                                 (ap A (nat_plus_n_O k)^) a) =	                                             coe (ap A (nat_plus_n_O y)^)	                                               (((shift_seq A 0) _f p0) a))	                                        with	                                        | 1 =>	                                            K S	                                              (fun (n : nat) (a0 : A n) =>	                                               (a0) ^+) 	                                              (nat_plus_n_O k)^ @	                                            ap10	                                              (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_O k))))	                                              (a) ^+	                                        end |};	   diag_equiv_isequiv := fun k : Graph.graph0 sequence_graph =>	                         isequiv_path (ap A (nat_plus_n_O k)^) |}	   (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A) ==	 colim_shift_seq_to_colim_seq A 0	subgoal 2 (ID 522) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	subgoal 3 (ID 526) is:	 ?f == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 152;
            data = "1 subgoal (ID 506)	  	  H : Funext	  A : Sequence	  ============================	  equiv_functor_colimit	    {|	    diag_equiv_map := {|	                      DiagramMap_obj := fun k : Graph.graph0 sequence_graph	                                        => coe (ap A (nat_plus_n_O k)^);	                      DiagramMap_comm := fun	                                           (k	                                            l : Graph.graph0 sequence_graph)	                                           (p : Graph.graph1 sequence_graph k	                                                 l) 	                                           (a : shift_seq A 0 k) =>	                                         match	                                           p as p0 in (_ = y)	                                           return	                                             ((A _f p0)	                                                (coe 	                                                 (ap A (nat_plus_n_O k)^) a) =	                                              coe 	                                                (ap A (nat_plus_n_O y)^)	                                                (((shift_seq A 0) _f p0) a))	                                         with	                                         | 1 =>	                                             K S	                                               (fun (n : nat) (a0 : A n) =>	                                                (a0) ^+) 	                                               (nat_plus_n_O k)^ @	                                             ap10	                                               (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_O k))))	                                               (a) ^+	                                         end |};	    diag_equiv_isequiv := fun k : Graph.graph0 sequence_graph =>	                          isequiv_path (ap A (nat_plus_n_O k)^) |}	    (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A) ==	  colim_shift_seq_to_colim_seq A 0	2 subgoals (ID 817)	  	  H : Funext	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  colim_shift_seq_to_colim_seq A 0 o inj (shift_seq A 0) n ==	  equiv_functor_colimit	    {|	    diag_equiv_map := {|	                      DiagramMap_obj := fun k : Graph.graph0 sequence_graph	                                        => coe (ap A (nat_plus_n_O k)^);	                      DiagramMap_comm := fun	                                           (k	                                            l : Graph.graph0 sequence_graph)	                                           (p : Graph.graph1 sequence_graph k	                                                 l) 	                                           (a : shift_seq A 0 k) =>	                                         match	                                           p as p0 in (_ = y)	                                           return	                                             ((A _f p0)	                                                (coe 	                                                 (ap A (nat_plus_n_O k)^) a) =	                                              coe 	                                                (ap A (nat_plus_n_O y)^)	                                                (((shift_seq A 0) _f p0) a))	                                         with	                                         | 1 =>	                                             K S	                                               (fun (n0 : nat) (a0 : A n0) =>	                                                (a0) ^+) 	                                               (nat_plus_n_O k)^ @	                                             ap10	                                               (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_O k))))	                                               (a) ^+	                                         end |};	    diag_equiv_isequiv := fun k : Graph.graph0 sequence_graph =>	                          isequiv_path (ap A (nat_plus_n_O k)^) |}	    (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A)	  o inj (shift_seq A 0) n		subgoal 2 (ID 819) is:	 forall (n : Graph.graph0 sequence_graph) (a : shift_seq A 0 n),	 ap (colim_shift_seq_to_colim_seq A 0) (glue (shift_seq A 0) n a) @ ?h0 n a =	 ?h0 n.+1 (a) ^+ @	 ap	   (equiv_functor_colimit	      {|	      diag_equiv_map := {|	                        DiagramMap_obj := fun k : Graph.graph0 sequence_graph	                                          => coe (ap A (nat_plus_n_O k)^);	                        DiagramMap_comm := fun	                                             (k	                                              l : 	                                              Graph.graph0 sequence_graph)	                                             (p : 	                                              Graph.graph1 sequence_graph k l)	                                             (a0 : shift_seq A 0 k) =>	                                           match	                                             p as p0 in (_ = y)	                                             return	                                               ((A _f p0)	                                                 (coe	                                                 (ap A (nat_plus_n_O k)^) a0) =	                                                coe 	                                                 (ap A (nat_plus_n_O y)^)	                                                 (((shift_seq A 0) _f p0) a0))	                                           with	                                           | 1 =>	                                               K S	                                                 (fun (n0 : nat) (a1 : A n0)	                                                 => 	                                                 (a1) ^+) 	                                                 (nat_plus_n_O k)^ @	                                               ap10	                                                 (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_O k))))	                                                 (a0) ^+	                                           end |};	      diag_equiv_isequiv := fun k : Graph.graph0 sequence_graph =>	                            isequiv_path (ap A (nat_plus_n_O k)^) |}	      (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A))	   (glue (shift_seq A 0) n a)	";
            responses[i]=data;
          

            i = 153;
            data = "1 subgoal (ID 817)	  	  H : Funext	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  colim_shift_seq_to_colim_seq A 0 o inj (shift_seq A 0) n ==	  equiv_functor_colimit	    {|	    diag_equiv_map := {|	                      DiagramMap_obj := fun k : Graph.graph0 sequence_graph	                                        => coe (ap A (nat_plus_n_O k)^);	                      DiagramMap_comm := fun	                                           (k	                                            l : Graph.graph0 sequence_graph)	                                           (p : Graph.graph1 sequence_graph k	                                                 l) 	                                           (a : shift_seq A 0 k) =>	                                         match	                                           p as p0 in (_ = y)	                                           return	                                             ((A _f p0)	                                                (coe 	                                                 (ap A (nat_plus_n_O k)^) a) =	                                              coe 	                                                (ap A (nat_plus_n_O y)^)	                                                (((shift_seq A 0) _f p0) a))	                                         with	                                         | 1 =>	                                             K S	                                               (fun (n0 : nat) (a0 : A n0) =>	                                                (a0) ^+) 	                                               (nat_plus_n_O k)^ @	                                             ap10	                                               (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_O k))))	                                               (a) ^+	                                         end |};	    diag_equiv_isequiv := fun k : Graph.graph0 sequence_graph =>	                          isequiv_path (ap A (nat_plus_n_O k)^) |}	    (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A)	  o inj (shift_seq A 0) n	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 subgoals (ID 819)		subgoal 1 (ID 819) is:	 forall (n : Graph.graph0 sequence_graph) (a : shift_seq A 0 n),	 ap (colim_shift_seq_to_colim_seq A 0) (glue (shift_seq A 0) n a) @	 (fun (k : Graph.graph0 sequence_graph) (a0 : shift_seq A 0 k) =>	  J (nat_plus_n_O k)) n a =	 (fun (k : Graph.graph0 sequence_graph) (a0 : shift_seq A 0 k) =>	  J (nat_plus_n_O k)) n.+1 (a) ^+ @	 ap	   (equiv_functor_colimit	      {|	      diag_equiv_map := {|	                        DiagramMap_obj := fun k : Graph.graph0 sequence_graph	                                          => coe (ap A (nat_plus_n_O k)^);	                        DiagramMap_comm := fun	                                             (k	                                              l : 	                                              Graph.graph0 sequence_graph)	                                             (p : 	                                              Graph.graph1 sequence_graph k l)	                                             (a0 : shift_seq A 0 k) =>	                                           match	                                             p as p0 in (_ = y)	                                             return	                                               ((A _f p0)	                                                 (coe	                                                 (ap A (nat_plus_n_O k)^) a0) =	                                                coe 	                                                 (ap A (nat_plus_n_O y)^)	                                                 (((shift_seq A 0) _f p0) a0))	                                           with	                                           | 1 =>	                                               K S	                                                 (fun (n0 : nat) (a1 : A n0)	                                                 => 	                                                 (a1) ^+) 	                                                 (nat_plus_n_O k)^ @	                                               ap10	                                                 (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_O k))))	                                                 (a0) ^+	                                           end |};	      diag_equiv_isequiv := fun k : Graph.graph0 sequence_graph =>	                            isequiv_path (ap A (nat_plus_n_O k)^) |}	      (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A))	   (glue (shift_seq A 0) n a)	subgoal 2 (ID 522) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	subgoal 3 (ID 526) is:	 ?f == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 154;
            data = "1 subgoal (ID 819)	  	  H : Funext	  A : Sequence	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : shift_seq A 0 n),	  ap (colim_shift_seq_to_colim_seq A 0) (glue (shift_seq A 0) n a) @	  (fun (k : Graph.graph0 sequence_graph) (a0 : shift_seq A 0 k) =>	   J (nat_plus_n_O k)) n a =	  (fun (k : Graph.graph0 sequence_graph) (a0 : shift_seq A 0 k) =>	   J (nat_plus_n_O k)) n.+1 (a) ^+ @	  ap	    (equiv_functor_colimit	       {|	       diag_equiv_map := {|	                         DiagramMap_obj := fun	                                             k : Graph.graph0 sequence_graph	                                           => coe (ap A (nat_plus_n_O k)^);	                         DiagramMap_comm := fun	                                              (k	                                               l : 	                                               Graph.graph0 sequence_graph)	                                              (p : 	                                               Graph.graph1 sequence_graph k	                                                 l) 	                                              (a0 : shift_seq A 0 k) =>	                                            match	                                              p as p0 in (_ = y)	                                              return	                                                ((A _f p0)	                                                 (coe	                                                 (ap A (nat_plus_n_O k)^) a0) =	                                                 coe 	                                                 (ap A (nat_plus_n_O y)^)	                                                 (((shift_seq A 0) _f p0) a0))	                                            with	                                            | 1 =>	                                                K S	                                                 (fun (n0 : nat) (a1 : A n0)	                                                 => 	                                                 (a1) ^+) 	                                                 (nat_plus_n_O k)^ @	                                                ap10	                                                 (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_O k))))	                                                 (a0) ^+	                                            end |};	       diag_equiv_isequiv := fun k : Graph.graph0 sequence_graph =>	                             isequiv_path (ap A (nat_plus_n_O k)^) |}	       (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A))	    (glue (shift_seq A 0) n a)	";
            responses[i]=data;
          

            i = 155;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 subgoals (ID 522)		subgoal 1 (ID 522) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	subgoal 2 (ID 526) is:	 ?f == colim_shift_seq_to_colim_seq A n.+1	1 subgoal (ID 522)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  Colimit (shift_seq A n.+1) <~> Colimit A	2 subgoals (ID 867)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  Colimit (shift_seq A n.+1) <~> Colimit (succ_seq (shift_seq A n))		subgoal 2 (ID 869) is:	 Colimit (succ_seq (shift_seq A n)) <~> Colimit A	";
            responses[i]=data;
          

            i = 156;
            data = "1 subgoal (ID 867)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  Colimit (shift_seq A n.+1) <~> Colimit (succ_seq (shift_seq A n))	2 subgoals (ID 955)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  DiagramMap (shift_seq A n.+1) (succ_seq (shift_seq A n))		subgoal 2 (ID 957) is:	 forall i : Graph.graph0 sequence_graph, IsEquiv (?m i)	";
            responses[i]=data;
          

            i = 157;
            data = "1 subgoal (ID 955)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  DiagramMap (shift_seq A n.+1) (succ_seq (shift_seq A n))	2 subgoals (ID 998)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall i : Graph.graph0 sequence_graph,	  shift_seq A n.+1 i -> succ_seq (shift_seq A n) i		subgoal 2 (ID 1000) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : shift_seq A n.+1 i),	 ((succ_seq (shift_seq A n)) _f g) (?DiagramMap_obj i x) =	 ?DiagramMap_obj j (((shift_seq A n.+1) _f g) x)	";
            responses[i]=data;
          

            i = 158;
            data = "1 subgoal (ID 998)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall i : Graph.graph0 sequence_graph,	  shift_seq A n.+1 i -> succ_seq (shift_seq A n) i	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	4 subgoals (ID 1000)		subgoal 1 (ID 1000) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : shift_seq A n.+1 i),	 ((succ_seq (shift_seq A n)) _f g)	   ((fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_Sm k n)^))	      i x) =	 (fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_Sm k n)^)) j	   (((shift_seq A n.+1) _f g) x)	subgoal 2 (ID 957) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	    DiagramMap_obj := fun k : Graph.graph0 sequence_graph =>	                      coe (ap A (nat_plus_n_Sm k n)^);	    DiagramMap_comm := ?DiagramMap_comm |} i)	subgoal 3 (ID 869) is:	 Colimit (succ_seq (shift_seq A n)) <~> Colimit A	subgoal 4 (ID 526) is:	 transitive_equiv (Colimit (shift_seq A n.+1))	   (Colimit (succ_seq (shift_seq A n))) (Colimit A)	   (equiv_functor_colimit	      {|	      diag_equiv_map := {|	                        DiagramMap_obj := fun k : Graph.graph0 sequence_graph	                                          => coe (ap A (nat_plus_n_Sm k n)^);	                        DiagramMap_comm := ?DiagramMap_comm |};	      diag_equiv_isequiv := ?H |} (iscolimit_colimit (shift_seq A n.+1))	      (iscolimit_colimit (succ_seq (shift_seq A n)))) 	   ?Goal == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 159;
            data = "1 subgoal (ID 1000)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : shift_seq A n.+1 i),	  ((succ_seq (shift_seq A n)) _f g)	    ((fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_Sm k n)^))	       i x) =	  (fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_Sm k n)^)) j	    (((shift_seq A n.+1) _f g) x)	1 subgoal (ID 1000)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : shift_seq A n.+1 i),	  ((succ_seq (shift_seq A n)) _f g)	    ((fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_Sm k n)^))	       i x) =	  (fun k : Graph.graph0 sequence_graph => coe (ap A (nat_plus_n_Sm k n)^)) j	    (((shift_seq A n.+1) _f g) x)	1 subgoal (ID 1047)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  k : Graph.graph0 sequence_graph	  a : shift_seq A n.+1 k	  ============================	  coe (ap A (ap S (nat_plus_n_Sm k n)^)) (a) ^+ =	  coe (ap A (nat_plus_n_Sm k.+1 n)^) (a) ^+	";
            responses[i]=data;
          

            i = 160;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 subgoals (ID 957)		subgoal 1 (ID 957) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	    DiagramMap_obj := fun k : Graph.graph0 sequence_graph =>	                      coe (ap A (nat_plus_n_Sm k n)^);	    DiagramMap_comm := fun (k l : Graph.graph0 sequence_graph)	                         (p : Graph.graph1 sequence_graph k l)	                         (a : shift_seq A n.+1 k) =>	                       match	                         p as p0 in (_ = y)	                         return	                           (((succ_seq (shift_seq A n)) _f p0)	                              (coe (ap A (nat_plus_n_Sm k n)^) a) =	                            coe (ap A (nat_plus_n_Sm y n)^)	                              (((shift_seq A n.+1) _f p0) a))	                       with	                       | 1 =>	                           K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+)	                             (nat_plus_n_Sm k n)^ @	                           ap10	                             (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k n))))	                             (a) ^+	                       end |} i)	subgoal 2 (ID 869) is:	 Colimit (succ_seq (shift_seq A n)) <~> Colimit A	subgoal 3 (ID 526) is:	 transitive_equiv (Colimit (shift_seq A n.+1))	   (Colimit (succ_seq (shift_seq A n))) (Colimit A)	   (equiv_functor_colimit	      {|	      diag_equiv_map := {|	                        DiagramMap_obj := fun k : Graph.graph0 sequence_graph	                                          => coe (ap A (nat_plus_n_Sm k n)^);	                        DiagramMap_comm := fun	                                             (k	                                              l : 	                                              Graph.graph0 sequence_graph)	                                             (p : 	                                              Graph.graph1 sequence_graph k l)	                                             (a : shift_seq A n.+1 k) =>	                                           match	                                             p as p0 in (_ = y)	                                             return	                                               (((succ_seq (shift_seq A n))	                                                 _f p0)	                                                 (coe	                                                 (ap A (nat_plus_n_Sm k n)^)	                                                 a) =	                                                coe	                                                 (ap A (nat_plus_n_Sm y n)^)	                                                 (((shift_seq A n.+1) _f p0)	                                                 a))	                                           with	                                           | 1 =>	                                               K S	                                                 (fun (n0 : nat) (a0 : A n0)	                                                 => 	                                                 (a0) ^+)	                                                 (nat_plus_n_Sm k n)^ @	                                               ap10	                                                 (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_Sm k n))))	                                                 (a) ^+	                                           end |};	      diag_equiv_isequiv := ?H |} (iscolimit_colimit (shift_seq A n.+1))	      (iscolimit_colimit (succ_seq (shift_seq A n)))) 	   ?Goal == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 161;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 subgoals (ID 957)		subgoal 1 (ID 957) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	    DiagramMap_obj := fun k : Graph.graph0 sequence_graph =>	                      coe (ap A (nat_plus_n_Sm k n)^);	    DiagramMap_comm := fun (k l : Graph.graph0 sequence_graph)	                         (p : Graph.graph1 sequence_graph k l)	                         (a : shift_seq A n.+1 k) =>	                       match	                         p as p0 in (_ = y)	                         return	                           (((succ_seq (shift_seq A n)) _f p0)	                              (coe (ap A (nat_plus_n_Sm k n)^) a) =	                            coe (ap A (nat_plus_n_Sm y n)^)	                              (((shift_seq A n.+1) _f p0) a))	                       with	                       | 1 =>	                           K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+)	                             (nat_plus_n_Sm k n)^ @	                           ap10	                             (ap coe (ap (ap A) (ap_V S (nat_plus_n_Sm k n))))	                             (a) ^+	                       end |} i)	subgoal 2 (ID 869) is:	 Colimit (succ_seq (shift_seq A n)) <~> Colimit A	subgoal 3 (ID 526) is:	 transitive_equiv (Colimit (shift_seq A n.+1))	   (Colimit (succ_seq (shift_seq A n))) (Colimit A)	   (equiv_functor_colimit	      {|	      diag_equiv_map := {|	                        DiagramMap_obj := fun k : Graph.graph0 sequence_graph	                                          => coe (ap A (nat_plus_n_Sm k n)^);	                        DiagramMap_comm := fun	                                             (k	                                              l : 	                                              Graph.graph0 sequence_graph)	                                             (p : 	                                              Graph.graph1 sequence_graph k l)	                                             (a : shift_seq A n.+1 k) =>	                                           match	                                             p as p0 in (_ = y)	                                             return	                                               (((succ_seq (shift_seq A n))	                                                 _f p0)	                                                 (coe	                                                 (ap A (nat_plus_n_Sm k n)^)	                                                 a) =	                                                coe	                                                 (ap A (nat_plus_n_Sm y n)^)	                                                 (((shift_seq A n.+1) _f p0)	                                                 a))	                                           with	                                           | 1 =>	                                               K S	                                                 (fun (n0 : nat) (a0 : A n0)	                                                 => 	                                                 (a0) ^+)	                                                 (nat_plus_n_Sm k n)^ @	                                               ap10	                                                 (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_Sm k n))))	                                                 (a) ^+	                                           end |};	      diag_equiv_isequiv := ?H |} (iscolimit_colimit (shift_seq A n.+1))	      (iscolimit_colimit (succ_seq (shift_seq A n)))) 	   ?Goal == colim_shift_seq_to_colim_seq A n.+1	1 subgoal (ID 957)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall i : Graph.graph0 sequence_graph,	  IsEquiv	    ({|	     DiagramMap_obj := fun k : Graph.graph0 sequence_graph =>	                       coe (ap A (nat_plus_n_Sm k n)^);	     DiagramMap_comm := fun (k l : Graph.graph0 sequence_graph)	                          (p : Graph.graph1 sequence_graph k l)	                          (a : shift_seq A n.+1 k) =>	                        match	                          p as p0 in (_ = y)	                          return	                            (((succ_seq (shift_seq A n)) _f p0)	                               (coe (ap A (nat_plus_n_Sm k n)^) a) =	                             coe (ap A (nat_plus_n_Sm y n)^)	                               (((shift_seq A n.+1) _f p0) a))	                        with	                        | 1 =>	                            K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+)	                              (nat_plus_n_Sm k n)^ @	                            ap10	                              (ap coe	                                 (ap (ap A) (ap_V S (nat_plus_n_Sm k n))))	                              (a) ^+	                        end |} i)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 869)		subgoal 1 (ID 869) is:	 Colimit (succ_seq (shift_seq A n)) <~> Colimit A	subgoal 2 (ID 526) is:	 transitive_equiv (Colimit (shift_seq A n.+1))	   (Colimit (succ_seq (shift_seq A n))) (Colimit A)	   (equiv_functor_colimit	      {|	      diag_equiv_map := {|	                        DiagramMap_obj := fun k : Graph.graph0 sequence_graph	                                          => coe (ap A (nat_plus_n_Sm k n)^);	                        DiagramMap_comm := fun	                                             (k	                                              l : 	                                              Graph.graph0 sequence_graph)	                                             (p : 	                                              Graph.graph1 sequence_graph k l)	                                             (a : shift_seq A n.+1 k) =>	                                           match	                                             p as p0 in (_ = y)	                                             return	                                               (((succ_seq (shift_seq A n))	                                                 _f p0)	                                                 (coe	                                                 (ap A (nat_plus_n_Sm k n)^)	                                                 a) =	                                                coe	                                                 (ap A (nat_plus_n_Sm y n)^)	                                                 (((shift_seq A n.+1) _f p0)	                                                 a))	                                           with	                                           | 1 =>	                                               K S	                                                 (fun (n0 : nat) (a0 : A n0)	                                                 => 	                                                 (a0) ^+)	                                                 (nat_plus_n_Sm k n)^ @	                                               ap10	                                                 (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_Sm k n))))	                                                 (a) ^+	                                           end |};	      diag_equiv_isequiv := fun k : Graph.graph0 sequence_graph =>	                            isequiv_path (ap A (nat_plus_n_Sm k n)^) |}	      (iscolimit_colimit (shift_seq A n.+1))	      (iscolimit_colimit (succ_seq (shift_seq A n)))) 	   ?Goal == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 162;
            data = "1 subgoal (ID 869)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  Colimit (succ_seq (shift_seq A n)) <~> Colimit A	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 526)		subgoal 1 (ID 526) is:	 transitive_equiv (Colimit (shift_seq A n.+1))	   (Colimit (succ_seq (shift_seq A n))) (Colimit A)	   (equiv_functor_colimit	      {|	      diag_equiv_map := {|	                        DiagramMap_obj := fun k : Graph.graph0 sequence_graph	                                          => coe (ap A (nat_plus_n_Sm k n)^);	                        DiagramMap_comm := fun	                                             (k	                                              l : 	                                              Graph.graph0 sequence_graph)	                                             (p : 	                                              Graph.graph1 sequence_graph k l)	                                             (a : shift_seq A n.+1 k) =>	                                           match	                                             p as p0 in (_ = y)	                                             return	                                               (((succ_seq (shift_seq A n))	                                                 _f p0)	                                                 (coe	                                                 (ap A (nat_plus_n_Sm k n)^)	                                                 a) =	                                                coe	                                                 (ap A (nat_plus_n_Sm y n)^)	                                                 (((shift_seq A n.+1) _f p0)	                                                 a))	                                           with	                                           | 1 =>	                                               K S	                                                 (fun (n0 : nat) (a0 : A n0)	                                                 => 	                                                 (a0) ^+)	                                                 (nat_plus_n_Sm k n)^ @	                                               ap10	                                                 (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_Sm k n))))	                                                 (a) ^+	                                           end |};	      diag_equiv_isequiv := fun k : Graph.graph0 sequence_graph =>	                            isequiv_path (ap A (nat_plus_n_Sm k n)^) |}	      (iscolimit_colimit (shift_seq A n.+1))	      (iscolimit_colimit (succ_seq (shift_seq A n))))	   (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	      {| equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e |}) ==	 colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 163;
            data = "1 subgoal (ID 526)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  transitive_equiv (Colimit (shift_seq A n.+1))	    (Colimit (succ_seq (shift_seq A n))) (Colimit A)	    (equiv_functor_colimit	       {|	       diag_equiv_map := {|	                         DiagramMap_obj := fun	                                             k : Graph.graph0 sequence_graph	                                           => coe (ap A (nat_plus_n_Sm k n)^);	                         DiagramMap_comm := fun	                                              (k	                                               l : 	                                               Graph.graph0 sequence_graph)	                                              (p : 	                                               Graph.graph1 sequence_graph k	                                                 l) 	                                              (a : shift_seq A n.+1 k) =>	                                            match	                                              p as p0 in (_ = y)	                                              return	                                                (((succ_seq (shift_seq A n))	                                                 _f p0)	                                                 (coe	                                                 (ap A (nat_plus_n_Sm k n)^)	                                                 a) =	                                                 coe	                                                 (ap A (nat_plus_n_Sm y n)^)	                                                 (((shift_seq A n.+1) _f p0)	                                                 a))	                                            with	                                            | 1 =>	                                                K S	                                                 (fun (n0 : nat) (a0 : A n0)	                                                 => 	                                                 (a0) ^+)	                                                 (nat_plus_n_Sm k n)^ @	                                                ap10	                                                 (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_Sm k n))))	                                                 (a) ^+	                                            end |};	       diag_equiv_isequiv := fun k : Graph.graph0 sequence_graph =>	                             isequiv_path (ap A (nat_plus_n_Sm k n)^) |}	       (iscolimit_colimit (shift_seq A n.+1))	       (iscolimit_colimit (succ_seq (shift_seq A n))))	    (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	       {|	       equiv_fun := colim_shift_seq_to_colim_seq A n;	       equiv_isequiv := e |}) == colim_shift_seq_to_colim_seq A n.+1	2 subgoals (ID 1176)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall n0 : Graph.graph0 sequence_graph,	  colim_shift_seq_to_colim_seq A n.+1 o inj (shift_seq A n.+1) n0 ==	  transitive_equiv (Colimit (shift_seq A n.+1))	    (Colimit (succ_seq (shift_seq A n))) (Colimit A)	    (equiv_functor_colimit	       {|	       diag_equiv_map := {|	                         DiagramMap_obj := fun	                                             k : Graph.graph0 sequence_graph	                                           => coe (ap A (nat_plus_n_Sm k n)^);	                         DiagramMap_comm := fun	                                              (k	                                               l : 	                                               Graph.graph0 sequence_graph)	                                              (p : 	                                               Graph.graph1 sequence_graph k	                                                 l) 	                                              (a : shift_seq A n.+1 k) =>	                                            match	                                              p as p0 in (_ = y)	                                              return	                                                (((succ_seq (shift_seq A n))	                                                 _f p0)	                                                 (coe	                                                 (ap A (nat_plus_n_Sm k n)^)	                                                 a) =	                                                 coe	                                                 (ap A (nat_plus_n_Sm y n)^)	                                                 (((shift_seq A n.+1) _f p0)	                                                 a))	                                            with	                                            | 1 =>	                                                K S	                                                 (fun (n1 : nat) (a0 : A n1)	                                                 => 	                                                 (a0) ^+)	                                                 (nat_plus_n_Sm k n)^ @	                                                ap10	                                                 (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_Sm k n))))	                                                 (a) ^+	                                            end |};	       diag_equiv_isequiv := fun k : Graph.graph0 sequence_graph =>	                             isequiv_path (ap A (nat_plus_n_Sm k n)^) |}	       (iscolimit_colimit (shift_seq A n.+1))	       (iscolimit_colimit (succ_seq (shift_seq A n))))	    (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	       {|	       equiv_fun := colim_shift_seq_to_colim_seq A n;	       equiv_isequiv := e |}) o inj (shift_seq A n.+1) n0		subgoal 2 (ID 1178) is:	 forall (n0 : Graph.graph0 sequence_graph) (a : shift_seq A n.+1 n0),	 ap (colim_shift_seq_to_colim_seq A n.+1) (glue (shift_seq A n.+1) n0 a) @	 ?h n0 a =	 ?h n0.+1 (a) ^+ @	 ap	   (transitive_equiv (Colimit (shift_seq A n.+1))	      (Colimit (succ_seq (shift_seq A n))) (Colimit A)	      (equiv_functor_colimit	         {|	         diag_equiv_map := {|	                           DiagramMap_obj := fun	                                               k : 	                                                Graph.graph0 sequence_graph	                                             =>	                                             coe (ap A (nat_plus_n_Sm k n)^);	                           DiagramMap_comm := fun	                                                (k	                                                 l : 	                                                 Graph.graph0 sequence_graph)	                                                (p : 	                                                 Graph.graph1 sequence_graph	                                                 k l)	                                                (a0 : shift_seq A n.+1 k) =>	                                              match	                                                p as p0 in (_ = y)	                                                return	                                                 (((succ_seq (shift_seq A n))	                                                 _f p0)	                                                 (coe	                                                 (ap A (nat_plus_n_Sm k n)^)	                                                 a0) =	                                                 coe	                                                 (ap A (nat_plus_n_Sm y n)^)	                                                 (((shift_seq A n.+1) _f p0)	                                                 a0))	                                              with	                                              | 1 =>	                                                 K S	                                                 (fun (n1 : nat) (a1 : A n1)	                                                 => 	                                                 (a1) ^+)	                                                 (nat_plus_n_Sm k n)^ @	                                                 ap10	                                                 (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_Sm k n))))	                                                 (a0) ^+	                                              end |};	         diag_equiv_isequiv := fun k : Graph.graph0 sequence_graph =>	                               isequiv_path (ap A (nat_plus_n_Sm k n)^) |}	         (iscolimit_colimit (shift_seq A n.+1))	         (iscolimit_colimit (succ_seq (shift_seq A n))))	      (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	         {|	         equiv_fun := colim_shift_seq_to_colim_seq A n;	         equiv_isequiv := e |})) (glue (shift_seq A n.+1) n0 a)	";
            responses[i]=data;
          

            i = 164;
            data = "1 subgoal (ID 1176)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall n0 : Graph.graph0 sequence_graph,	  colim_shift_seq_to_colim_seq A n.+1 o inj (shift_seq A n.+1) n0 ==	  transitive_equiv (Colimit (shift_seq A n.+1))	    (Colimit (succ_seq (shift_seq A n))) (Colimit A)	    (equiv_functor_colimit	       {|	       diag_equiv_map := {|	                         DiagramMap_obj := fun	                                             k : Graph.graph0 sequence_graph	                                           => coe (ap A (nat_plus_n_Sm k n)^);	                         DiagramMap_comm := fun	                                              (k	                                               l : 	                                               Graph.graph0 sequence_graph)	                                              (p : 	                                               Graph.graph1 sequence_graph k	                                                 l) 	                                              (a : shift_seq A n.+1 k) =>	                                            match	                                              p as p0 in (_ = y)	                                              return	                                                (((succ_seq (shift_seq A n))	                                                 _f p0)	                                                 (coe	                                                 (ap A (nat_plus_n_Sm k n)^)	                                                 a) =	                                                 coe	                                                 (ap A (nat_plus_n_Sm y n)^)	                                                 (((shift_seq A n.+1) _f p0)	                                                 a))	                                            with	                                            | 1 =>	                                                K S	                                                 (fun (n1 : nat) (a0 : A n1)	                                                 => 	                                                 (a0) ^+)	                                                 (nat_plus_n_Sm k n)^ @	                                                ap10	                                                 (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_Sm k n))))	                                                 (a) ^+	                                            end |};	       diag_equiv_isequiv := fun k : Graph.graph0 sequence_graph =>	                             isequiv_path (ap A (nat_plus_n_Sm k n)^) |}	       (iscolimit_colimit (shift_seq A n.+1))	       (iscolimit_colimit (succ_seq (shift_seq A n))))	    (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	       {|	       equiv_fun := colim_shift_seq_to_colim_seq A n;	       equiv_isequiv := e |}) o inj (shift_seq A n.+1) n0	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 1178)		subgoal 1 (ID 1178) is:	 forall (n0 : Graph.graph0 sequence_graph) (a : shift_seq A n.+1 n0),	 ap (colim_shift_seq_to_colim_seq A n.+1) (glue (shift_seq A n.+1) n0 a) @	 (fun (k : Graph.graph0 sequence_graph) (a0 : shift_seq A n.+1 k) =>	  J (nat_plus_n_Sm k n)) n0 a =	 (fun (k : Graph.graph0 sequence_graph) (a0 : shift_seq A n.+1 k) =>	  J (nat_plus_n_Sm k n)) n0.+1 (a) ^+ @	 ap	   (transitive_equiv (Colimit (shift_seq A n.+1))	      (Colimit (succ_seq (shift_seq A n))) (Colimit A)	      (equiv_functor_colimit	         {|	         diag_equiv_map := {|	                           DiagramMap_obj := fun	                                               k : 	                                                Graph.graph0 sequence_graph	                                             =>	                                             coe (ap A (nat_plus_n_Sm k n)^);	                           DiagramMap_comm := fun	                                                (k	                                                 l : 	                                                 Graph.graph0 sequence_graph)	                                                (p : 	                                                 Graph.graph1 sequence_graph	                                                 k l)	                                                (a0 : shift_seq A n.+1 k) =>	                                              match	                                                p as p0 in (_ = y)	                                                return	                                                 (((succ_seq (shift_seq A n))	                                                 _f p0)	                                                 (coe	                                                 (ap A (nat_plus_n_Sm k n)^)	                                                 a0) =	                                                 coe	                                                 (ap A (nat_plus_n_Sm y n)^)	                                                 (((shift_seq A n.+1) _f p0)	                                                 a0))	                                              with	                                              | 1 =>	                                                 K S	                                                 (fun (n1 : nat) (a1 : A n1)	                                                 => 	                                                 (a1) ^+)	                                                 (nat_plus_n_Sm k n)^ @	                                                 ap10	                                                 (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_Sm k n))))	                                                 (a0) ^+	                                              end |};	         diag_equiv_isequiv := fun k : Graph.graph0 sequence_graph =>	                               isequiv_path (ap A (nat_plus_n_Sm k n)^) |}	         (iscolimit_colimit (shift_seq A n.+1))	         (iscolimit_colimit (succ_seq (shift_seq A n))))	      (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	         {|	         equiv_fun := colim_shift_seq_to_colim_seq A n;	         equiv_isequiv := e |})) (glue (shift_seq A n.+1) n0 a)	";
            responses[i]=data;
          

            i = 165;
            data = "1 subgoal (ID 1178)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall (n0 : Graph.graph0 sequence_graph) (a : shift_seq A n.+1 n0),	  ap (colim_shift_seq_to_colim_seq A n.+1) (glue (shift_seq A n.+1) n0 a) @	  (fun (k : Graph.graph0 sequence_graph) (a0 : shift_seq A n.+1 k) =>	   J (nat_plus_n_Sm k n)) n0 a =	  (fun (k : Graph.graph0 sequence_graph) (a0 : shift_seq A n.+1 k) =>	   J (nat_plus_n_Sm k n)) n0.+1 (a) ^+ @	  ap	    (transitive_equiv (Colimit (shift_seq A n.+1))	       (Colimit (succ_seq (shift_seq A n))) (Colimit A)	       (equiv_functor_colimit	          {|	          diag_equiv_map := {|	                            DiagramMap_obj := fun	                                                k : 	                                                 Graph.graph0 sequence_graph	                                              =>	                                              coe (ap A (nat_plus_n_Sm k n)^);	                            DiagramMap_comm := fun	                                                 (k	                                                 l : 	                                                 Graph.graph0 sequence_graph)	                                                 (p : 	                                                 Graph.graph1 sequence_graph	                                                 k l)	                                                 (a0 : shift_seq A n.+1 k) =>	                                               match	                                                 p as p0 in (_ = y)	                                                 return	                                                 (((succ_seq (shift_seq A n))	                                                 _f p0)	                                                 (coe	                                                 (ap A (nat_plus_n_Sm k n)^)	                                                 a0) =	                                                 coe	                                                 (ap A (nat_plus_n_Sm y n)^)	                                                 (((shift_seq A n.+1) _f p0)	                                                 a0))	                                               with	                                               | 1 =>	                                                 K S	                                                 (fun (n1 : nat) (a1 : A n1)	                                                 => 	                                                 (a1) ^+)	                                                 (nat_plus_n_Sm k n)^ @	                                                 ap10	                                                 (ap coe	                                                 (ap 	                                                 (ap A)	                                                 (ap_V S (nat_plus_n_Sm k n))))	                                                 (a0) ^+	                                               end |};	          diag_equiv_isequiv := fun k : Graph.graph0 sequence_graph =>	                                isequiv_path (ap A (nat_plus_n_Sm k n)^) |}	          (iscolimit_colimit (shift_seq A n.+1))	          (iscolimit_colimit (succ_seq (shift_seq A n))))	       (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	          {|	          equiv_fun := colim_shift_seq_to_colim_seq A n;	          equiv_isequiv := e |})) (glue (shift_seq A n.+1) n0 a)	";
            responses[i]=data;
          

            i = 166;
            data = "1 subgoal (ID 1246)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  k : Graph.graph0 sequence_graph	  a : shift_seq A n.+1 k	  ============================	  colimp (k + n.+1)%nat (k + n.+1).+1 1 a @ J (nat_plus_n_Sm k n) =	  J (ap S (nat_plus_n_Sm k n)) @	  ap	    (fun x : Colimit (shift_seq A n.+1) =>	     colim_shift_seq_to_colim_seq A n	       (colim_succ_seq_to_colim_seq (shift_seq A n)	          (functor_colimit	             {|	             DiagramMap_obj := fun k0 : nat =>	                               coe (ap A (nat_plus_n_Sm k0 n)^);	             DiagramMap_comm := fun (k0 l : nat) (p : k0.+1 = l)	                                  (a0 : A (k0 + n.+1)%nat) =>	                                match	                                  p as p0 in (_ = y)	                                  return	                                    (match	                                       p0 in (_ = y0)	                                       return	                                         (A (k0 + n).+1 -> A (y0 + n).+1)	                                     with	                                     | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                                     end	                                       (coe (ap A (nat_plus_n_Sm k0 n)^) a0) =	                                     coe (ap A (nat_plus_n_Sm y n)^)	                                       (match	                                          p0 in (_ = y0)	                                          return	                                            (A (k0 + n.+1)%nat ->	                                             A (y0 + n.+1)%nat)	                                        with	                                        | 1 =>	                                            fun a1 : A (k0 + n.+1)%nat =>	                                            (a1) ^+	                                        end a0))	                                with	                                | 1 =>	                                    K S	                                      (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                                      (nat_plus_n_Sm k0 n)^ @	                                    ap10	                                      (ap coe	                                         (ap (ap A)	                                            (ap_V S (nat_plus_n_Sm k0 n))))	                                      (a0) ^+	                                end |} (iscolimit_colimit (shift_seq A n.+1))	             (iscolimit_colimit (succ_seq (shift_seq A n))) x)))	    (colimp k k.+1 1 a)	";
            responses[i]=data;
          

            i = 167;
            data = "";
            responses[i]=data;
          

            i = 168;
            data = "";
            responses[i]=data;
          

            i = 169;
            data = "1 subgoal (ID 1301)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  k : Graph.graph0 sequence_graph	  a : shift_seq A n.+1 k	  ============================	  colimp (k + n.+1)%nat (k + n.+1).+1 1 a @ J (nat_plus_n_Sm k n) =	  J (ap S (nat_plus_n_Sm k n)) @	  (ap (colim_shift_seq_to_colim_seq A n)	     (ap (colim_succ_seq_to_colim_seq (shift_seq A n))	        (ap (iscolimit_colimit (succ_seq (shift_seq A n)) k.+1)	           (DiagramMap_comm	              {|	              DiagramMap_obj := fun k0 : nat =>	                                coe (ap A (nat_plus_n_Sm k0 n)^);	              DiagramMap_comm := fun (k0 l : nat) 	                                   (p : k0.+1 = l) 	                                   (a0 : A (k0 + n.+1)%nat) =>	                                 match	                                   p as p0 in (_ = y)	                                   return	                                     (match	                                        p0 in (_ = y0)	                                        return	                                          (A (k0 + n).+1 -> A (y0 + n).+1)	                                      with	                                      | 1 =>	                                          fun a1 : A (k0 + n).+1 => (a1) ^+	                                      end	                                        (coe (ap A (nat_plus_n_Sm k0 n)^) a0) =	                                      coe (ap A (nat_plus_n_Sm y n)^)	                                        (match	                                           p0 in (_ = y0)	                                           return	                                             (A (k0 + n.+1)%nat ->	                                              A (y0 + n.+1)%nat)	                                         with	                                         | 1 =>	                                             fun a1 : A (k0 + n.+1)%nat =>	                                             (a1) ^+	                                         end a0))	                                 with	                                 | 1 =>	                                     K S	                                       (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                                       (nat_plus_n_Sm k0 n)^ @	                                     ap10	                                       (ap coe	                                          (ap (ap A)	                                             (ap_V S (nat_plus_n_Sm k0 n))))	                                       (a0) ^+	                                 end |} 1 a)^)) @	   ap (colim_shift_seq_to_colim_seq A n)	     (ap (colim_succ_seq_to_colim_seq (shift_seq A n))	        (legs_comm (iscolimit_colimit (succ_seq (shift_seq A n))) k k.+1 1	           ({|	            DiagramMap_obj := fun k0 : nat =>	                              coe (ap A (nat_plus_n_Sm k0 n)^);	            DiagramMap_comm := fun (k0 l : nat) (p : k0.+1 = l)	                                 (a0 : A (k0 + n.+1)%nat) =>	                               match	                                 p as p0 in (_ = y)	                                 return	                                   (match	                                      p0 in (_ = y0)	                                      return (A (k0 + n).+1 -> A (y0 + n).+1)	                                    with	                                    | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                                    end (coe (ap A (nat_plus_n_Sm k0 n)^) a0) =	                                    coe (ap A (nat_plus_n_Sm y n)^)	                                      (match	                                         p0 in (_ = y0)	                                         return	                                           (A (k0 + n.+1)%nat ->	                                            A (y0 + n.+1)%nat)	                                       with	                                       | 1 =>	                                           fun a1 : A (k0 + n.+1)%nat =>	                                           (a1) ^+	                                       end a0))	                               with	                               | 1 =>	                                   K S	                                     (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                                     (nat_plus_n_Sm k0 n)^ @	                                   ap10	                                     (ap coe	                                        (ap (ap A)	                                           (ap_V S (nat_plus_n_Sm k0 n))))	                                     (a0) ^+	                               end |} k a))))	";
            responses[i]=data;
          

            i = 170;
            data = "";
            responses[i]=data;
          

            i = 171;
            data = "1 subgoal (ID 1305)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  k : Graph.graph0 sequence_graph	  a : shift_seq A n.+1 k	  ============================	  colimp (k + n.+1)%nat (k + n.+1).+1 1 a @ J (nat_plus_n_Sm k n) =	  J (ap S (nat_plus_n_Sm k n)) @	  (ap (inj A (k.+2 + n)%nat)	     (DiagramMap_comm	        {|	        DiagramMap_obj := fun k0 : nat => coe (ap A (nat_plus_n_Sm k0 n)^);	        DiagramMap_comm := fun (k0 l : nat) (p : k0.+1 = l)	                             (a0 : A (k0 + n.+1)%nat) =>	                           match	                             p as p0 in (_ = y)	                             return	                               (match	                                  p0 in (_ = y0)	                                  return (A (k0 + n).+1 -> A (y0 + n).+1)	                                with	                                | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                                end (coe (ap A (nat_plus_n_Sm k0 n)^) a0) =	                                coe (ap A (nat_plus_n_Sm y n)^)	                                  (match	                                     p0 in (_ = y0)	                                     return	                                       (A (k0 + n.+1)%nat ->	                                        A (y0 + n.+1)%nat)	                                   with	                                   | 1 =>	                                       fun a1 : A (k0 + n.+1)%nat => (a1) ^+	                                   end a0))	                           with	                           | 1 =>	                               K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                                 (nat_plus_n_Sm k0 n)^ @	                               ap10	                                 (ap coe	                                    (ap (ap A) (ap_V S (nat_plus_n_Sm k0 n))))	                                 (a0) ^+	                           end |} 1 a)^ @	   ap (colim_shift_seq_to_colim_seq A n)	     (ap (colim_succ_seq_to_colim_seq (shift_seq A n))	        (legs_comm (iscolimit_colimit (succ_seq (shift_seq A n))) k k.+1 1	           ({|	            DiagramMap_obj := fun k0 : nat =>	                              coe (ap A (nat_plus_n_Sm k0 n)^);	            DiagramMap_comm := fun (k0 l : nat) (p : k0.+1 = l)	                                 (a0 : A (k0 + n.+1)%nat) =>	                               match	                                 p as p0 in (_ = y)	                                 return	                                   (match	                                      p0 in (_ = y0)	                                      return (A (k0 + n).+1 -> A (y0 + n).+1)	                                    with	                                    | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                                    end (coe (ap A (nat_plus_n_Sm k0 n)^) a0) =	                                    coe (ap A (nat_plus_n_Sm y n)^)	                                      (match	                                         p0 in (_ = y0)	                                         return	                                           (A (k0 + n.+1)%nat ->	                                            A (y0 + n.+1)%nat)	                                       with	                                       | 1 =>	                                           fun a1 : A (k0 + n.+1)%nat =>	                                           (a1) ^+	                                       end a0))	                               with	                               | 1 =>	                                   K S	                                     (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                                     (nat_plus_n_Sm k0 n)^ @	                                   ap10	                                     (ap coe	                                        (ap (ap A)	                                           (ap_V S (nat_plus_n_Sm k0 n))))	                                     (a0) ^+	                               end |} k a))))	1 subgoal (ID 1306)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  k : Graph.graph0 sequence_graph	  a : shift_seq A n.+1 k	  ============================	  colimp (k + n.+1)%nat (k + n.+1).+1 1 a @ J (nat_plus_n_Sm k n) =	  J (ap S (nat_plus_n_Sm k n)) @	  (ap (inj A (k.+2 + n)%nat)	     (DiagramMap_comm	        {|	        DiagramMap_obj := fun k0 : nat => coe (ap A (nat_plus_n_Sm k0 n)^);	        DiagramMap_comm := fun (k0 l : nat) (p : k0.+1 = l)	                             (a0 : A (k0 + n.+1)%nat) =>	                           match	                             p as p0 in (_ = y)	                             return	                               (match	                                  p0 in (_ = y0)	                                  return (A (k0 + n).+1 -> A (y0 + n).+1)	                                with	                                | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                                end (coe (ap A (nat_plus_n_Sm k0 n)^) a0) =	                                coe (ap A (nat_plus_n_Sm y n)^)	                                  (match	                                     p0 in (_ = y0)	                                     return	                                       (A (k0 + n.+1)%nat ->	                                        A (y0 + n.+1)%nat)	                                   with	                                   | 1 =>	                                       fun a1 : A (k0 + n.+1)%nat => (a1) ^+	                                   end a0))	                           with	                           | 1 =>	                               K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                                 (nat_plus_n_Sm k0 n)^ @	                               ap10	                                 (ap coe	                                    (ap (ap A) (ap_V S (nat_plus_n_Sm k0 n))))	                                 (a0) ^+	                           end |} 1 a)^ @	   ap (colim_shift_seq_to_colim_seq A n)	     (colimp k.+1 k.+2 1	        ({|	         DiagramMap_obj := fun k0 : nat => coe (ap A (nat_plus_n_Sm k0 n)^);	         DiagramMap_comm := fun (k0 l : nat) (p : k0.+1 = l)	                              (a0 : A (k0 + n.+1)%nat) =>	                            match	                              p as p0 in (_ = y)	                              return	                                (match	                                   p0 in (_ = y0)	                                   return (A (k0 + n).+1 -> A (y0 + n).+1)	                                 with	                                 | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                                 end (coe (ap A (nat_plus_n_Sm k0 n)^) a0) =	                                 coe (ap A (nat_plus_n_Sm y n)^)	                                   (match	                                      p0 in (_ = y0)	                                      return	                                        (A (k0 + n.+1)%nat ->	                                         A (y0 + n.+1)%nat)	                                    with	                                    | 1 =>	                                        fun a1 : A (k0 + n.+1)%nat => (a1) ^+	                                    end a0))	                            with	                            | 1 =>	                                K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                                  (nat_plus_n_Sm k0 n)^ @	                                ap10	                                  (ap coe	                                     (ap (ap A) (ap_V S (nat_plus_n_Sm k0 n))))	                                  (a0) ^+	                            end |} k a)))	No more subgoals.	";
            responses[i]=data;
          

            i = 172;
            data = "";
            responses[i]=data;
          

            i = 173;
            data = "";
            responses[i]=data;
          

            i = 174;
            data = "";
            responses[i]=data;
          

            i = 175;
            data = "";
            responses[i]=data;
          

            i = 176;
            data = "";
            responses[i]=data;
          

            i = 177;
            data = "";
            responses[i]=data;
          

            i = 178;
            data = "";
            responses[i]=data;
          

            i = 179;
            data = "";
            responses[i]=data;
          

            i = 180;
            data = "";
            responses[i]=data;
          

            i = 181;
            data = "";
            responses[i]=data;
          

            i = 182;
            data = "";
            responses[i]=data;
          

            i = 183;
            data = "";
            responses[i]=data;
          

            i = 184;
            data = "";
            responses[i]=data;
          

            i = 185;
            data = "<infomsg>equiv_colim_shift_seq_to_colim_seq is defined</infomsg>	1 subgoal (ID 497)	  	  H : Funext	  A : Sequence	  ============================	  (forall k : Graph.graph0 sequence_graph, Contr (A k)) -> Contr (Colimit A)	1 subgoal (ID 502)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  Contr (Colimit A)	2 subgoals (ID 516)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  Colimit unit_seq <~> Colimit A		subgoal 2 (ID 518) is:	 Contr (Colimit unit_seq)	1 subgoal (ID 516)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  Colimit unit_seq <~> Colimit A	1 subgoal (ID 585)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  A ~d~ unit_seq	2 subgoals (ID 655)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> unit_seq i		subgoal 2 (ID 657) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 (unit_seq _f g) (?DiagramMap_obj i x) = ?DiagramMap_obj j ((A _f g) x)	1 subgoal (ID 655)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> unit_seq i	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 subgoals (ID 657)		subgoal 1 (ID 657) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 (unit_seq _f g)	   ((fun (i0 : Graph.graph0 sequence_graph) (_ : A i0) => tt) i x) =	 (fun (i0 : Graph.graph0 sequence_graph) (_ : A i0) => tt) j ((A _f g) x)	subgoal 2 (ID 518) is:	 Contr (Colimit unit_seq)	1 subgoal (ID 657)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : A i),	  (unit_seq _f g)	    ((fun (i0 : Graph.graph0 sequence_graph) (_ : A i0) => tt) i x) =	  (fun (i0 : Graph.graph0 sequence_graph) (_ : A i0) => tt) j ((A _f g) x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 518)		subgoal 1 (ID 518) is:	 Contr (Colimit unit_seq)	1 subgoal (ID 518)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  Contr (Colimit unit_seq)	1 subgoal (ID 691)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall y : Colimit unit_seq, y = inj unit_seq 0 tt	2 subgoals (ID 725)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  idmap o inj unit_seq n ==	  (fun _ : Colimit unit_seq => inj unit_seq 0 tt) o inj unit_seq n		subgoal 2 (ID 727) is:	 forall (n : Graph.graph0 sequence_graph) (a : unit_seq n),	 ap idmap (glue unit_seq n a) @ ?h n a =	 ?h n.+1 (a) ^+ @	 ap (fun _ : Colimit unit_seq => inj unit_seq 0 tt) (glue unit_seq n a)	";
            responses[i]=data;
          

            i = 186;
            data = "1 subgoal (ID 725)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  idmap o inj unit_seq n ==	  (fun _ : Colimit unit_seq => inj unit_seq 0 tt) o inj unit_seq n	2 subgoals (ID 737)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  inj unit_seq 0 tt = inj unit_seq 0 tt		subgoal 2 (ID 740) is:	 inj unit_seq n.+1 tt = inj unit_seq 0 tt	";
            responses[i]=data;
          

            i = 187;
            data = "1 subgoal (ID 737)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  inj unit_seq 0 tt = inj unit_seq 0 tt	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 740)		subgoal 1 (ID 740) is:	 inj unit_seq n.+1 tt = inj unit_seq 0 tt	subgoal 2 (ID 727) is:	 forall (n : Graph.graph0 sequence_graph) (a : unit_seq n),	 ap idmap (glue unit_seq n a) @	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : unit_seq n0) =>	  match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	  | tt =>	      nat_rect (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	        (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	         ?Goal@{n:=n1}) n0	  end) n a =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : unit_seq n0) =>	  match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	  | tt =>	      nat_rect (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	        (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	         ?Goal@{n:=n1}) n0	  end) n.+1 (a) ^+ @	 ap (fun _ : Colimit unit_seq => inj unit_seq 0 tt) (glue unit_seq n a)	";
            responses[i]=data;
          

            i = 188;
            data = "1 subgoal (ID 740)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  n : nat	  r : inj unit_seq n tt = inj unit_seq 0 tt	  ============================	  inj unit_seq n.+1 tt = inj unit_seq 0 tt	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 subgoal (ID 727)		subgoal 1 (ID 727) is:	 forall (n : Graph.graph0 sequence_graph) (a : unit_seq n),	 ap idmap (glue unit_seq n a) @	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : unit_seq n0) =>	  match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	  | tt =>	      nat_rect (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	        (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	         glue unit_seq n1 tt @ r) n0	  end) n a =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : unit_seq n0) =>	  match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	  | tt =>	      nat_rect (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	        (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	         glue unit_seq n1 tt @ r) n0	  end) n.+1 (a) ^+ @	 ap (fun _ : Colimit unit_seq => inj unit_seq 0 tt) (glue unit_seq n a)	";
            responses[i]=data;
          

            i = 189;
            data = "1 subgoal (ID 727)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : unit_seq n),	  ap idmap (glue unit_seq n a) @	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : unit_seq n0) =>	   match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	   | tt =>	       nat_rect (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	         (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	          glue unit_seq n1 tt @ r) n0	   end) n a =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : unit_seq n0) =>	   match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	   | tt =>	       nat_rect (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	         (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	          glue unit_seq n1 tt @ r) n0	   end) n.+1 (a) ^+ @	  ap (fun _ : Colimit unit_seq => inj unit_seq 0 tt) (glue unit_seq n a)	No more subgoals.	";
            responses[i]=data;
          

            i = 190;
            data = "";
            responses[i]=data;
          

            i = 191;
            data = "";
            responses[i]=data;
          

            i = 192;
            data = "";
            responses[i]=data;
          

            i = 193;
            data = "";
            responses[i]=data;
          

            i = 194;
            data = "";
            responses[i]=data;
          

            i = 195;
            data = "<infomsg>FibSequence is defined</infomsg>	<infomsg>FibSequence_rect is defined</infomsg>	<infomsg>FibSequence_ind is defined</infomsg>	<infomsg>FibSequence_rec is defined</infomsg>	<infomsg>FibSequence_sind is defined</infomsg>	<infomsg>fibSequence is defined</infomsg>	<infomsg>fibSequenceArr is defined</infomsg>	";
            responses[i]=data;
          

            i = 196;
            data = "<infomsg>fibSequence is now a coercion</infomsg>	";
            responses[i]=data;
          

            i = 197;
            data = "";
            responses[i]=data;
          

            i = 198;
            data = "";
            responses[i]=data;
          

            i = 199;
            data = "";
            responses[i]=data;
          

            i = 200;
            data = "";
            responses[i]=data;
          

            i = 201;
            data = "";
            responses[i]=data;
          

            i = 202;
            data = "";
            responses[i]=data;
          

            i = 203;
            data = "";
            responses[i]=data;
          

            i = 204;
            data = "1 subgoal (ID 501)	  	  A : Sequence	  B : FibSequence A	  ============================	  Sequence	";
            responses[i]=data;
          

            i = 205;
            data = "";
            responses[i]=data;
          

            i = 206;
            data = "2 subgoals (ID 505)	  	  A : Sequence	  B : FibSequence A	  ============================	  nat -> Type		subgoal 2 (ID 507) is:	 forall n : nat, ?X n -> ?X n.+1	";
            responses[i]=data;
          

            i = 207;
            data = "1 subgoal (ID 505)	  	  A : Sequence	  B : FibSequence A	  ============================	  nat -> Type	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 507)		subgoal 1 (ID 507) is:	 forall n : nat,	 (fun n0 : nat => {a : A n0 & B (n0; a)}) n ->	 (fun n0 : nat => {a : A n0 & B (n0; a)}) n.+1	";
            responses[i]=data;
          

            i = 208;
            data = "1 subgoal (ID 507)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall n : nat,	  (fun n0 : nat => {a : A n0 & B (n0; a)}) n ->	  (fun n0 : nat => {a : A n0 & B (n0; a)}) n.+1	No more subgoals.	";
            responses[i]=data;
          

            i = 209;
            data = "";
            responses[i]=data;
          

            i = 210;
            data = "";
            responses[i]=data;
          

            i = 211;
            data = "";
            responses[i]=data;
          

            i = 212;
            data = "";
            responses[i]=data;
          

            i = 213;
            data = "";
            responses[i]=data;
          

            i = 214;
            data = "1 subgoal (ID 508)	  	  A : Sequence	  B : FibSequence A	  ============================	  Colimit (sig_seq B) -> Colimit A	";
            responses[i]=data;
          

            i = 215;
            data = "";
            responses[i]=data;
          

            i = 216;
            data = "2 subgoals (ID 540)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph, sig_seq B i -> Colimit A		subgoal 2 (ID 542) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j), ?legs j o (sig_seq B) _f g == ?legs i	";
            responses[i]=data;
          

            i = 217;
            data = "1 subgoal (ID 540)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph, sig_seq B i -> Colimit A	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 542)		subgoal 1 (ID 542) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	  (fun (a : A n) (_ : B (n; a)) => inj A n a) X.1 X.2) j o 	 (sig_seq B) _f g ==	 (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	  (fun (a : A n) (_ : B (n; a)) => inj A n a) X.1 X.2) i	";
            responses[i]=data;
          

            i = 218;
            data = "1 subgoal (ID 542)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	   (fun (a : A n) (_ : B (n; a)) => inj A n a) X.1 X.2) j o 	  (sig_seq B) _f g ==	  (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	   (fun (a : A n) (_ : B (n; a)) => inj A n a) X.1 X.2) i	No more subgoals.	";
            responses[i]=data;
          

            i = 219;
            data = "";
            responses[i]=data;
          

            i = 220;
            data = "";
            responses[i]=data;
          

            i = 221;
            data = "";
            responses[i]=data;
          

            i = 222;
            data = "";
            responses[i]=data;
          

            i = 223;
            data = "";
            responses[i]=data;
          

            i = 224;
            data = "1 subgoal (ID 514)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  Sequence	";
            responses[i]=data;
          

            i = 225;
            data = "";
            responses[i]=data;
          

            i = 226;
            data = "4 subgoals (ID 530)	  	  A : Sequence	  B : FibSequence A	  ============================	  {x : _ & A x} -> Type		subgoal 2 (ID 533) is:	 {x : _ & A x} -> Type	subgoal 3 (ID 537) is:	 forall x : {x : _ & A x},	 nat_rect (fun _ : nat => {x : _ & A x} -> Type) ?Goal	   (fun (k : nat) (h : {x : _ & A x} -> Type) => ?Goal0) 0 x ->	 nat_rect (fun _ : nat => {x : _ & A x} -> Type) ?Goal	   (fun (k : nat) (h : {x : _ & A x} -> Type) => ?Goal0) 1 x	subgoal 4 (ID 540) is:	 forall x : {x : _ & A x},	 nat_rect (fun _ : nat => {x : _ & A x} -> Type) ?Goal	   (fun (k0 : nat) (h0 : {x : _ & A x} -> Type) => ?Goal0@{k:=k0; h:=h0})	   k.+1 x ->	 nat_rect (fun _ : nat => {x : _ & A x} -> Type) ?Goal	   (fun (k0 : nat) (h0 : {x : _ & A x} -> Type) => ?Goal0@{k:=k0; h:=h0})	   k.+2 x	";
            responses[i]=data;
          

            i = 227;
            data = "1 subgoal (ID 530)	  	  A : Sequence	  B : FibSequence A	  ============================	  {x : _ & A x} -> Type	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 subgoals (ID 533)		subgoal 1 (ID 533) is:	 {x : _ & A x} -> Type	subgoal 2 (ID 537) is:	 forall x : {x : _ & A x},	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (k : nat) (h : {x : _ & A x} -> Type) => ?Goal) 0 x ->	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (k : nat) (h : {x : _ & A x} -> Type) => ?Goal) 1 x	subgoal 3 (ID 540) is:	 forall x : {x : _ & A x},	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (k0 : nat) (h0 : {x : _ & A x} -> Type) => ?Goal@{k:=k0; h:=h0}) k.+1	   x ->	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (k0 : nat) (h0 : {x : _ & A x} -> Type) => ?Goal@{k:=k0; h:=h0}) k.+2	   x	";
            responses[i]=data;
          

            i = 228;
            data = "1 subgoal (ID 533)	  	  A : Sequence	  B : FibSequence A	  k : nat	  h : {x : _ & A x} -> Type	  ============================	  {x : _ & A x} -> Type	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 subgoals (ID 537)		subgoal 1 (ID 537) is:	 forall x : {x : _ & A x},	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h (x0) ^++) 0 x ->	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h (x0) ^++) 1 x	subgoal 2 (ID 540) is:	 forall x : {x : _ & A x},	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h0 (x0) ^++) k.+1 x ->	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h0 (x0) ^++) k.+2 x	";
            responses[i]=data;
          

            i = 229;
            data = "1 subgoal (ID 537)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall x : {x : _ & A x},	  nat_rect (fun _ : nat => {x : _ & A x} -> Type)	    (fun x0 : {x : _ & A x} => B x0)	    (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	     h (x0) ^++) 0 x ->	  nat_rect (fun _ : nat => {x : _ & A x} -> Type)	    (fun x0 : {x : _ & A x} => B x0)	    (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	     h (x0) ^++) 1 x	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 subgoal (ID 540)		subgoal 1 (ID 540) is:	 forall x : {x : _ & A x},	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h0 (x0) ^++) k.+1 x ->	 nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h0 (x0) ^++) k.+2 x	";
            responses[i]=data;
          

            i = 230;
            data = "1 subgoal (ID 540)	  	  A : Sequence	  B : FibSequence A	  k : nat	  h : forall x : {x : _ & A x},	      nat_rect (fun _ : nat => {x : _ & A x} -> Type)	        (fun x0 : {x : _ & A x} => B x0)	        (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	         h (x0) ^++) k x ->	      nat_rect (fun _ : nat => {x : _ & A x} -> Type)	        (fun x0 : {x : _ & A x} => B x0)	        (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	         h (x0) ^++) k.+1 x	  ============================	  forall x : {x : _ & A x},	  nat_rect (fun _ : nat => {x : _ & A x} -> Type)	    (fun x0 : {x : _ & A x} => B x0)	    (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	     h0 (x0) ^++) k.+1 x ->	  nat_rect (fun _ : nat => {x : _ & A x} -> Type)	    (fun x0 : {x : _ & A x} => B x0)	    (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	     h0 (x0) ^++) k.+2 x	No more subgoals.	";
            responses[i]=data;
          

            i = 231;
            data = "";
            responses[i]=data;
          

            i = 232;
            data = "";
            responses[i]=data;
          

            i = 233;
            data = "";
            responses[i]=data;
          

            i = 234;
            data = "";
            responses[i]=data;
          

            i = 235;
            data = "";
            responses[i]=data;
          

            i = 236;
            data = "<infomsg>fib_seq_to_seq' is defined</infomsg>	";
            responses[i]=data;
          

            i = 237;
            data = "1 subgoal (ID 534)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  fib_seq_to_seq B x ~d~ fib_seq_to_seq' B x	";
            responses[i]=data;
          

            i = 238;
            data = "";
            responses[i]=data;
          

            i = 239;
            data = "2 subgoals (ID 557)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  DiagramMap (fib_seq_to_seq B x) (fib_seq_to_seq' B x)		subgoal 2 (ID 559) is:	 forall i : Graph.graph0 sequence_graph, IsEquiv (?m i)	";
            responses[i]=data;
          

            i = 240;
            data = "1 subgoal (ID 557)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  DiagramMap (fib_seq_to_seq B x) (fib_seq_to_seq' B x)	2 subgoals (ID 600)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  forall i : Graph.graph0 sequence_graph,	  fib_seq_to_seq B x i -> fib_seq_to_seq' B x i		subgoal 2 (ID 602) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x0 : fib_seq_to_seq B x i),	 ((fib_seq_to_seq' B x) _f g) (?DiagramMap_obj i x0) =	 ?DiagramMap_obj j (((fib_seq_to_seq B x) _f g) x0)	";
            responses[i]=data;
          

            i = 241;
            data = "1 subgoal (ID 600)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  forall i : Graph.graph0 sequence_graph,	  fib_seq_to_seq B x i -> fib_seq_to_seq' B x i	2 subgoals (ID 609)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall x : {x : _ & A x}, fib_seq_to_seq B x 0 -> fib_seq_to_seq' B x 0		subgoal 2 (ID 612) is:	 forall x : {x : _ & A x},	 fib_seq_to_seq B x n.+1 -> fib_seq_to_seq' B x n.+1	";
            responses[i]=data;
          

            i = 242;
            data = "1 subgoal (ID 609)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall x : {x : _ & A x}, fib_seq_to_seq B x 0 -> fib_seq_to_seq' B x 0	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 subgoals (ID 612)		subgoal 1 (ID 612) is:	 forall x : {x : _ & A x},	 fib_seq_to_seq B x n.+1 -> fib_seq_to_seq' B x n.+1	subgoal 2 (ID 602) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x0 : fib_seq_to_seq B x i),	 ((fib_seq_to_seq' B x) _f g)	   ((fun n : Graph.graph0 sequence_graph =>	     nat_rect	       (fun n0 : nat =>	        forall x1 : {x : _ & A x},	        fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (fun x1 : {x : _ & A x} => idmap)	       (fun (n0 : nat)	          (e : forall x1 : {x : _ & A x},	               fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0) =>	        ?Goal@{n:=n0}) n x) i x0) =	 (fun n : Graph.graph0 sequence_graph =>	  nat_rect	    (fun n0 : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n0 : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0) =>	     ?Goal@{n:=n0}) n x) j (((fib_seq_to_seq B x) _f g) x0)	subgoal 3 (ID 559) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	    DiagramMap_obj := fun n : Graph.graph0 sequence_graph =>	                      nat_rect	                        (fun n0 : nat =>	                         forall x0 : {x : _ & A x},	                         fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	                        (fun x0 : {x : _ & A x} => idmap)	                        (fun (n0 : nat)	                           (e : forall x0 : {x : _ & A x},	                                fib_seq_to_seq B x0 n0 ->	                                fib_seq_to_seq' B x0 n0) => 	                         ?Goal@{n:=n0}) n x;	    DiagramMap_comm := ?DiagramMap_comm |} i)	";
            responses[i]=data;
          

            i = 243;
            data = "1 subgoal (ID 612)	  	  A : Sequence	  B : FibSequence A	  n : nat	  e : forall x : {x : _ & A x}, fib_seq_to_seq B x n -> fib_seq_to_seq' B x n	  ============================	  forall x : {x : _ & A x},	  fib_seq_to_seq B x n.+1 -> fib_seq_to_seq' B x n.+1	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 subgoals (ID 602)		subgoal 1 (ID 602) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x0 : fib_seq_to_seq B x i),	 ((fib_seq_to_seq' B x) _f g)	   ((fun n : Graph.graph0 sequence_graph =>	     nat_rect	       (fun n0 : nat =>	        forall x1 : {x : _ & A x},	        fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (fun x1 : {x : _ & A x} => idmap)	       (fun (n0 : nat)	          (e : forall x1 : {x : _ & A x},	               fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	          (x1 : {x : _ & A x}) =>	        coe (ap B (seq_pair_shift_assoc x1 n0)) o e (x1) ^++) n x) i x0) =	 (fun n : Graph.graph0 sequence_graph =>	  nat_rect	    (fun n0 : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n0 : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (x1 : {x : _ & A x}) =>	     coe (ap B (seq_pair_shift_assoc x1 n0)) o e (x1) ^++) n x) j	   (((fib_seq_to_seq B x) _f g) x0)	subgoal 2 (ID 559) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	    DiagramMap_obj := fun n : Graph.graph0 sequence_graph =>	                      nat_rect	                        (fun n0 : nat =>	                         forall x0 : {x : _ & A x},	                         fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	                        (fun x0 : {x : _ & A x} => idmap)	                        (fun (n0 : nat)	                           (e : forall x0 : {x : _ & A x},	                                fib_seq_to_seq B x0 n0 ->	                                fib_seq_to_seq' B x0 n0) 	                           (x0 : {x : _ & A x}) =>	                         coe (ap B (seq_pair_shift_assoc x0 n0)) o e (x0) ^++)	                        n x;	    DiagramMap_comm := ?DiagramMap_comm |} i)	";
            responses[i]=data;
          

            i = 244;
            data = "1 subgoal (ID 602)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x0 : fib_seq_to_seq B x i),	  ((fib_seq_to_seq' B x) _f g)	    ((fun n : Graph.graph0 sequence_graph =>	      nat_rect	        (fun n0 : nat =>	         forall x1 : {x : _ & A x},	         fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	        (fun x1 : {x : _ & A x} => idmap)	        (fun (n0 : nat)	           (e : forall x1 : {x : _ & A x},	                fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	           (x1 : {x : _ & A x}) =>	         coe (ap B (seq_pair_shift_assoc x1 n0)) o e (x1) ^++) n x) i x0) =	  (fun n : Graph.graph0 sequence_graph =>	   nat_rect	     (fun n0 : nat =>	      forall x1 : {x : _ & A x},	      fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	     (fun x1 : {x : _ & A x} => idmap)	     (fun (n0 : nat)	        (e : forall x1 : {x : _ & A x},	             fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	        (x1 : {x : _ & A x}) =>	      coe (ap B (seq_pair_shift_assoc x1 n0)) o e (x1) ^++) n x) j	    (((fib_seq_to_seq B x) _f g) x0)	2 subgoals (ID 647)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x 0),	  (nat_rect	     (fun n : nat =>	      forall x1 : {x : _ & A x},	      fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	     (fun x1 : {x : _ & A x} => idmap)	     (fun (n : nat)	        (e : forall x1 : {x : _ & A x},	             fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	        (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	      coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) 0 x x0) ^+ =	  nat_rect	    (fun n : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	       (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	     coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) 1 x 	    (x0) ^+		subgoal 2 (ID 650) is:	 forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x n.+1),	 (nat_rect	    (fun n0 : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n0 : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	     coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+1 x x0) ^+ =	 nat_rect	   (fun n0 : nat =>	    forall x1 : {x : _ & A x},	    fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	   (fun x1 : {x : _ & A x} => idmap)	   (fun (n0 : nat)	      (e : forall x1 : {x : _ & A x},	           fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	      (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	    coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+2 x 	   (x0) ^+	";
            responses[i]=data;
          

            i = 245;
            data = "1 subgoal (ID 647)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x 0),	  (nat_rect	     (fun n : nat =>	      forall x1 : {x : _ & A x},	      fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	     (fun x1 : {x : _ & A x} => idmap)	     (fun (n : nat)	        (e : forall x1 : {x : _ & A x},	             fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	        (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	      coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) 0 x x0) ^+ =	  nat_rect	    (fun n : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	       (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	     coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) 1 x 	    (x0) ^+	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 subgoals (ID 650)		subgoal 1 (ID 650) is:	 forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x n.+1),	 (nat_rect	    (fun n0 : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n0 : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	     coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+1 x x0) ^+ =	 nat_rect	   (fun n0 : nat =>	    forall x1 : {x : _ & A x},	    fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	   (fun x1 : {x : _ & A x} => idmap)	   (fun (n0 : nat)	      (e : forall x1 : {x : _ & A x},	           fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	      (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	    coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+2 x 	   (x0) ^+	subgoal 2 (ID 559) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	    DiagramMap_obj := fun n : Graph.graph0 sequence_graph =>	                      nat_rect	                        (fun n0 : nat =>	                         forall x0 : {x : _ & A x},	                         fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	                        (fun x0 : {x : _ & A x} => idmap)	                        (fun (n0 : nat)	                           (e : forall x0 : {x : _ & A x},	                                fib_seq_to_seq B x0 n0 ->	                                fib_seq_to_seq' B x0 n0) 	                           (x0 : {x : _ & A x}) =>	                         coe (ap B (seq_pair_shift_assoc x0 n0)) o e (x0) ^++)	                        n x;	    DiagramMap_comm := fun (n m : Graph.graph0 sequence_graph)	                         (p : Graph.graph1 sequence_graph n m) =>	                       match	                         p as p0 in (_ = y)	                         return	                           (forall x0 : fib_seq_to_seq B x n,	                            ((fib_seq_to_seq' B x) _f p0)	                              (nat_rect	                                 (fun n0 : nat =>	                                  forall x1 : {x : _ & A x},	                                  fib_seq_to_seq B x1 n0 ->	                                  fib_seq_to_seq' B x1 n0)	                                 (fun x1 : {x : _ & A x} => idmap)	                                 (fun (n0 : nat)	                                    (e : forall x1 : {x : _ & A x},	                                         fib_seq_to_seq B x1 n0 ->	                                         fib_seq_to_seq' B x1 n0)	                                    (x1 : {x : _ & A x})	                                    (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                                  coe (ap B (seq_pair_shift_assoc x1 n0))	                                    (e (x1) ^++ x2)) n x x0) =	                            nat_rect	                              (fun n0 : nat =>	                               forall x1 : {x : _ & A x},	                               fib_seq_to_seq B x1 n0 ->	                               fib_seq_to_seq' B x1 n0)	                              (fun x1 : {x : _ & A x} => idmap)	                              (fun (n0 : nat)	                                 (e : forall x1 : {x : _ & A x},	                                      fib_seq_to_seq B x1 n0 ->	                                      fib_seq_to_seq' B x1 n0)	                                 (x1 : {x : _ & A x})	                                 (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                               coe (ap B (seq_pair_shift_assoc x1 n0))	                                 (e (x1) ^++ x2)) y x	                              (((fib_seq_to_seq B x) _f p0) x0))	                       with	                       | 1 =>	                           nat_rect	                             (fun n0 : nat =>	                              forall (x0 : {x : _ & A x})	                              (x1 : fib_seq_to_seq B x0 n0),	                              (nat_rect	                                 (fun n1 : nat =>	                                  forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n1 ->	                                  fib_seq_to_seq' B x2 n1)	                                 (fun x2 : {x : _ & A x} => idmap)	                                 (fun (n1 : nat)	                                    (e : forall x2 : {x : _ & A x},	                                         fib_seq_to_seq B x2 n1 ->	                                         fib_seq_to_seq' B x2 n1)	                                    (x2 : {x : _ & A x})	                                    (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                                  coe (ap B (seq_pair_shift_assoc x2 n1))	                                    (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                              nat_rect	                                (fun n1 : nat =>	                                 forall x2 : {x : _ & A x},	                                 fib_seq_to_seq B x2 n1 ->	                                 fib_seq_to_seq' B x2 n1)	                                (fun x2 : {x : _ & A x} => idmap)	                                (fun (n1 : nat)	                                   (e : forall x2 : {x : _ & A x},	                                        fib_seq_to_seq B x2 n1 ->	                                        fib_seq_to_seq' B x2 n1)	                                   (x2 : {x : _ & A x})	                                   (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                                 coe (ap B (seq_pair_shift_assoc x2 n1))	                                   (e (x2) ^++ x3)) n0.+1 x0 	                                (x1) ^+)	                             (fun (x0 : {x : _ & A x})	                                (x1 : fib_seq_to_seq B x0 0) => 1)	                             (fun (n0 : nat)	                                (p0 : forall (x0 : {x : _ & A x})	                                      (x1 : fib_seq_to_seq B x0 n0),	                                      (nat_rect	                                         (fun n1 : nat =>	                                          forall x2 : {x : _ & A x},	                                          fib_seq_to_seq B x2 n1 ->	                                          fib_seq_to_seq' B x2 n1)	                                         (fun x2 : {x : _ & A x} => idmap)	                                         (fun (n1 : nat)	                                            (e : forall 	                                                 x2 : {x : _ & A x},	                                                 fib_seq_to_seq B x2 n1 ->	                                                 fib_seq_to_seq' B x2 n1)	                                            (x2 : {x : _ & A x})	                                            (x3 : 	                                             fib_seq_to_seq B 	                                               (x2) ^++ n1) =>	                                          coe	                                            (ap B	                                               (seq_pair_shift_assoc x2 n1))	                                            (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                                      nat_rect	                                        (fun n1 : nat =>	                                         forall x2 : {x : _ & A x},	                                         fib_seq_to_seq B x2 n1 ->	                                         fib_seq_to_seq' B x2 n1)	                                        (fun x2 : {x : _ & A x} => idmap)	                                        (fun (n1 : nat)	                                           (e : forall 	                                                x2 : {x : _ & A x},	                                                fib_seq_to_seq B x2 n1 ->	                                                fib_seq_to_seq' B x2 n1)	                                           (x2 : {x : _ & A x})	                                           (x3 : fib_seq_to_seq B (x2) ^++ n1)	                                         =>	                                         coe	                                           (ap B (seq_pair_shift_assoc x2 n1))	                                           (e (x2) ^++ x3)) n0.+1 x0 	                                        (x1) ^+) => 	                              ?Goal@{n:=n0; p:=p0}) n x	                       end |} i)	";
            responses[i]=data;
          

            i = 246;
            data = "1 subgoal (ID 650)	  	  A : Sequence	  B : FibSequence A	  n : nat	  p : forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x n),	      (nat_rect	         (fun n : nat =>	          forall x1 : {x : _ & A x},	          fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	         (fun x1 : {x : _ & A x} => idmap)	         (fun (n : nat)	            (e : forall x1 : {x : _ & A x},	                 fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	            (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	          coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) n x x0) ^+ =	      nat_rect	        (fun n : nat =>	         forall x1 : {x : _ & A x},	         fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	        (fun x1 : {x : _ & A x} => idmap)	        (fun (n : nat)	           (e : forall x1 : {x : _ & A x},	                fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	           (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	         coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) n.+1 x	        (x0) ^+	  ============================	  forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x n.+1),	  (nat_rect	     (fun n0 : nat =>	      forall x1 : {x : _ & A x},	      fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	     (fun x1 : {x : _ & A x} => idmap)	     (fun (n0 : nat)	        (e : forall x1 : {x : _ & A x},	             fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	        (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	      coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+1 x x0) ^+ =	  nat_rect	    (fun n0 : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n0 : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	     coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+2 x 	    (x0) ^+	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 559)		subgoal 1 (ID 559) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	    DiagramMap_obj := fun n : Graph.graph0 sequence_graph =>	                      nat_rect	                        (fun n0 : nat =>	                         forall x0 : {x : _ & A x},	                         fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	                        (fun x0 : {x : _ & A x} => idmap)	                        (fun (n0 : nat)	                           (e : forall x0 : {x : _ & A x},	                                fib_seq_to_seq B x0 n0 ->	                                fib_seq_to_seq' B x0 n0) 	                           (x0 : {x : _ & A x}) =>	                         coe (ap B (seq_pair_shift_assoc x0 n0)) o e (x0) ^++)	                        n x;	    DiagramMap_comm := fun (n m : Graph.graph0 sequence_graph)	                         (p : Graph.graph1 sequence_graph n m) =>	                       match	                         p as p0 in (_ = y)	                         return	                           (forall x0 : fib_seq_to_seq B x n,	                            ((fib_seq_to_seq' B x) _f p0)	                              (nat_rect	                                 (fun n0 : nat =>	                                  forall x1 : {x : _ & A x},	                                  fib_seq_to_seq B x1 n0 ->	                                  fib_seq_to_seq' B x1 n0)	                                 (fun x1 : {x : _ & A x} => idmap)	                                 (fun (n0 : nat)	                                    (e : forall x1 : {x : _ & A x},	                                         fib_seq_to_seq B x1 n0 ->	                                         fib_seq_to_seq' B x1 n0)	                                    (x1 : {x : _ & A x})	                                    (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                                  coe (ap B (seq_pair_shift_assoc x1 n0))	                                    (e (x1) ^++ x2)) n x x0) =	                            nat_rect	                              (fun n0 : nat =>	                               forall x1 : {x : _ & A x},	                               fib_seq_to_seq B x1 n0 ->	                               fib_seq_to_seq' B x1 n0)	                              (fun x1 : {x : _ & A x} => idmap)	                              (fun (n0 : nat)	                                 (e : forall x1 : {x : _ & A x},	                                      fib_seq_to_seq B x1 n0 ->	                                      fib_seq_to_seq' B x1 n0)	                                 (x1 : {x : _ & A x})	                                 (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                               coe (ap B (seq_pair_shift_assoc x1 n0))	                                 (e (x1) ^++ x2)) y x	                              (((fib_seq_to_seq B x) _f p0) x0))	                       with	                       | 1 =>	                           nat_rect	                             (fun n0 : nat =>	                              forall (x0 : {x : _ & A x})	                              (x1 : fib_seq_to_seq B x0 n0),	                              (nat_rect	                                 (fun n1 : nat =>	                                  forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n1 ->	                                  fib_seq_to_seq' B x2 n1)	                                 (fun x2 : {x : _ & A x} => idmap)	                                 (fun (n1 : nat)	                                    (e : forall x2 : {x : _ & A x},	                                         fib_seq_to_seq B x2 n1 ->	                                         fib_seq_to_seq' B x2 n1)	                                    (x2 : {x : _ & A x})	                                    (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                                  coe (ap B (seq_pair_shift_assoc x2 n1))	                                    (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                              nat_rect	                                (fun n1 : nat =>	                                 forall x2 : {x : _ & A x},	                                 fib_seq_to_seq B x2 n1 ->	                                 fib_seq_to_seq' B x2 n1)	                                (fun x2 : {x : _ & A x} => idmap)	                                (fun (n1 : nat)	                                   (e : forall x2 : {x : _ & A x},	                                        fib_seq_to_seq B x2 n1 ->	                                        fib_seq_to_seq' B x2 n1)	                                   (x2 : {x : _ & A x})	                                   (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                                 coe (ap B (seq_pair_shift_assoc x2 n1))	                                   (e (x2) ^++ x3)) n0.+1 x0 	                                (x1) ^+)	                             (fun (x0 : {x : _ & A x})	                                (x1 : fib_seq_to_seq B x0 0) => 1)	                             (fun (n0 : nat)	                                (p0 : forall (x0 : {x : _ & A x})	                                      (x1 : fib_seq_to_seq B x0 n0),	                                      (nat_rect	                                         (fun n1 : nat =>	                                          forall x2 : {x : _ & A x},	                                          fib_seq_to_seq B x2 n1 ->	                                          fib_seq_to_seq' B x2 n1)	                                         (fun x2 : {x : _ & A x} => idmap)	                                         (fun (n1 : nat)	                                            (e : forall 	                                                 x2 : {x : _ & A x},	                                                 fib_seq_to_seq B x2 n1 ->	                                                 fib_seq_to_seq' B x2 n1)	                                            (x2 : {x : _ & A x})	                                            (x3 : 	                                             fib_seq_to_seq B 	                                               (x2) ^++ n1) =>	                                          coe	                                            (ap B	                                               (seq_pair_shift_assoc x2 n1))	                                            (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                                      nat_rect	                                        (fun n1 : nat =>	                                         forall x2 : {x : _ & A x},	                                         fib_seq_to_seq B x2 n1 ->	                                         fib_seq_to_seq' B x2 n1)	                                        (fun x2 : {x : _ & A x} => idmap)	                                        (fun (n1 : nat)	                                           (e : forall 	                                                x2 : {x : _ & A x},	                                                fib_seq_to_seq B x2 n1 ->	                                                fib_seq_to_seq' B x2 n1)	                                           (x2 : {x : _ & A x})	                                           (x3 : fib_seq_to_seq B (x2) ^++ n1)	                                         =>	                                         coe	                                           (ap B (seq_pair_shift_assoc x2 n1))	                                           (e (x2) ^++ x3)) n0.+1 x0 	                                        (x1) ^+) (x0 : {x : _ & A x})	                                (b : fib_seq_to_seq B x0 n0.+1) =>	                              K seq_pair_shift (fibSequenceArr B)	                                (seq_pair_shift_assoc x0 n0) @	                              ap	                                (coe	                                   (ap B	                                      (ap seq_pair_shift	                                         (seq_pair_shift_assoc x0 n0))))	                                (p0 (x0) ^++ b)) n x	                       end |} i)	";
            responses[i]=data;
          

            i = 247;
            data = "1 subgoal (ID 559)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  forall i : Graph.graph0 sequence_graph,	  IsEquiv	    ({|	     DiagramMap_obj := fun n : Graph.graph0 sequence_graph =>	                       nat_rect	                         (fun n0 : nat =>	                          forall x0 : {x : _ & A x},	                          fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	                         (fun x0 : {x : _ & A x} => idmap)	                         (fun (n0 : nat)	                            (e : forall x0 : {x : _ & A x},	                                 fib_seq_to_seq B x0 n0 ->	                                 fib_seq_to_seq' B x0 n0)	                            (x0 : {x : _ & A x}) =>	                          coe (ap B (seq_pair_shift_assoc x0 n0))	                          o e (x0) ^++) n x;	     DiagramMap_comm := fun (n m : Graph.graph0 sequence_graph)	                          (p : Graph.graph1 sequence_graph n m) =>	                        match	                          p as p0 in (_ = y)	                          return	                            (forall x0 : fib_seq_to_seq B x n,	                             ((fib_seq_to_seq' B x) _f p0)	                               (nat_rect	                                  (fun n0 : nat =>	                                   forall x1 : {x : _ & A x},	                                   fib_seq_to_seq B x1 n0 ->	                                   fib_seq_to_seq' B x1 n0)	                                  (fun x1 : {x : _ & A x} => idmap)	                                  (fun (n0 : nat)	                                     (e : forall x1 : {x : _ & A x},	                                          fib_seq_to_seq B x1 n0 ->	                                          fib_seq_to_seq' B x1 n0)	                                     (x1 : {x : _ & A x})	                                     (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                                   coe (ap B (seq_pair_shift_assoc x1 n0))	                                     (e (x1) ^++ x2)) n x x0) =	                             nat_rect	                               (fun n0 : nat =>	                                forall x1 : {x : _ & A x},	                                fib_seq_to_seq B x1 n0 ->	                                fib_seq_to_seq' B x1 n0)	                               (fun x1 : {x : _ & A x} => idmap)	                               (fun (n0 : nat)	                                  (e : forall x1 : {x : _ & A x},	                                       fib_seq_to_seq B x1 n0 ->	                                       fib_seq_to_seq' B x1 n0)	                                  (x1 : {x : _ & A x})	                                  (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                                coe (ap B (seq_pair_shift_assoc x1 n0))	                                  (e (x1) ^++ x2)) y x	                               (((fib_seq_to_seq B x) _f p0) x0))	                        with	                        | 1 =>	                            nat_rect	                              (fun n0 : nat =>	                               forall (x0 : {x : _ & A x})	                               (x1 : fib_seq_to_seq B x0 n0),	                               (nat_rect	                                  (fun n1 : nat =>	                                   forall x2 : {x : _ & A x},	                                   fib_seq_to_seq B x2 n1 ->	                                   fib_seq_to_seq' B x2 n1)	                                  (fun x2 : {x : _ & A x} => idmap)	                                  (fun (n1 : nat)	                                     (e : forall x2 : {x : _ & A x},	                                          fib_seq_to_seq B x2 n1 ->	                                          fib_seq_to_seq' B x2 n1)	                                     (x2 : {x : _ & A x})	                                     (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                                   coe (ap B (seq_pair_shift_assoc x2 n1))	                                     (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                               nat_rect	                                 (fun n1 : nat =>	                                  forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n1 ->	                                  fib_seq_to_seq' B x2 n1)	                                 (fun x2 : {x : _ & A x} => idmap)	                                 (fun (n1 : nat)	                                    (e : forall x2 : {x : _ & A x},	                                         fib_seq_to_seq B x2 n1 ->	                                         fib_seq_to_seq' B x2 n1)	                                    (x2 : {x : _ & A x})	                                    (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                                  coe (ap B (seq_pair_shift_assoc x2 n1))	                                    (e (x2) ^++ x3)) n0.+1 x0 	                                 (x1) ^+)	                              (fun (x0 : {x : _ & A x})	                                 (x1 : fib_seq_to_seq B x0 0) => 1)	                              (fun (n0 : nat)	                                 (p0 : forall (x0 : {x : _ & A x})	                                       (x1 : fib_seq_to_seq B x0 n0),	                                       (nat_rect	                                          (fun n1 : nat =>	                                           forall 	                                           x2 : {x : _ & A x},	                                           fib_seq_to_seq B x2 n1 ->	                                           fib_seq_to_seq' B x2 n1)	                                          (fun x2 : {x : _ & A x} => idmap)	                                          (fun (n1 : nat)	                                             (e : 	                                              forall 	                                              x2 : {x : _ & A x},	                                              fib_seq_to_seq B x2 n1 ->	                                              fib_seq_to_seq' B x2 n1)	                                             (x2 : {x : _ & A x})	                                             (x3 : 	                                              fib_seq_to_seq B 	                                                (x2) ^++ n1) =>	                                           coe	                                             (ap B	                                                (seq_pair_shift_assoc x2 n1))	                                             (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                                       nat_rect	                                         (fun n1 : nat =>	                                          forall x2 : {x : _ & A x},	                                          fib_seq_to_seq B x2 n1 ->	                                          fib_seq_to_seq' B x2 n1)	                                         (fun x2 : {x : _ & A x} => idmap)	                                         (fun (n1 : nat)	                                            (e : forall 	                                                 x2 : {x : _ & A x},	                                                 fib_seq_to_seq B x2 n1 ->	                                                 fib_seq_to_seq' B x2 n1)	                                            (x2 : {x : _ & A x})	                                            (x3 : 	                                             fib_seq_to_seq B 	                                               (x2) ^++ n1) =>	                                          coe	                                            (ap B	                                               (seq_pair_shift_assoc x2 n1))	                                            (e (x2) ^++ x3)) n0.+1 x0 	                                         (x1) ^+) 	                                 (x0 : {x : _ & A x})	                                 (b : fib_seq_to_seq B x0 n0.+1) =>	                               K seq_pair_shift (fibSequenceArr B)	                                 (seq_pair_shift_assoc x0 n0) @	                               ap	                                 (coe	                                    (ap B	                                       (ap seq_pair_shift	                                          (seq_pair_shift_assoc x0 n0))))	                                 (p0 (x0) ^++ b)) n x	                        end |} i)	2 subgoals (ID 685)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall x : {x : _ & A x},	  IsEquiv	    ({|	     DiagramMap_obj := fun n : Graph.graph0 sequence_graph =>	                       nat_rect	                         (fun n0 : nat =>	                          forall x0 : {x : _ & A x},	                          fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	                         (fun x0 : {x : _ & A x} => idmap)	                         (fun (n0 : nat)	                            (e : forall x0 : {x : _ & A x},	                                 fib_seq_to_seq B x0 n0 ->	                                 fib_seq_to_seq' B x0 n0)	                            (x0 : {x : _ & A x})	                            (x1 : fib_seq_to_seq B (x0) ^++ n0) =>	                          coe (ap B (seq_pair_shift_assoc x0 n0))	                            (e (x0) ^++ x1)) n x;	     DiagramMap_comm := fun (n m : Graph.graph0 sequence_graph)	                          (p : Graph.graph1 sequence_graph n m) =>	                        match	                          p as p0 in (_ = y)	                          return	                            (forall x0 : fib_seq_to_seq B x n,	                             ((fib_seq_to_seq' B x) _f p0)	                               (nat_rect	                                  (fun n0 : nat =>	                                   forall x1 : {x : _ & A x},	                                   fib_seq_to_seq B x1 n0 ->	                                   fib_seq_to_seq' B x1 n0)	                                  (fun x1 : {x : _ & A x} => idmap)	                                  (fun (n0 : nat)	                                     (e : forall x1 : {x : _ & A x},	                                          fib_seq_to_seq B x1 n0 ->	                                          fib_seq_to_seq' B x1 n0)	                                     (x1 : {x : _ & A x})	                                     (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                                   coe (ap B (seq_pair_shift_assoc x1 n0))	                                     (e (x1) ^++ x2)) n x x0) =	                             nat_rect	                               (fun n0 : nat =>	                                forall x1 : {x : _ & A x},	                                fib_seq_to_seq B x1 n0 ->	                                fib_seq_to_seq' B x1 n0)	                               (fun x1 : {x : _ & A x} => idmap)	                               (fun (n0 : nat)	                                  (e : forall x1 : {x : _ & A x},	                                       fib_seq_to_seq B x1 n0 ->	                                       fib_seq_to_seq' B x1 n0)	                                  (x1 : {x : _ & A x})	                                  (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                                coe (ap B (seq_pair_shift_assoc x1 n0))	                                  (e (x1) ^++ x2)) y x	                               (((fib_seq_to_seq B x) _f p0) x0))	                        with	                        | 1 =>	                            nat_rect	                              (fun n0 : nat =>	                               forall (x0 : {x : _ & A x})	                               (x1 : fib_seq_to_seq B x0 n0),	                               (nat_rect	                                  (fun n1 : nat =>	                                   forall x2 : {x : _ & A x},	                                   fib_seq_to_seq B x2 n1 ->	                                   fib_seq_to_seq' B x2 n1)	                                  (fun x2 : {x : _ & A x} => idmap)	                                  (fun (n1 : nat)	                                     (e : forall x2 : {x : _ & A x},	                                          fib_seq_to_seq B x2 n1 ->	                                          fib_seq_to_seq' B x2 n1)	                                     (x2 : {x : _ & A x})	                                     (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                                   coe (ap B (seq_pair_shift_assoc x2 n1))	                                     (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                               nat_rect	                                 (fun n1 : nat =>	                                  forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n1 ->	                                  fib_seq_to_seq' B x2 n1)	                                 (fun x2 : {x : _ & A x} => idmap)	                                 (fun (n1 : nat)	                                    (e : forall x2 : {x : _ & A x},	                                         fib_seq_to_seq B x2 n1 ->	                                         fib_seq_to_seq' B x2 n1)	                                    (x2 : {x : _ & A x})	                                    (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                                  coe (ap B (seq_pair_shift_assoc x2 n1))	                                    (e (x2) ^++ x3)) n0.+1 x0 	                                 (x1) ^+)	                              (fun (x0 : {x : _ & A x})	                                 (x1 : fib_seq_to_seq B x0 0) => 1)	                              (fun (n0 : nat)	                                 (p0 : forall (x0 : {x : _ & A x})	                                       (x1 : fib_seq_to_seq B x0 n0),	                                       (nat_rect	                                          (fun n1 : nat =>	                                           forall 	                                           x2 : {x : _ & A x},	                                           fib_seq_to_seq B x2 n1 ->	                                           fib_seq_to_seq' B x2 n1)	                                          (fun x2 : {x : _ & A x} => idmap)	                                          (fun (n1 : nat)	                                             (e : 	                                              forall 	                                              x2 : {x : _ & A x},	                                              fib_seq_to_seq B x2 n1 ->	                                              fib_seq_to_seq' B x2 n1)	                                             (x2 : {x : _ & A x})	                                             (x3 : 	                                              fib_seq_to_seq B 	                                                (x2) ^++ n1) =>	                                           coe	                                             (ap B	                                                (seq_pair_shift_assoc x2 n1))	                                             (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                                       nat_rect	                                         (fun n1 : nat =>	                                          forall x2 : {x : _ & A x},	                                          fib_seq_to_seq B x2 n1 ->	                                          fib_seq_to_seq' B x2 n1)	                                         (fun x2 : {x : _ & A x} => idmap)	                                         (fun (n1 : nat)	                                            (e : forall 	                                                 x2 : {x : _ & A x},	                                                 fib_seq_to_seq B x2 n1 ->	                                                 fib_seq_to_seq' B x2 n1)	                                            (x2 : {x : _ & A x})	                                            (x3 : 	                                             fib_seq_to_seq B 	                                               (x2) ^++ n1) =>	                                          coe	                                            (ap B	                                               (seq_pair_shift_assoc x2 n1))	                                            (e (x2) ^++ x3)) n0.+1 x0 	                                         (x1) ^+) 	                                 (x0 : {x : _ & A x})	                                 (b : fib_seq_to_seq B x0 n0.+1) =>	                               K seq_pair_shift (fibSequenceArr B)	                                 (seq_pair_shift_assoc x0 n0) @	                               ap	                                 (coe	                                    (ap B	                                       (ap seq_pair_shift	                                          (seq_pair_shift_assoc x0 n0))))	                                 (p0 (x0) ^++ b)) n x	                        end |} 0)		subgoal 2 (ID 688) is:	 forall x : {x : _ & A x},	 IsEquiv	   ({|	    DiagramMap_obj := fun n0 : Graph.graph0 sequence_graph =>	                      nat_rect	                        (fun n1 : nat =>	                         forall x0 : {x : _ & A x},	                         fib_seq_to_seq B x0 n1 -> fib_seq_to_seq' B x0 n1)	                        (fun x0 : {x : _ & A x} => idmap)	                        (fun (n1 : nat)	                           (e0 : forall x0 : {x : _ & A x},	                                 fib_seq_to_seq B x0 n1 ->	                                 fib_seq_to_seq' B x0 n1)	                           (x0 : {x : _ & A x})	                           (x1 : fib_seq_to_seq B (x0) ^++ n1) =>	                         coe (ap B (seq_pair_shift_assoc x0 n1))	                           (e0 (x0) ^++ x1)) n0 x;	    DiagramMap_comm := fun (n0 m : Graph.graph0 sequence_graph)	                         (p : Graph.graph1 sequence_graph n0 m) =>	                       match	                         p as p0 in (_ = y)	                         return	                           (forall x0 : fib_seq_to_seq B x n0,	                            ((fib_seq_to_seq' B x) _f p0)	                              (nat_rect	                                 (fun n1 : nat =>	                                  forall x1 : {x : _ & A x},	                                  fib_seq_to_seq B x1 n1 ->	                                  fib_seq_to_seq' B x1 n1)	                                 (fun x1 : {x : _ & A x} => idmap)	                                 (fun (n1 : nat)	                                    (e0 : forall x1 : {x : _ & A x},	                                          fib_seq_to_seq B x1 n1 ->	                                          fib_seq_to_seq' B x1 n1)	                                    (x1 : {x : _ & A x})	                                    (x2 : fib_seq_to_seq B (x1) ^++ n1) =>	                                  coe (ap B (seq_pair_shift_assoc x1 n1))	                                    (e0 (x1) ^++ x2)) n0 x x0) =	                            nat_rect	                              (fun n1 : nat =>	                               forall x1 : {x : _ & A x},	                               fib_seq_to_seq B x1 n1 ->	                               fib_seq_to_seq' B x1 n1)	                              (fun x1 : {x : _ & A x} => idmap)	                              (fun (n1 : nat)	                                 (e0 : forall x1 : {x : _ & A x},	                                       fib_seq_to_seq B x1 n1 ->	                                       fib_seq_to_seq' B x1 n1)	                                 (x1 : {x : _ & A x})	                                 (x2 : fib_seq_to_seq B (x1) ^++ n1) =>	                               coe (ap B (seq_pair_shift_assoc x1 n1))	                                 (e0 (x1) ^++ x2)) y x	                              (((fib_seq_to_seq B x) _f p0) x0))	                       with	                       | 1 =>	                           nat_rect	                             (fun n1 : nat =>	                              forall (x0 : {x : _ & A x})	                              (x1 : fib_seq_to_seq B x0 n1),	                              (nat_rect	                                 (fun n2 : nat =>	                                  forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n2 ->	                                  fib_seq_to_seq' B x2 n2)	                                 (fun x2 : {x : _ & A x} => idmap)	                                 (fun (n2 : nat)	                                    (e0 : forall x2 : {x : _ & A x},	                                          fib_seq_to_seq B x2 n2 ->	                                          fib_seq_to_seq' B x2 n2)	                                    (x2 : {x : _ & A x})	                                    (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                                  coe (ap B (seq_pair_shift_assoc x2 n2))	                                    (e0 (x2) ^++ x3)) n1 x0 x1) ^+ =	                              nat_rect	                                (fun n2 : nat =>	                                 forall x2 : {x : _ & A x},	                                 fib_seq_to_seq B x2 n2 ->	                                 fib_seq_to_seq' B x2 n2)	                                (fun x2 : {x : _ & A x} => idmap)	                                (fun (n2 : nat)	                                   (e0 : forall x2 : {x : _ & A x},	                                         fib_seq_to_seq B x2 n2 ->	                                         fib_seq_to_seq' B x2 n2)	                                   (x2 : {x : _ & A x})	                                   (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                                 coe (ap B (seq_pair_shift_assoc x2 n2))	                                   (e0 (x2) ^++ x3)) n1.+1 x0 	                                (x1) ^+)	                             (fun (x0 : {x : _ & A x})	                                (x1 : fib_seq_to_seq B x0 0) => 1)	                             (fun (n1 : nat)	                                (p0 : forall (x0 : {x : _ & A x})	                                      (x1 : fib_seq_to_seq B x0 n1),	                                      (nat_rect	                                         (fun n2 : nat =>	                                          forall x2 : {x : _ & A x},	                                          fib_seq_to_seq B x2 n2 ->	                                          fib_seq_to_seq' B x2 n2)	                                         (fun x2 : {x : _ & A x} => idmap)	                                         (fun (n2 : nat)	                                            (e0 : 	                                             forall 	                                             x2 : {x : _ & A x},	                                             fib_seq_to_seq B x2 n2 ->	                                             fib_seq_to_seq' B x2 n2)	                                            (x2 : {x : _ & A x})	                                            (x3 : 	                                             fib_seq_to_seq B 	                                               (x2) ^++ n2) =>	                                          coe	                                            (ap B	                                               (seq_pair_shift_assoc x2 n2))	                                            (e0 (x2) ^++ x3)) n1 x0 x1) ^+ =	                                      nat_rect	                                        (fun n2 : nat =>	                                         forall x2 : {x : _ & A x},	                                         fib_seq_to_seq B x2 n2 ->	                                         fib_seq_to_seq' B x2 n2)	                                        (fun x2 : {x : _ & A x} => idmap)	                                        (fun (n2 : nat)	                                           (e0 : forall 	                                                 x2 : {x : _ & A x},	                                                 fib_seq_to_seq B x2 n2 ->	                                                 fib_seq_to_seq' B x2 n2)	                                           (x2 : {x : _ & A x})	                                           (x3 : fib_seq_to_seq B (x2) ^++ n2)	                                         =>	                                         coe	                                           (ap B (seq_pair_shift_assoc x2 n2))	                                           (e0 (x2) ^++ x3)) n1.+1 x0 	                                        (x1) ^+) (x0 : {x : _ & A x})	                                (b : fib_seq_to_seq B x0 n1.+1) =>	                              K seq_pair_shift (fibSequenceArr B)	                                (seq_pair_shift_assoc x0 n1) @	                              ap	                                (coe	                                   (ap B	                                      (ap seq_pair_shift	                                         (seq_pair_shift_assoc x0 n1))))	                                (p0 (x0) ^++ b)) n0 x	                       end |} n.+1)	";
            responses[i]=data;
          

            i = 248;
            data = "1 subgoal (ID 685)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall x : {x : _ & A x},	  IsEquiv	    ({|	     DiagramMap_obj := fun n : Graph.graph0 sequence_graph =>	                       nat_rect	                         (fun n0 : nat =>	                          forall x0 : {x : _ & A x},	                          fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	                         (fun x0 : {x : _ & A x} => idmap)	                         (fun (n0 : nat)	                            (e : forall x0 : {x : _ & A x},	                                 fib_seq_to_seq B x0 n0 ->	                                 fib_seq_to_seq' B x0 n0)	                            (x0 : {x : _ & A x})	                            (x1 : fib_seq_to_seq B (x0) ^++ n0) =>	                          coe (ap B (seq_pair_shift_assoc x0 n0))	                            (e (x0) ^++ x1)) n x;	     DiagramMap_comm := fun (n m : Graph.graph0 sequence_graph)	                          (p : Graph.graph1 sequence_graph n m) =>	                        match	                          p as p0 in (_ = y)	                          return	                            (forall x0 : fib_seq_to_seq B x n,	                             ((fib_seq_to_seq' B x) _f p0)	                               (nat_rect	                                  (fun n0 : nat =>	                                   forall x1 : {x : _ & A x},	                                   fib_seq_to_seq B x1 n0 ->	                                   fib_seq_to_seq' B x1 n0)	                                  (fun x1 : {x : _ & A x} => idmap)	                                  (fun (n0 : nat)	                                     (e : forall x1 : {x : _ & A x},	                                          fib_seq_to_seq B x1 n0 ->	                                          fib_seq_to_seq' B x1 n0)	                                     (x1 : {x : _ & A x})	                                     (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                                   coe (ap B (seq_pair_shift_assoc x1 n0))	                                     (e (x1) ^++ x2)) n x x0) =	                             nat_rect	                               (fun n0 : nat =>	                                forall x1 : {x : _ & A x},	                                fib_seq_to_seq B x1 n0 ->	                                fib_seq_to_seq' B x1 n0)	                               (fun x1 : {x : _ & A x} => idmap)	                               (fun (n0 : nat)	                                  (e : forall x1 : {x : _ & A x},	                                       fib_seq_to_seq B x1 n0 ->	                                       fib_seq_to_seq' B x1 n0)	                                  (x1 : {x : _ & A x})	                                  (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                                coe (ap B (seq_pair_shift_assoc x1 n0))	                                  (e (x1) ^++ x2)) y x	                               (((fib_seq_to_seq B x) _f p0) x0))	                        with	                        | 1 =>	                            nat_rect	                              (fun n0 : nat =>	                               forall (x0 : {x : _ & A x})	                               (x1 : fib_seq_to_seq B x0 n0),	                               (nat_rect	                                  (fun n1 : nat =>	                                   forall x2 : {x : _ & A x},	                                   fib_seq_to_seq B x2 n1 ->	                                   fib_seq_to_seq' B x2 n1)	                                  (fun x2 : {x : _ & A x} => idmap)	                                  (fun (n1 : nat)	                                     (e : forall x2 : {x : _ & A x},	                                          fib_seq_to_seq B x2 n1 ->	                                          fib_seq_to_seq' B x2 n1)	                                     (x2 : {x : _ & A x})	                                     (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                                   coe (ap B (seq_pair_shift_assoc x2 n1))	                                     (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                               nat_rect	                                 (fun n1 : nat =>	                                  forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n1 ->	                                  fib_seq_to_seq' B x2 n1)	                                 (fun x2 : {x : _ & A x} => idmap)	                                 (fun (n1 : nat)	                                    (e : forall x2 : {x : _ & A x},	                                         fib_seq_to_seq B x2 n1 ->	                                         fib_seq_to_seq' B x2 n1)	                                    (x2 : {x : _ & A x})	                                    (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                                  coe (ap B (seq_pair_shift_assoc x2 n1))	                                    (e (x2) ^++ x3)) n0.+1 x0 	                                 (x1) ^+)	                              (fun (x0 : {x : _ & A x})	                                 (x1 : fib_seq_to_seq B x0 0) => 1)	                              (fun (n0 : nat)	                                 (p0 : forall (x0 : {x : _ & A x})	                                       (x1 : fib_seq_to_seq B x0 n0),	                                       (nat_rect	                                          (fun n1 : nat =>	                                           forall 	                                           x2 : {x : _ & A x},	                                           fib_seq_to_seq B x2 n1 ->	                                           fib_seq_to_seq' B x2 n1)	                                          (fun x2 : {x : _ & A x} => idmap)	                                          (fun (n1 : nat)	                                             (e : 	                                              forall 	                                              x2 : {x : _ & A x},	                                              fib_seq_to_seq B x2 n1 ->	                                              fib_seq_to_seq' B x2 n1)	                                             (x2 : {x : _ & A x})	                                             (x3 : 	                                              fib_seq_to_seq B 	                                                (x2) ^++ n1) =>	                                           coe	                                             (ap B	                                                (seq_pair_shift_assoc x2 n1))	                                             (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                                       nat_rect	                                         (fun n1 : nat =>	                                          forall x2 : {x : _ & A x},	                                          fib_seq_to_seq B x2 n1 ->	                                          fib_seq_to_seq' B x2 n1)	                                         (fun x2 : {x : _ & A x} => idmap)	                                         (fun (n1 : nat)	                                            (e : forall 	                                                 x2 : {x : _ & A x},	                                                 fib_seq_to_seq B x2 n1 ->	                                                 fib_seq_to_seq' B x2 n1)	                                            (x2 : {x : _ & A x})	                                            (x3 : 	                                             fib_seq_to_seq B 	                                               (x2) ^++ n1) =>	                                          coe	                                            (ap B	                                               (seq_pair_shift_assoc x2 n1))	                                            (e (x2) ^++ x3)) n0.+1 x0 	                                         (x1) ^+) 	                                 (x0 : {x : _ & A x})	                                 (b : fib_seq_to_seq B x0 n0.+1) =>	                               K seq_pair_shift (fibSequenceArr B)	                                 (seq_pair_shift_assoc x0 n0) @	                               ap	                                 (coe	                                    (ap B	                                       (ap seq_pair_shift	                                          (seq_pair_shift_assoc x0 n0))))	                                 (p0 (x0) ^++ b)) n x	                        end |} 0)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 subgoal (ID 688)		subgoal 1 (ID 688) is:	 forall x : {x : _ & A x},	 IsEquiv	   ({|	    DiagramMap_obj := fun n0 : Graph.graph0 sequence_graph =>	                      nat_rect	                        (fun n1 : nat =>	                         forall x0 : {x : _ & A x},	                         fib_seq_to_seq B x0 n1 -> fib_seq_to_seq' B x0 n1)	                        (fun x0 : {x : _ & A x} => idmap)	                        (fun (n1 : nat)	                           (e0 : forall x0 : {x : _ & A x},	                                 fib_seq_to_seq B x0 n1 ->	                                 fib_seq_to_seq' B x0 n1)	                           (x0 : {x : _ & A x})	                           (x1 : fib_seq_to_seq B (x0) ^++ n1) =>	                         coe (ap B (seq_pair_shift_assoc x0 n1))	                           (e0 (x0) ^++ x1)) n0 x;	    DiagramMap_comm := fun (n0 m : Graph.graph0 sequence_graph)	                         (p : Graph.graph1 sequence_graph n0 m) =>	                       match	                         p as p0 in (_ = y)	                         return	                           (forall x0 : fib_seq_to_seq B x n0,	                            ((fib_seq_to_seq' B x) _f p0)	                              (nat_rect	                                 (fun n1 : nat =>	                                  forall x1 : {x : _ & A x},	                                  fib_seq_to_seq B x1 n1 ->	                                  fib_seq_to_seq' B x1 n1)	                                 (fun x1 : {x : _ & A x} => idmap)	                                 (fun (n1 : nat)	                                    (e0 : forall x1 : {x : _ & A x},	                                          fib_seq_to_seq B x1 n1 ->	                                          fib_seq_to_seq' B x1 n1)	                                    (x1 : {x : _ & A x})	                                    (x2 : fib_seq_to_seq B (x1) ^++ n1) =>	                                  coe (ap B (seq_pair_shift_assoc x1 n1))	                                    (e0 (x1) ^++ x2)) n0 x x0) =	                            nat_rect	                              (fun n1 : nat =>	                               forall x1 : {x : _ & A x},	                               fib_seq_to_seq B x1 n1 ->	                               fib_seq_to_seq' B x1 n1)	                              (fun x1 : {x : _ & A x} => idmap)	                              (fun (n1 : nat)	                                 (e0 : forall x1 : {x : _ & A x},	                                       fib_seq_to_seq B x1 n1 ->	                                       fib_seq_to_seq' B x1 n1)	                                 (x1 : {x : _ & A x})	                                 (x2 : fib_seq_to_seq B (x1) ^++ n1) =>	                               coe (ap B (seq_pair_shift_assoc x1 n1))	                                 (e0 (x1) ^++ x2)) y x	                              (((fib_seq_to_seq B x) _f p0) x0))	                       with	                       | 1 =>	                           nat_rect	                             (fun n1 : nat =>	                              forall (x0 : {x : _ & A x})	                              (x1 : fib_seq_to_seq B x0 n1),	                              (nat_rect	                                 (fun n2 : nat =>	                                  forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n2 ->	                                  fib_seq_to_seq' B x2 n2)	                                 (fun x2 : {x : _ & A x} => idmap)	                                 (fun (n2 : nat)	                                    (e0 : forall x2 : {x : _ & A x},	                                          fib_seq_to_seq B x2 n2 ->	                                          fib_seq_to_seq' B x2 n2)	                                    (x2 : {x : _ & A x})	                                    (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                                  coe (ap B (seq_pair_shift_assoc x2 n2))	                                    (e0 (x2) ^++ x3)) n1 x0 x1) ^+ =	                              nat_rect	                                (fun n2 : nat =>	                                 forall x2 : {x : _ & A x},	                                 fib_seq_to_seq B x2 n2 ->	                                 fib_seq_to_seq' B x2 n2)	                                (fun x2 : {x : _ & A x} => idmap)	                                (fun (n2 : nat)	                                   (e0 : forall x2 : {x : _ & A x},	                                         fib_seq_to_seq B x2 n2 ->	                                         fib_seq_to_seq' B x2 n2)	                                   (x2 : {x : _ & A x})	                                   (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                                 coe (ap B (seq_pair_shift_assoc x2 n2))	                                   (e0 (x2) ^++ x3)) n1.+1 x0 	                                (x1) ^+)	                             (fun (x0 : {x : _ & A x})	                                (x1 : fib_seq_to_seq B x0 0) => 1)	                             (fun (n1 : nat)	                                (p0 : forall (x0 : {x : _ & A x})	                                      (x1 : fib_seq_to_seq B x0 n1),	                                      (nat_rect	                                         (fun n2 : nat =>	                                          forall x2 : {x : _ & A x},	                                          fib_seq_to_seq B x2 n2 ->	                                          fib_seq_to_seq' B x2 n2)	                                         (fun x2 : {x : _ & A x} => idmap)	                                         (fun (n2 : nat)	                                            (e0 : 	                                             forall 	                                             x2 : {x : _ & A x},	                                             fib_seq_to_seq B x2 n2 ->	                                             fib_seq_to_seq' B x2 n2)	                                            (x2 : {x : _ & A x})	                                            (x3 : 	                                             fib_seq_to_seq B 	                                               (x2) ^++ n2) =>	                                          coe	                                            (ap B	                                               (seq_pair_shift_assoc x2 n2))	                                            (e0 (x2) ^++ x3)) n1 x0 x1) ^+ =	                                      nat_rect	                                        (fun n2 : nat =>	                                         forall x2 : {x : _ & A x},	                                         fib_seq_to_seq B x2 n2 ->	                                         fib_seq_to_seq' B x2 n2)	                                        (fun x2 : {x : _ & A x} => idmap)	                                        (fun (n2 : nat)	                                           (e0 : forall 	                                                 x2 : {x : _ & A x},	                                                 fib_seq_to_seq B x2 n2 ->	                                                 fib_seq_to_seq' B x2 n2)	                                           (x2 : {x : _ & A x})	                                           (x3 : fib_seq_to_seq B (x2) ^++ n2)	                                         =>	                                         coe	                                           (ap B (seq_pair_shift_assoc x2 n2))	                                           (e0 (x2) ^++ x3)) n1.+1 x0 	                                        (x1) ^+) (x0 : {x : _ & A x})	                                (b : fib_seq_to_seq B x0 n1.+1) =>	                              K seq_pair_shift (fibSequenceArr B)	                                (seq_pair_shift_assoc x0 n1) @	                              ap	                                (coe	                                   (ap B	                                      (ap seq_pair_shift	                                         (seq_pair_shift_assoc x0 n1))))	                                (p0 (x0) ^++ b)) n0 x	                       end |} n.+1)	";
            responses[i]=data;
          

            i = 249;
            data = "1 subgoal (ID 688)	  	  A : Sequence	  B : FibSequence A	  n : nat	  e : forall x : {x : _ & A x},	      IsEquiv	        ({|	         DiagramMap_obj := fun n : Graph.graph0 sequence_graph =>	                           nat_rect	                             (fun n0 : nat =>	                              forall x0 : {x : _ & A x},	                              fib_seq_to_seq B x0 n0 ->	                              fib_seq_to_seq' B x0 n0)	                             (fun x0 : {x : _ & A x} => idmap)	                             (fun (n0 : nat)	                                (e : forall x0 : {x : _ & A x},	                                     fib_seq_to_seq B x0 n0 ->	                                     fib_seq_to_seq' B x0 n0)	                                (x0 : {x : _ & A x})	                                (x1 : fib_seq_to_seq B (x0) ^++ n0) =>	                              coe (ap B (seq_pair_shift_assoc x0 n0))	                                (e (x0) ^++ x1)) n x;	         DiagramMap_comm := fun (n m : Graph.graph0 sequence_graph)	                              (p : Graph.graph1 sequence_graph n m) =>	                            match	                              p as p0 in (_ = y)	                              return	                                (forall x0 : fib_seq_to_seq B x n,	                                 ((fib_seq_to_seq' B x) _f p0)	                                   (nat_rect	                                      (fun n0 : nat =>	                                       forall x1 : {x : _ & A x},	                                       fib_seq_to_seq B x1 n0 ->	                                       fib_seq_to_seq' B x1 n0)	                                      (fun x1 : {x : _ & A x} => idmap)	                                      (fun (n0 : nat)	                                         (e : forall 	                                              x1 : {x : _ & A x},	                                              fib_seq_to_seq B x1 n0 ->	                                              fib_seq_to_seq' B x1 n0)	                                         (x1 : {x : _ & A x})	                                         (x2 : fib_seq_to_seq B (x1) ^++ n0)	                                       =>	                                       coe	                                         (ap B (seq_pair_shift_assoc x1 n0))	                                         (e (x1) ^++ x2)) n x x0) =	                                 nat_rect	                                   (fun n0 : nat =>	                                    forall x1 : {x : _ & A x},	                                    fib_seq_to_seq B x1 n0 ->	                                    fib_seq_to_seq' B x1 n0)	                                   (fun x1 : {x : _ & A x} => idmap)	                                   (fun (n0 : nat)	                                      (e : forall 	                                           x1 : {x : _ & A x},	                                           fib_seq_to_seq B x1 n0 ->	                                           fib_seq_to_seq' B x1 n0)	                                      (x1 : {x : _ & A x})	                                      (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                                    coe (ap B (seq_pair_shift_assoc x1 n0))	                                      (e (x1) ^++ x2)) y x	                                   (((fib_seq_to_seq B x) _f p0) x0))	                            with	                            | 1 =>	                                nat_rect	                                  (fun n0 : nat =>	                                   forall (x0 : {x : _ & A x})	                                   (x1 : fib_seq_to_seq B x0 n0),	                                   (nat_rect	                                      (fun n1 : nat =>	                                       forall x2 : {x : _ & A x},	                                       fib_seq_to_seq B x2 n1 ->	                                       fib_seq_to_seq' B x2 n1)	                                      (fun x2 : {x : _ & A x} => idmap)	                                      (fun (n1 : nat)	                                         (e : forall 	                                              x2 : {x : _ & A x},	                                              fib_seq_to_seq B x2 n1 ->	                                              fib_seq_to_seq' B x2 n1)	                                         (x2 : {x : _ & A x})	                                         (x3 : fib_seq_to_seq B (x2) ^++ n1)	                                       =>	                                       coe	                                         (ap B (seq_pair_shift_assoc x2 n1))	                                         (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                                   nat_rect	                                     (fun n1 : nat =>	                                      forall x2 : {x : _ & A x},	                                      fib_seq_to_seq B x2 n1 ->	                                      fib_seq_to_seq' B x2 n1)	                                     (fun x2 : {x : _ & A x} => idmap)	                                     (fun (n1 : nat)	                                        (e : forall 	                                             x2 : {x : _ & A x},	                                             fib_seq_to_seq B x2 n1 ->	                                             fib_seq_to_seq' B x2 n1)	                                        (x2 : {x : _ & A x})	                                        (x3 : fib_seq_to_seq B (x2) ^++ n1)	                                      =>	                                      coe (ap B (seq_pair_shift_assoc x2 n1))	                                        (e (x2) ^++ x3)) n0.+1 x0 	                                     (x1) ^+)	                                  (fun (x0 : {x : _ & A x})	                                     (x1 : fib_seq_to_seq B x0 0) => 1)	                                  (fun (n0 : nat)	                                     (p0 : forall 	                                           (x0 : {x : _ & A x})	                                           (x1 : fib_seq_to_seq B x0 n0),	                                           (nat_rect	                                              (fun n1 : nat =>	                                               forall 	                                               x2 : {x : _ & A x},	                                               fib_seq_to_seq B x2 n1 ->	                                               fib_seq_to_seq' B x2 n1)	                                              (fun x2 : {x : _ & A x} =>	                                               idmap)	                                              (fun 	                                                 (n1 : nat)	                                                 (e : 	                                                 forall 	                                                 x2 : {x : _ & A x},	                                                 fib_seq_to_seq B x2 n1 ->	                                                 fib_seq_to_seq' B x2 n1)	                                                 (x2 : {x : _ & A x})	                                                 (x3 : 	                                                 fib_seq_to_seq B 	                                                 (x2) ^++ n1) =>	                                               coe	                                                 (ap B	                                                 (seq_pair_shift_assoc x2 n1))	                                                 (e (x2) ^++ x3)) n0 x0 x1)	                                           ^+ =	                                           nat_rect	                                             (fun n1 : nat =>	                                              forall 	                                              x2 : {x : _ & A x},	                                              fib_seq_to_seq B x2 n1 ->	                                              fib_seq_to_seq' B x2 n1)	                                             (fun x2 : {x : _ & A x} => idmap)	                                             (fun 	                                                (n1 : nat)	                                                (e : 	                                                 forall 	                                                 x2 : {x : _ & A x},	                                                 fib_seq_to_seq B x2 n1 ->	                                                 fib_seq_to_seq' B x2 n1)	                                                (x2 : {x : _ & A x})	                                                (x3 : 	                                                 fib_seq_to_seq B 	                                                 (x2) ^++ n1) =>	                                              coe	                                                (ap B	                                                 (seq_pair_shift_assoc x2 n1))	                                                (e (x2) ^++ x3)) n0.+1 x0	                                             (x1) ^+) 	                                     (x0 : {x : _ & A x})	                                     (b : fib_seq_to_seq B x0 n0.+1) =>	                                   K seq_pair_shift 	                                     (fibSequenceArr B)	                                     (seq_pair_shift_assoc x0 n0) @	                                   ap	                                     (coe	                                        (ap B	                                           (ap seq_pair_shift	                                              (seq_pair_shift_assoc x0 n0))))	                                     (p0 (x0) ^++ b)) n x	                            end |} n)	  ============================	  forall x : {x : _ & A x},	  IsEquiv	    ({|	     DiagramMap_obj := fun n0 : Graph.graph0 sequence_graph =>	                       nat_rect	                         (fun n1 : nat =>	                          forall x0 : {x : _ & A x},	                          fib_seq_to_seq B x0 n1 -> fib_seq_to_seq' B x0 n1)	                         (fun x0 : {x : _ & A x} => idmap)	                         (fun (n1 : nat)	                            (e0 : forall x0 : {x : _ & A x},	                                  fib_seq_to_seq B x0 n1 ->	                                  fib_seq_to_seq' B x0 n1)	                            (x0 : {x : _ & A x})	                            (x1 : fib_seq_to_seq B (x0) ^++ n1) =>	                          coe (ap B (seq_pair_shift_assoc x0 n1))	                            (e0 (x0) ^++ x1)) n0 x;	     DiagramMap_comm := fun (n0 m : Graph.graph0 sequence_graph)	                          (p : Graph.graph1 sequence_graph n0 m) =>	                        match	                          p as p0 in (_ = y)	                          return	                            (forall x0 : fib_seq_to_seq B x n0,	                             ((fib_seq_to_seq' B x) _f p0)	                               (nat_rect	                                  (fun n1 : nat =>	                                   forall x1 : {x : _ & A x},	                                   fib_seq_to_seq B x1 n1 ->	                                   fib_seq_to_seq' B x1 n1)	                                  (fun x1 : {x : _ & A x} => idmap)	                                  (fun (n1 : nat)	                                     (e0 : forall 	                                           x1 : {x : _ & A x},	                                           fib_seq_to_seq B x1 n1 ->	                                           fib_seq_to_seq' B x1 n1)	                                     (x1 : {x : _ & A x})	                                     (x2 : fib_seq_to_seq B (x1) ^++ n1) =>	                                   coe (ap B (seq_pair_shift_assoc x1 n1))	                                     (e0 (x1) ^++ x2)) n0 x x0) =	                             nat_rect	                               (fun n1 : nat =>	                                forall x1 : {x : _ & A x},	                                fib_seq_to_seq B x1 n1 ->	                                fib_seq_to_seq' B x1 n1)	                               (fun x1 : {x : _ & A x} => idmap)	                               (fun (n1 : nat)	                                  (e0 : forall x1 : {x : _ & A x},	                                        fib_seq_to_seq B x1 n1 ->	                                        fib_seq_to_seq' B x1 n1)	                                  (x1 : {x : _ & A x})	                                  (x2 : fib_seq_to_seq B (x1) ^++ n1) =>	                                coe (ap B (seq_pair_shift_assoc x1 n1))	                                  (e0 (x1) ^++ x2)) y x	                               (((fib_seq_to_seq B x) _f p0) x0))	                        with	                        | 1 =>	                            nat_rect	                              (fun n1 : nat =>	                               forall (x0 : {x : _ & A x})	                               (x1 : fib_seq_to_seq B x0 n1),	                               (nat_rect	                                  (fun n2 : nat =>	                                   forall x2 : {x : _ & A x},	                                   fib_seq_to_seq B x2 n2 ->	                                   fib_seq_to_seq' B x2 n2)	                                  (fun x2 : {x : _ & A x} => idmap)	                                  (fun (n2 : nat)	                                     (e0 : forall 	                                           x2 : {x : _ & A x},	                                           fib_seq_to_seq B x2 n2 ->	                                           fib_seq_to_seq' B x2 n2)	                                     (x2 : {x : _ & A x})	                                     (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                                   coe (ap B (seq_pair_shift_assoc x2 n2))	                                     (e0 (x2) ^++ x3)) n1 x0 x1) ^+ =	                               nat_rect	                                 (fun n2 : nat =>	                                  forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n2 ->	                                  fib_seq_to_seq' B x2 n2)	                                 (fun x2 : {x : _ & A x} => idmap)	                                 (fun (n2 : nat)	                                    (e0 : forall x2 : {x : _ & A x},	                                          fib_seq_to_seq B x2 n2 ->	                                          fib_seq_to_seq' B x2 n2)	                                    (x2 : {x : _ & A x})	                                    (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                                  coe (ap B (seq_pair_shift_assoc x2 n2))	                                    (e0 (x2) ^++ x3)) n1.+1 x0 	                                 (x1) ^+)	                              (fun (x0 : {x : _ & A x})	                                 (x1 : fib_seq_to_seq B x0 0) => 1)	                              (fun (n1 : nat)	                                 (p0 : forall (x0 : {x : _ & A x})	                                       (x1 : fib_seq_to_seq B x0 n1),	                                       (nat_rect	                                          (fun n2 : nat =>	                                           forall 	                                           x2 : {x : _ & A x},	                                           fib_seq_to_seq B x2 n2 ->	                                           fib_seq_to_seq' B x2 n2)	                                          (fun x2 : {x : _ & A x} => idmap)	                                          (fun (n2 : nat)	                                             (e0 : 	                                              forall 	                                              x2 : {x : _ & A x},	                                              fib_seq_to_seq B x2 n2 ->	                                              fib_seq_to_seq' B x2 n2)	                                             (x2 : {x : _ & A x})	                                             (x3 : 	                                              fib_seq_to_seq B 	                                                (x2) ^++ n2) =>	                                           coe	                                             (ap B	                                                (seq_pair_shift_assoc x2 n2))	                                             (e0 (x2) ^++ x3)) n1 x0 x1) ^+ =	                                       nat_rect	                                         (fun n2 : nat =>	                                          forall x2 : {x : _ & A x},	                                          fib_seq_to_seq B x2 n2 ->	                                          fib_seq_to_seq' B x2 n2)	                                         (fun x2 : {x : _ & A x} => idmap)	                                         (fun (n2 : nat)	                                            (e0 : 	                                             forall 	                                             x2 : {x : _ & A x},	                                             fib_seq_to_seq B x2 n2 ->	                                             fib_seq_to_seq' B x2 n2)	                                            (x2 : {x : _ & A x})	                                            (x3 : 	                                             fib_seq_to_seq B 	                                               (x2) ^++ n2) =>	                                          coe	                                            (ap B	                                               (seq_pair_shift_assoc x2 n2))	                                            (e0 (x2) ^++ x3)) n1.+1 x0	                                         (x1) ^+) 	                                 (x0 : {x : _ & A x})	                                 (b : fib_seq_to_seq B x0 n1.+1) =>	                               K seq_pair_shift (fibSequenceArr B)	                                 (seq_pair_shift_assoc x0 n1) @	                               ap	                                 (coe	                                    (ap B	                                       (ap seq_pair_shift	                                          (seq_pair_shift_assoc x0 n1))))	                                 (p0 (x0) ^++ b)) n0 x	                        end |} n.+1)	No more subgoals.	";
            responses[i]=data;
          

            i = 250;
            data = "";
            responses[i]=data;
          

            i = 251;
            data = "";
            responses[i]=data;
          

            i = 252;
            data = "";
            responses[i]=data;
          

            i = 253;
            data = "";
            responses[i]=data;
          

            i = 254;
            data = "";
            responses[i]=data;
          

            i = 255;
            data = "1 subgoal (ID 540)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  Colimit A -> Type	";
            responses[i]=data;
          

            i = 256;
            data = "";
            responses[i]=data;
          

            i = 257;
            data = "2 subgoals (ID 572)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> Type		subgoal 2 (ID 574) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j), ?legs j o A _f g == ?legs i	";
            responses[i]=data;
          

            i = 258;
            data = "1 subgoal (ID 572)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> Type	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 574)		subgoal 1 (ID 574) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	  Colimit (fib_seq_to_seq B (n; a))) j o A _f g ==	 (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	  Colimit (fib_seq_to_seq B (n; a))) i	";
            responses[i]=data;
          

            i = 259;
            data = "1 subgoal (ID 574)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	   Colimit (fib_seq_to_seq B (n; a))) j o A _f g ==	  (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	   Colimit (fib_seq_to_seq B (n; a))) i	1 subgoal (ID 594)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  Colimit (fib_seq_to_seq B (n.+1; (a) ^+)) <~>	  Colimit (fib_seq_to_seq B (n; a))	";
            responses[i]=data;
          

            i = 260;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 261;
            data = "";
            responses[i]=data;
          

            i = 262;
            data = "1 subgoal (ID 570)	  	  H : Univalence	  A : Diagram sequence_graph	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  coe (ap (fib_seq_to_type_fam B) (glue A n a)) =	  colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a))	";
            responses[i]=data;
          

            i = 263;
            data = "";
            responses[i]=data;
          

            i = 264;
            data = "1 subgoal (ID 596)	  	  H : Univalence	  A : Diagram sequence_graph	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  coe	    (legs_comm	       {|	       legs := fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	               Colimit (fib_seq_to_seq B (n0; a0));	       legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                      (p : Graph.graph1 sequence_graph n0 m) 	                      (a0 : A n0) =>	                    match	                      p as p0 in (_ = y)	                      return	                        (Colimit (fib_seq_to_seq B (y; (A _f p0) a0)) =	                         Colimit (fib_seq_to_seq B (n0; a0)))	                    with	                    | 1 =>	                        path_universe_uncurried	                          (equiv_colim_succ_seq_to_colim_seq	                             (fib_seq_to_seq B (n0; a0)))	                    end |} n n.+1 1 a) =	  colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a))	";
            responses[i]=data;
          

            i = 265;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 266;
            data = "";
            responses[i]=data;
          

            i = 267;
            data = "1 subgoal (ID 606)	  	  X : Type	  Y : X -> Type	  x1, x2 : X	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  psi : coe (ap Y p) = F	  y : Y x1	  ============================	  (x1; y) = (x2; F y)	";
            responses[i]=data;
          

            i = 268;
            data = "";
            responses[i]=data;
          

            i = 269;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 270;
            data = "";
            responses[i]=data;
          

            i = 271;
            data = "1 subgoal (ID 646)	  	  X : Type	  Y : X -> Type	  x1, x2 : X	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  psi : coe (ap Y p) = F	  y : Y x1	  ============================	  ap pr1 (Delta p psi y) = p	";
            responses[i]=data;
          

            i = 272;
            data = "";
            responses[i]=data;
          

            i = 273;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 274;
            data = "";
            responses[i]=data;
          

            i = 275;
            data = "";
            responses[i]=data;
          

            i = 276;
            data = "";
            responses[i]=data;
          

            i = 277;
            data = "";
            responses[i]=data;
          

            i = 278;
            data = "";
            responses[i]=data;
          

            i = 279;
            data = "1 subgoal (ID 656)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  Colimit (sig_seq B) -> {x : _ & fib_seq_to_type_fam B x}	";
            responses[i]=data;
          

            i = 280;
            data = "";
            responses[i]=data;
          

            i = 281;
            data = "2 subgoals (ID 688)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph,	  sig_seq B i -> {x : _ & fib_seq_to_type_fam B x}		subgoal 2 (ID 690) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j), ?legs j o (sig_seq B) _f g == ?legs i	";
            responses[i]=data;
          

            i = 282;
            data = "1 subgoal (ID 688)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph,	  sig_seq B i -> {x : _ & fib_seq_to_type_fam B x}	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 690)		subgoal 1 (ID 690) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	  (fun (a : A n) (b : B (n; a)) =>	   (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)) X.1 X.2) j	 o (sig_seq B) _f g ==	 (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	  (fun (a : A n) (b : B (n; a)) =>	   (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)) X.1 X.2) i	";
            responses[i]=data;
          

            i = 283;
            data = "1 subgoal (ID 690)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	   (fun (a : A n) (b : B (n; a)) =>	    (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)) X.1 X.2) j	  o (sig_seq B) _f g ==	  (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	   (fun (a : A n) (b : B (n; a)) =>	    (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)) X.1 X.2) i	1 subgoal (ID 723)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  ============================	  (inj A n.+1 ((a; b)) ^+.1;	  inj (fib_seq_to_seq B (n.+1; ((a; b)) ^+.1)) 0 ((a; b)) ^+.2) =	  (inj A n a; inj (fib_seq_to_seq B (n; a)) 1 (b) ^+)	";
            responses[i]=data;
          

            i = 284;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 285;
            data = "";
            responses[i]=data;
          

            i = 286;
            data = "1 subgoal (ID 722)	  	  H : Univalence	  A : Diagram sequence_graph	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  b : (fun a : A n => B (n; a)) a	  ============================	  ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)) =	  Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a)	    (inj (fib_seq_to_seq B (n.+1; (a) ^+)) 0 (b) ^+) @	  ap (exist (fib_seq_to_type_fam B) (inj A n a))	    (glue (fib_seq_to_seq B (n; a)) 0 b)	";
            responses[i]=data;
          

            i = 287;
            data = "";
            responses[i]=data;
          

            i = 288;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 289;
            data = "";
            responses[i]=data;
          

            i = 290;
            data = "";
            responses[i]=data;
          

            i = 291;
            data = "";
            responses[i]=data;
          

            i = 292;
            data = "";
            responses[i]=data;
          

            i = 293;
            data = "";
            responses[i]=data;
          

            i = 294;
            data = "";
            responses[i]=data;
          

            i = 295;
            data = "<infomsg>H is declared</infomsg>	<infomsg>A is declared</infomsg>	<infomsg>B is declared</infomsg>	";
            responses[i]=data;
          

            i = 296;
            data = "<infomsg>E is declared</infomsg>	";
            responses[i]=data;
          

            i = 297;
            data = "<infomsg>e is declared</infomsg>	";
            responses[i]=data;
          

            i = 298;
            data = "<infomsg>t is declared</infomsg>	";
            responses[i]=data;
          

            i = 299;
            data = "";
            responses[i]=data;
          

            i = 300;
            data = "";
            responses[i]=data;
          

            i = 301;
            data = "";
            responses[i]=data;
          

            i = 302;
            data = "";
            responses[i]=data;
          

            i = 303;
            data = "1 subgoal (ID 790)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  k : Graph.graph0 sequence_graph	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) k),	  E (inj A n a; inj (fib_seq_to_seq B (n; a)) k b)	";
            responses[i]=data;
          

            i = 304;
            data = "";
            responses[i]=data;
          

            i = 305;
            data = "2 subgoals (ID 794)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) 0),	  E (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)		subgoal 2 (ID 797) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n)	 (b : fib_seq_to_seq B (n; a) k.+1),	 E (inj A n a; inj (fib_seq_to_seq B (n; a)) k.+1 b)	";
            responses[i]=data;
          

            i = 306;
            data = "1 subgoal (ID 794)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) 0),	  E (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 797)		subgoal 1 (ID 797) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n)	 (b : fib_seq_to_seq B (n; a) k.+1),	 E (inj A n a; inj (fib_seq_to_seq B (n; a)) k.+1 b)	";
            responses[i]=data;
          

            i = 307;
            data = "1 subgoal (ID 797)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  k : nat	  h : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : fib_seq_to_seq B (n; a) k),	      E (inj A n a; inj (fib_seq_to_seq B (n; a)) k b)	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) k.+1),	  E (inj A n a; inj (fib_seq_to_seq B (n; a)) k.+1 b)	No more subgoals.	";
            responses[i]=data;
          

            i = 308;
            data = "";
            responses[i]=data;
          

            i = 309;
            data = "";
            responses[i]=data;
          

            i = 310;
            data = "";
            responses[i]=data;
          

            i = 311;
            data = "";
            responses[i]=data;
          

            i = 312;
            data = "";
            responses[i]=data;
          

            i = 313;
            data = "1 subgoal (ID 865)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x : X	  y1, y2 : Y x	  z : {x : _ & Y x}	  p : y1 = y2	  q1 : z = (x; y1)	  q2 : z = (x; y2)	  theta : q2 = q1 @ ap (exist Y x) p	  ============================	  transport (Z o exist Y x) p o transport Z q1 == transport Z q2	";
            responses[i]=data;
          

            i = 314;
            data = "";
            responses[i]=data;
          

            i = 315;
            data = "1 subgoal (ID 891)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x : X	  y1 : Y x	  z : {x : _ & Y x}	  ============================	  (fun x0 : Z z => transport Z 1 x0) == transport Z (1 @ 1)	";
            responses[i]=data;
          

            i = 316;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 317;
            data = "";
            responses[i]=data;
          

            i = 318;
            data = "1 subgoal (ID 976)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x1, x2 : X	  y1, y2 : Y x1	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  q : y1 = y2	  psi : coe (ap Y p) = F	  r : F y1 = F y2	  theta : ap F q = r	  ============================	  transport (Z o exist Y x2) r o transport Z (Delta p psi y1) ==	  transport Z (Delta p psi y2) o transport (Z o exist Y x1) q	";
            responses[i]=data;
          

            i = 319;
            data = "";
            responses[i]=data;
          

            i = 320;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 321;
            data = "";
            responses[i]=data;
          

            i = 322;
            data = "";
            responses[i]=data;
          

            i = 323;
            data = "";
            responses[i]=data;
          

            i = 324;
            data = "";
            responses[i]=data;
          

            i = 325;
            data = "";
            responses[i]=data;
          

            i = 326;
            data = "1 subgoal (ID 1015)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  k : Graph.graph0 sequence_graph	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) k),	  transport (E o exist (fib_seq_to_type_fam B) (inj A n a))	    (glue (fib_seq_to_seq B (n; a)) k b) (Q k.+1 n a (b) ^+) = 	  Q k n a b	";
            responses[i]=data;
          

            i = 327;
            data = "";
            responses[i]=data;
          

            i = 328;
            data = "2 subgoals (ID 1019)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) 0),	  transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	    (colimp 0 1 1 b) (Q 1 n a (b) ^+) = Q 0 n a b		subgoal 2 (ID 1022) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n)	 (b : fib_seq_to_seq B (n; a) k.+1),	 transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	   (colimp k.+1 k.+2 1 b) (Q k.+2 n a (b) ^+) = Q k.+1 n a b	";
            responses[i]=data;
          

            i = 329;
            data = "1 subgoal (ID 1019)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) 0),	  transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	    (colimp 0 1 1 b) (Q 1 n a (b) ^+) = Q 0 n a b	1 subgoal (ID 1031)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : fib_seq_to_seq B (n; a) 0	  ============================	  transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	    (colimp 0 1 1 b) (Q 1 n a (b) ^+) =	  transport E	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	    (e n.+1 (a) ^+ (b) ^+f)	";
            responses[i]=data;
          

            i = 330;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 1022)		subgoal 1 (ID 1022) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n)	 (b : fib_seq_to_seq B (n; a) k.+1),	 transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	   (colimp k.+1 k.+2 1 b) (Q k.+2 n a (b) ^+) = Q k.+1 n a b	";
            responses[i]=data;
          

            i = 331;
            data = "1 subgoal (ID 1022)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  k : nat	  h : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : fib_seq_to_seq B (n; a) k),	      transport	        (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	        (colimp k k.+1 1 b) (Q k.+1 n a (b) ^+) = 	      Q k n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) k.+1),	  transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	    (colimp k.+1 k.+2 1 b) (Q k.+2 n a (b) ^+) = Q k.+1 n a b	1 subgoal (ID 1066)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  k : nat	  h : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : fib_seq_to_seq B (n; a) k),	      transport	        (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	        (colimp k k.+1 1 b) (Q k.+1 n a (b) ^+) = 	      Q k n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : fib_seq_to_seq B (n; a) k.+1	  ============================	  transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	    (colimp k.+1 k.+2 1 b) (Q k.+2 n a (b) ^+) =	  transport E	    (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a)	       (inj (fib_seq_to_seq B (n.+1; (a) ^+)) k b))	    (transport	       (fun x : fib_seq_to_type_fam B (inj A n.+1 (a) ^+) =>	        E (inj A n.+1 (a) ^+; x)) (colimp k k.+1 1 b)	       (Q k.+1 n.+1 (a) ^+ (b) ^+))	";
            responses[i]=data;
          

            i = 332;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 333;
            data = "";
            responses[i]=data;
          

            i = 334;
            data = "";
            responses[i]=data;
          

            i = 335;
            data = "";
            responses[i]=data;
          

            i = 336;
            data = "";
            responses[i]=data;
          

            i = 337;
            data = "";
            responses[i]=data;
          

            i = 338;
            data = "1 subgoal (ID 1028)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall x : fib_seq_to_type_fam B (inj A n a), E (inj A n a; x)	";
            responses[i]=data;
          

            i = 339;
            data = "";
            responses[i]=data;
          

            i = 340;
            data = "2 subgoals (ID 1046)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : fib_seq_to_seq B (n; a) i),	  (fun w : Colimit (fib_seq_to_seq B (n; a)) => E (inj A n a; w))	    (inj (fib_seq_to_seq B (n; a)) i x)		subgoal 2 (ID 1048) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : fib_seq_to_seq B (n; a) i),	 transport (fun w : Colimit (fib_seq_to_seq B (n; a)) => E (inj A n a; w))	   (colimp i j g x) (?q j (((fib_seq_to_seq B (n; a)) _f g) x)) = 	 ?q i x	";
            responses[i]=data;
          

            i = 341;
            data = "1 subgoal (ID 1046)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : fib_seq_to_seq B (n; a) i),	  (fun w : Colimit (fib_seq_to_seq B (n; a)) => E (inj A n a; w))	    (inj (fib_seq_to_seq B (n; a)) i x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 1048)		subgoal 1 (ID 1048) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : fib_seq_to_seq B (n; a) i),	 transport (fun w : Colimit (fib_seq_to_seq B (n; a)) => E (inj A n a; w))	   (colimp i j g x)	   ((fun k : Graph.graph0 sequence_graph => Q k n a) j	      (((fib_seq_to_seq B (n; a)) _f g) x)) =	 (fun k : Graph.graph0 sequence_graph => Q k n a) i x	";
            responses[i]=data;
          

            i = 342;
            data = "1 subgoal (ID 1048)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : fib_seq_to_seq B (n; a) i),	  transport (fun w : Colimit (fib_seq_to_seq B (n; a)) => E (inj A n a; w))	    (colimp i j g x)	    ((fun k : Graph.graph0 sequence_graph => Q k n a) j	       (((fib_seq_to_seq B (n; a)) _f g) x)) =	  (fun k : Graph.graph0 sequence_graph => Q k n a) i x	No more subgoals.	";
            responses[i]=data;
          

            i = 343;
            data = "";
            responses[i]=data;
          

            i = 344;
            data = "1 subgoal (ID 1047)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : fib_seq_to_seq B (n; a) 0	  ============================	  apD (F n a) (glue (fib_seq_to_seq B (n; a)) 0 b) = R 0 n a b	";
            responses[i]=data;
          

            i = 345;
            data = "";
            responses[i]=data;
          

            i = 346;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 347;
            data = "";
            responses[i]=data;
          

            i = 348;
            data = "1 subgoal (ID 1187)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x1, x2 : X	  y1, y2 : Y x1	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  q : y1 = y2	  psi : coe (ap Y p) = F	  G1 : forall y : Y x1, Z (x1; y)	  G2 : forall y : Y x2, Z (x2; y)	  r : F y1 = F y2	  theta : ap F q = r	  ============================	  forall (u1 : G2 (F y1) = transport Z (Delta p psi y1) (G1 y1))	  (u2 : G2 (F y2) = transport Z (Delta p psi y2) (G1 y2)),	  apD G2 r @ u2 =	  (ap (transport (fun x : Y x2 => Z (x2; x)) r) u1 @ Epsilon p theta (G1 y1)) @	  ap (transport Z (Delta p psi y2)) (apD G1 q) ->	  transport (fun y : Y x1 => G2 (F y) = transport Z (Delta p psi y) (G1 y)) q	    u1 = u2	";
            responses[i]=data;
          

            i = 349;
            data = "";
            responses[i]=data;
          

            i = 350;
            data = "1 subgoal (ID 1212)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x1, x2 : X	  y1 : Y x1	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  psi : coe (ap Y p) = F	  G1 : forall y : Y x1, Z (x1; y)	  G2 : forall y : Y x2, Z (x2; y)	  u1, u2 : G2 (F y1) = transport Z (Delta p psi y1) (G1 y1)	  ============================	  apD G2 (ap F 1) @ u2 = u1 ->	  transport (fun y : Y x1 => G2 (F y) = transport Z (Delta p psi y) (G1 y)) 1	    u1 = u2	";
            responses[i]=data;
          

            i = 351;
            data = "1 subgoal (ID 1220)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x1, x2 : X	  y1 : Y x1	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  psi : coe (ap Y p) = F	  G1 : forall y : Y x1, Z (x1; y)	  G2 : forall y : Y x2, Z (x2; y)	  u1, u2 : G2 (F y1) = transport Z (Delta p psi y1) (G1 y1)	  ============================	  1 @ u2 = u1 -> u1 = u2	";
            responses[i]=data;
          

            i = 352;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 353;
            data = "";
            responses[i]=data;
          

            i = 354;
            data = "";
            responses[i]=data;
          

            i = 355;
            data = "";
            responses[i]=data;
          

            i = 356;
            data = "";
            responses[i]=data;
          

            i = 357;
            data = "";
            responses[i]=data;
          

            i = 358;
            data = "1 subgoal (ID 1220)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall y : fib_seq_to_type_fam B (inj A n.+1 (a) ^+),	  F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) y) =	  transport E	    (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) y)	    (F n.+1 (a) ^+ y)	";
            responses[i]=data;
          

            i = 359;
            data = "";
            responses[i]=data;
          

            i = 360;
            data = "2 subgoals (ID 1238)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i : Graph.graph0 sequence_graph)	  (x : fib_seq_to_seq B (n.+1; (a) ^+) i),	  (fun w : Colimit (fib_seq_to_seq B (n.+1; (a) ^+)) =>	   F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	   transport E	     (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	     (F n.+1 (a) ^+ w)) (inj (fib_seq_to_seq B (n.+1; (a) ^+)) i x)		subgoal 2 (ID 1240) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j)	 (x : fib_seq_to_seq B (n.+1; (a) ^+) i),	 transport	   (fun w : Colimit (fib_seq_to_seq B (n.+1; (a) ^+)) =>	    F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	    transport E	      (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	      (F n.+1 (a) ^+ w)) (colimp i j g x)	   (?q j (((fib_seq_to_seq B (n.+1; (a) ^+)) _f g) x)) = 	 ?q i x	";
            responses[i]=data;
          

            i = 361;
            data = "1 subgoal (ID 1238)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i : Graph.graph0 sequence_graph)	  (x : fib_seq_to_seq B (n.+1; (a) ^+) i),	  (fun w : Colimit (fib_seq_to_seq B (n.+1; (a) ^+)) =>	   F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	   transport E	     (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	     (F n.+1 (a) ^+ w)) (inj (fib_seq_to_seq B (n.+1; (a) ^+)) i x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 1240)		subgoal 1 (ID 1240) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j)	 (x : fib_seq_to_seq B (n.+1; (a) ^+) i),	 transport	   (fun w : Colimit (fib_seq_to_seq B (n.+1; (a) ^+)) =>	    F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	    transport E	      (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	      (F n.+1 (a) ^+ w)) (colimp i j g x)	   ((fun (k : Graph.graph0 sequence_graph)	       (b : fib_seq_to_seq B (n.+1; (a) ^+) k) => 1) j	      (((fib_seq_to_seq B (n.+1; (a) ^+)) _f g) x)) =	 (fun (k : Graph.graph0 sequence_graph)	    (b : fib_seq_to_seq B (n.+1; (a) ^+) k) => 1) i x	";
            responses[i]=data;
          

            i = 362;
            data = "1 subgoal (ID 1240)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j)	  (x : fib_seq_to_seq B (n.+1; (a) ^+) i),	  transport	    (fun w : Colimit (fib_seq_to_seq B (n.+1; (a) ^+)) =>	     F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	     transport E	       (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	       (F n.+1 (a) ^+ w)) (colimp i j g x)	    ((fun (k : Graph.graph0 sequence_graph)	        (b : fib_seq_to_seq B (n.+1; (a) ^+) k) => 1) j	       (((fib_seq_to_seq B (n.+1; (a) ^+)) _f g) x)) =	  (fun (k : Graph.graph0 sequence_graph)	     (b : fib_seq_to_seq B (n.+1; (a) ^+) k) => 1) i x	1 subgoal (ID 1252)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  k : Graph.graph0 sequence_graph	  b : fib_seq_to_seq B (n.+1; (a) ^+) k	  ============================	  transport	    (fun w : Colimit (fib_seq_to_seq B (n.+1; (a) ^+)) =>	     F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	     transport E	       (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	       (F n.+1 (a) ^+ w)) (colimp k k.+1 1 b) 1 = 1	";
            responses[i]=data;
          

            i = 363;
            data = "1 subgoal (ID 1351)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  k : Graph.graph0 sequence_graph	  b : fib_seq_to_seq B (n.+1; (a) ^+) k	  ============================	  apD (F n a) (colimp k.+1 k.+2 1 b) @ 1 =	  (ap	     (transport	        (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	        (colimp k.+1 k.+2 1 b)) 1 @	   Epsilon (glue A n a)	     (colim_succ_seq_to_colim_seq_beta_glue (fib_seq_to_seq B (n; a)) k b)	     (F n.+1 (a) ^+ (inj (succ_seq (fib_seq_to_seq B (n; a))) k.+1 (b) ^+))) @	  ap	    (transport E	       (Delta (glue A n a) (fib_seq_to_type_fam_beta_glue B n a)	          (inj (succ_seq (fib_seq_to_seq B (n; a))) k b)))	    (apD (F n.+1 (a) ^+) (colimp k k.+1 1 b))	";
            responses[i]=data;
          

            i = 364;
            data = "";
            responses[i]=data;
          

            i = 365;
            data = "1 subgoal (ID 1365)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  k : Graph.graph0 sequence_graph	  b : fib_seq_to_seq B (n.+1; (a) ^+) k	  ============================	  R k.+1 n a b @ 1 =	  (ap	     (transport	        (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	        (colimp k.+1 k.+2 1 b)) 1 @	   Epsilon (colimp n n.+1 1 a)	     (colim_succ_seq_to_colim_seq_beta_glue (fib_seq_to_seq B (n; a)) k b)	     (F n.+1 (a) ^+ (inj (succ_seq (fib_seq_to_seq B (n; a))) k.+1 (b) ^+))) @	  ap	    (transport E	       (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a)	          (inj (succ_seq (fib_seq_to_seq B (n; a))) k b)))	    (apD (F n.+1 (a) ^+) (colimp k k.+1 1 b))	1 subgoal (ID 1400)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  k : Graph.graph0 sequence_graph	  b : fib_seq_to_seq B (n.+1; (a) ^+) k	  ============================	  R k.+1 n a b @ 1 =	  (ap	     (transport	        (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	        (colimp k.+1 k.+2 1 b)) 1 @	   Epsilon (colimp n n.+1 1 a)	     (colim_succ_seq_to_colim_seq_beta_glue (fib_seq_to_seq B (n; a)) k b)	     (F n.+1 (a) ^+ (inj (succ_seq (fib_seq_to_seq B (n; a))) k.+1 (b) ^+))) @	  ap	    (transport E	       (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a)	          (inj (succ_seq (fib_seq_to_seq B (n; a))) k b)))	    (R k n.+1 (a) ^+ b)	";
            responses[i]=data;
          

            i = 366;
            data = "";
            responses[i]=data;
          

            i = 367;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 368;
            data = "";
            responses[i]=data;
          

            i = 369;
            data = "";
            responses[i]=data;
          

            i = 370;
            data = "1 subgoal (ID 1281)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x2 : X & idmap (Y x2)} -> Type	  x1, x2 : X	  p : x1 = x2	  F : idmap (Y x1) -> idmap (Y x2)	  psi : coe (ap Y p) = F	  G1 : forall y : (fun x2 : X => idmap (Y x2)) x1, Z (x1; y)	  G2 : forall y : (fun x2 : X => idmap (Y x2)) x2, Z (x2; y)	  ============================	  transport	    (fun x : X => forall y : (fun x3 : X => idmap (Y x3)) x, Z (x; y)) p G1 =	  G2 <~> (forall y : Y x1, G2 (F y) = transport Z (Delta p psi y) (G1 y))	1 subgoal (ID 1298)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x2 : X & idmap (Y x2)} -> Type	  x1 : X	  G1 : forall y : (fun x2 : X => idmap (Y x2)) x1, Z (x1; y)	  G2 : forall y : Y x1, Z (x1; y)	  ============================	  transport (fun x : X => forall y : Y x, Z (x; y)) 1 G1 = G2 <~>	  (forall y : Y x1, G2 (coe (ap Y 1) y) = transport Z (Delta 1 1 y) (G1 y))	";
            responses[i]=data;
          

            i = 371;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 372;
            data = "";
            responses[i]=data;
          

            i = 373;
            data = "";
            responses[i]=data;
          

            i = 374;
            data = "";
            responses[i]=data;
          

            i = 375;
            data = "";
            responses[i]=data;
          

            i = 376;
            data = "";
            responses[i]=data;
          

            i = 377;
            data = "1 subgoal (ID 1289)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (x : Colimit A) (y : fib_seq_to_type_fam B x), E (x; y)	";
            responses[i]=data;
          

            i = 378;
            data = "";
            responses[i]=data;
          

            i = 379;
            data = "1 subgoal (ID 1307)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  transport	    (fun w : Colimit A => forall y : fib_seq_to_type_fam B w, E (w; y))	    (colimp n n.+1 1 a) (F n.+1 (a) ^+) = F n a	";
            responses[i]=data;
          

            i = 380;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 381;
            data = "";
            responses[i]=data;
          

            i = 382;
            data = "";
            responses[i]=data;
          

            i = 383;
            data = "";
            responses[i]=data;
          

            i = 384;
            data = "";
            responses[i]=data;
          

            i = 385;
            data = "";
            responses[i]=data;
          

            i = 386;
            data = "1 subgoal (ID 1316)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  I (fib_seq_to_type_fam_beta_glue B n a)	    (apD seq_colim_sum_ind_cur (glue A n a)) = G n a	";
            responses[i]=data;
          

            i = 387;
            data = "";
            responses[i]=data;
          

            i = 388;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 389;
            data = "";
            responses[i]=data;
          

            i = 390;
            data = "";
            responses[i]=data;
          

            i = 391;
            data = "";
            responses[i]=data;
          

            i = 392;
            data = "";
            responses[i]=data;
          

            i = 393;
            data = "";
            responses[i]=data;
          

            i = 394;
            data = "1 subgoal (ID 1318)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall x : {x : _ & fib_seq_to_type_fam B x}, E x	";
            responses[i]=data;
          

            i = 395;
            data = "";
            responses[i]=data;
          

            i = 396;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 397;
            data = "";
            responses[i]=data;
          

            i = 398;
            data = "1 subgoal (ID 1434)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  G : forall x0 : {x : _ & Y x}, Z x0	  x : X	  y1, y2 : Y x	  z : {x : _ & Y x}	  p : y1 = y2	  q1 : z = (x; y1)	  q2 : z = (x; y2)	  theta : q2 = q1 @ ap (exist Y x) p	  ============================	  apD (G o exist Y x) p =	  (ap (transport (Z o exist Y x) p) (apD G q1)^ @ Eta theta (G z)) @ apD G q2	";
            responses[i]=data;
          

            i = 399;
            data = "";
            responses[i]=data;
          

            i = 400;
            data = "1 subgoal (ID 1465)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  G : forall x0 : {x : _ & Y x}, Z x0	  x : X	  y1, y2 : Y x	  z : {x : _ & Y x}	  p : y1 = y2	  q1 : z = (x; y1)	  q2 : z = (x; y2)	  ============================	  forall x0 : q1 @ ap (exist Y x) p = q2,	  (fun y : q2 = q1 @ ap (exist Y x) p =>	   apD (G o exist Y x) p =	   (ap (transport (Z o exist Y x) p) (apD G q1)^ @ Eta y (G z)) @ apD G q2)	    (equiv_path_inverse (q1 @ ap (exist Y x) p) q2 x0)	";
            responses[i]=data;
          

            i = 401;
            data = "1 subgoal (ID 1470)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  G : forall x0 : {x : _ & Y x}, Z x0	  x : X	  y1, y2 : Y x	  z : {x : _ & Y x}	  p : y1 = y2	  q1 : z = (x; y1)	  ============================	  apD (fun x0 : Y x => G (x; x0)) p =	  (ap (transport (fun x0 : Y x => Z (x; x0)) p) (apD G q1)^ @	   Eta (equiv_path_inverse (q1 @ ap (exist Y x) p) (q1 @ ap (exist Y x) p) 1)	     (G z)) @ apD G (q1 @ ap (exist Y x) p)	";
            responses[i]=data;
          

            i = 402;
            data = "1 subgoal (ID 1506)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  G : forall x0 : {x : _ & Y x}, Z x0	  x : X	  y1, y2 : Y x	  p : y1 = y2	  ============================	  apD (fun x0 : Y x => G (x; x0)) p =	  (ap (transport (fun x0 : Y x => Z (x; x0)) p)	     (apD G (equiv_path_inverse (x; y1) (x; y1) 1))^ @	   Eta	     (equiv_path_inverse	        (equiv_path_inverse (x; y1) (x; y1) 1 @ ap (exist Y x) p)	        (equiv_path_inverse (x; y1) (x; y1) 1 @ ap (exist Y x) p) 1)	     (G (x; y1))) @	  apD G (equiv_path_inverse (x; y1) (x; y1) 1 @ ap (exist Y x) p)	";
            responses[i]=data;
          

            i = 403;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 404;
            data = "";
            responses[i]=data;
          

            i = 405;
            data = "1 subgoal (ID 1514)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x2 : X & idmap (Y x2)} -> Type	  x1, x2 : X	  p : x1 = x2	  F : idmap (Y x1) -> idmap (Y x2)	  G : forall z : {x2 : X & idmap (Y x2)}, Z z	  psi : coe (ap Y p) = F	  q : forall y : Y x1,	      (fun y0 : (fun x2 : X => idmap (Y x2)) x2 => G (x2; y0)) (F y) =	      transport Z (Delta p psi y)	        ((fun y0 : (fun x2 : X => idmap (Y x2)) x1 => G (x1; y0)) y)	  theta : I psi	            (apD	               (fun (x : X) (y : (fun x2 : X => idmap (Y x2)) x) => G (x; y))	               p) = q	  y : Y x1	  ============================	  apD G (Delta p psi y) = (q y)^	";
            responses[i]=data;
          

            i = 406;
            data = "";
            responses[i]=data;
          

            i = 407;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 408;
            data = "";
            responses[i]=data;
          

            i = 409;
            data = "";
            responses[i]=data;
          

            i = 410;
            data = "";
            responses[i]=data;
          

            i = 411;
            data = "";
            responses[i]=data;
          

            i = 412;
            data = "";
            responses[i]=data;
          

            i = 413;
            data = "1 subgoal (ID 1536)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n) 	  (b : B (n; a)),	  apD seq_colim_sum_ind	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  t n a b	";
            responses[i]=data;
          

            i = 414;
            data = "";
            responses[i]=data;
          

            i = 415;
            data = "1 subgoal (ID 1540)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  h := F_beta_glue n a b	   : apD (F n a) (glue (fib_seq_to_seq B (n; a)) 0 b) = R 0 n a b	  ============================	  apD seq_colim_sum_ind	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  t n a b	";
            responses[i]=data;
          

            i = 416;
            data = "1 subgoal (ID 1554)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  h : (ap	         (transport	            (fun x0 : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x0))	            (colimp 0 1 1 b))	         (apD seq_colim_sum_ind	            (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a)	               (inj (fib_seq_to_seq B (n.+1; (a) ^+)) 0 (b) ^+)))^ @	       Eta (seq_colim_sum_to_sum_seq_colim_beta_glue B n a b)	         (seq_colim_sum_ind	            (seq_colim_sum_to_sum_seq_colim B	               (inj (sig_seq B) n.+1 ((a; b)) ^+)))) @	      apD seq_colim_sum_ind	        (ap (seq_colim_sum_to_sum_seq_colim B) (colimp n n.+1 1 (a; b))) =	      R 0 n a b	  ============================	  apD seq_colim_sum_ind	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  t n a b	";
            responses[i]=data;
          

            i = 417;
            data = "";
            responses[i]=data;
          

            i = 418;
            data = "";
            responses[i]=data;
          

            i = 419;
            data = "";
            responses[i]=data;
          

            i = 420;
            data = "1 subgoal (ID 1581)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  h : (ap	         (transport	            (fun x0 : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x0))	            (colimp 0 1 1 b))	         ((G n a (inj (fib_seq_to_seq B (n.+1; (a) ^+)) 0 (b) ^+))^)^ @	       Eta (seq_colim_sum_to_sum_seq_colim_beta_glue B n a b)	         (seq_colim_sum_ind	            (seq_colim_sum_to_sum_seq_colim B	               (inj (sig_seq B) n.+1 ((a; b)) ^+)))) @	      apD seq_colim_sum_ind	        (ap (seq_colim_sum_to_sum_seq_colim B) (colimp n n.+1 1 (a; b))) =	      R 0 n a b	  ============================	  apD seq_colim_sum_ind	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  t n a b	No more subgoals.	";
            responses[i]=data;
          

            i = 421;
            data = "";
            responses[i]=data;
          

            i = 422;
            data = "";
            responses[i]=data;
          

            i = 423;
            data = "";
            responses[i]=data;
          

            i = 424;
            data = "";
            responses[i]=data;
          

            i = 425;
            data = "";
            responses[i]=data;
          

            i = 426;
            data = "";
            responses[i]=data;
          

            i = 427;
            data = "";
            responses[i]=data;
          

            i = 428;
            data = "";
            responses[i]=data;
          

            i = 429;
            data = "";
            responses[i]=data;
          

            i = 430;
            data = "<infomsg>H is declared</infomsg>	<infomsg>A is declared</infomsg>	<infomsg>B is declared</infomsg>	<infomsg>E is declared</infomsg>	<infomsg>e is declared</infomsg>	<infomsg>t is declared</infomsg>	1 subgoal (ID 757)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n), B (n; a) -> E	  t : forall (n : Graph.graph0 sequence_graph) (a : A n) 	      (b : B (n; a)), e n.+1 (a) ^+ (b) ^+f = e n a b	  ============================	  {x : _ & fib_seq_to_type_fam B x} -> E	";
            responses[i]=data;
          

            i = 431;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 432;
            data = "";
            responses[i]=data;
          

            i = 433;
            data = "1 subgoal (ID 782)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n), B (n; a) -> E	  t : forall (n : Graph.graph0 sequence_graph) (a : A n) 	      (b : B (n; a)), e n.+1 (a) ^+ (b) ^+f = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : (fun a0 : A n => B (n; a0)) a),	  ap seq_colim_sum_rec	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  t n a b	";
            responses[i]=data;
          

            i = 434;
            data = "";
            responses[i]=data;
          

            i = 435;
            data = "1 subgoal (ID 812)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n), B (n; a) -> E	  t : forall (n : Graph.graph0 sequence_graph) (a : A n) 	      (b : B (n; a)), e n.+1 (a) ^+ (b) ^+f = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : (fun a : A n => B (n; a)) a	  ============================	  apD seq_colim_sum_rec	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  transport_const	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	    (seq_colim_sum_rec	       (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n.+1 ((a; b)) ^+))) @	  t n a b	";
            responses[i]=data;
          

            i = 436;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 437;
            data = "";
            responses[i]=data;
          

            i = 438;
            data = "";
            responses[i]=data;
          

            i = 439;
            data = "";
            responses[i]=data;
          

            i = 440;
            data = "";
            responses[i]=data;
          

            i = 441;
            data = "";
            responses[i]=data;
          

            i = 442;
            data = "";
            responses[i]=data;
          

            i = 443;
            data = "1 subgoal (ID 763)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : Type	  F, G : {x : _ & fib_seq_to_type_fam B x} -> E	  ============================	  F o seq_colim_sum_to_sum_seq_colim B ==	  G o seq_colim_sum_to_sum_seq_colim B -> F == G	";
            responses[i]=data;
          

            i = 444;
            data = "";
            responses[i]=data;
          

            i = 445;
            data = "1 subgoal (ID 787)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : Type	  F, G : {x : _ & fib_seq_to_type_fam B x} -> E	  h : F o seq_colim_sum_to_sum_seq_colim B ==	      G o seq_colim_sum_to_sum_seq_colim B	  n : Graph.graph0 sequence_graph	  a : A n	  b : (fun a : A n => B (n; a)) a	  ============================	  transport (fun x : {x : _ & fib_seq_to_type_fam B x} => F x = G x)	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	    ((fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0)	        (b0 : (fun a1 : A n0 => B (n0; a1)) a0) =>	      h (inj (sig_seq B) n0 (a0; b0))) n.+1 (a) ^+ 	       (b) ^+f) =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0)	     (b0 : (fun a1 : A n0 => B (n0; a1)) a0) =>	   h (inj (sig_seq B) n0 (a0; b0))) n a b	";
            responses[i]=data;
          

            i = 446;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 447;
            data = "";
            responses[i]=data;
          

            i = 448;
            data = "";
            responses[i]=data;
          

            i = 449;
            data = "";
            responses[i]=data;
          

            i = 450;
            data = "";
            responses[i]=data;
          

            i = 451;
            data = "";
            responses[i]=data;
          

            i = 452;
            data = "1 subgoal (ID 772)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 453;
            data = "";
            responses[i]=data;
          

            i = 454;
            data = "2 subgoals (ID 780)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  {G0 : {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B) &	  Sect (seq_colim_sum_to_sum_seq_colim B) G0}		subgoal 2 (ID 782) is:	 IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 455;
            data = "1 subgoal (ID 780)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  {G0 : {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B) &	  Sect (seq_colim_sum_to_sum_seq_colim B) G0}	2 subgoals (ID 787)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B)		subgoal 2 (ID 789) is:	 (fun G0 : {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B) =>	  Sect (seq_colim_sum_to_sum_seq_colim B) G0) ?proj1_sig	";
            responses[i]=data;
          

            i = 456;
            data = "1 subgoal (ID 787)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B)	2 subgoals (ID 817)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n),	  B (n; a) -> Colimit (sig_seq B)		subgoal 2 (ID 819) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n) 	 (b : B (n; a)), ?e n.+1 (a) ^+ (b) ^+f = ?e n a b	";
            responses[i]=data;
          

            i = 457;
            data = "1 subgoal (ID 817)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n),	  B (n; a) -> Colimit (sig_seq B)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 subgoals (ID 819)		subgoal 1 (ID 819) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n) 	 (b : B (n; a)),	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b0 : B (n0; a0)) =>	  inj (sig_seq B) n0 (a0; b0)) n.+1 (a) ^+ (b) ^+f =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b0 : B (n0; a0)) =>	  inj (sig_seq B) n0 (a0; b0)) n a b	subgoal 2 (ID 789) is:	 (fun G0 : {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B) =>	  Sect (seq_colim_sum_to_sum_seq_colim B) G0)	   (seq_colim_sum_rec B (Colimit (sig_seq B))	      (fun (n : Graph.graph0 sequence_graph) (a : A n) (b : B (n; a)) =>	       inj (sig_seq B) n (a; b)) ?t)	subgoal 3 (ID 782) is:	 IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 458;
            data = "1 subgoal (ID 819)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n) 	  (b : B (n; a)),	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b0 : B (n0; a0)) =>	   inj (sig_seq B) n0 (a0; b0)) n.+1 (a) ^+ (b) ^+f =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b0 : B (n0; a0)) =>	   inj (sig_seq B) n0 (a0; b0)) n a b	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 789)		subgoal 1 (ID 789) is:	 (fun G0 : {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B) =>	  Sect (seq_colim_sum_to_sum_seq_colim B) G0)	   (seq_colim_sum_rec B (Colimit (sig_seq B))	      (fun (n : Graph.graph0 sequence_graph) (a : A n) (b : B (n; a)) =>	       inj (sig_seq B) n (a; b))	      (fun (n : Graph.graph0 sequence_graph) (a : A n) (b : B (n; a)) =>	       glue (sig_seq B) n (a; b)))	subgoal 2 (ID 782) is:	 IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 459;
            data = "1 subgoal (ID 789)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  (fun G0 : {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B) =>	   Sect (seq_colim_sum_to_sum_seq_colim B) G0)	    (seq_colim_sum_rec B (Colimit (sig_seq B))	       (fun (n : Graph.graph0 sequence_graph) (a : A n) (b : B (n; a)) =>	        inj (sig_seq B) n (a; b))	       (fun (n : Graph.graph0 sequence_graph) (a : A n) (b : B (n; a)) =>	        glue (sig_seq B) n (a; b)))	2 subgoals (ID 870)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (sig_seq B) =>	   seq_colim_sum_rec B (Colimit (sig_seq B))	     (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) (b : B (n0; a)) =>	      inj (sig_seq B) n0 (a; b))	     (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) (b : B (n0; a)) =>	      glue (sig_seq B) n0 (a; b)) (seq_colim_sum_to_sum_seq_colim B x))	  o inj (sig_seq B) n == idmap o inj (sig_seq B) n		subgoal 2 (ID 872) is:	 forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	 ap	   (fun x : Colimit (sig_seq B) =>	    seq_colim_sum_rec B (Colimit (sig_seq B))	      (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0)) =>	       inj (sig_seq B) n0 (a0; b))	      (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0)) =>	       glue (sig_seq B) n0 (a0; b)) (seq_colim_sum_to_sum_seq_colim B x))	   (glue (sig_seq B) n a) @ ?h n a =	 ?h n.+1 (a) ^+ @ ap idmap (glue (sig_seq B) n a)	";
            responses[i]=data;
          

            i = 460;
            data = "1 subgoal (ID 870)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (sig_seq B) =>	   seq_colim_sum_rec B (Colimit (sig_seq B))	     (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) (b : B (n0; a)) =>	      inj (sig_seq B) n0 (a; b))	     (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) (b : B (n0; a)) =>	      glue (sig_seq B) n0 (a; b)) (seq_colim_sum_to_sum_seq_colim B x))	  o inj (sig_seq B) n == idmap o inj (sig_seq B) n	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 subgoals (ID 872)		subgoal 1 (ID 872) is:	 forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	 ap	   (fun x : Colimit (sig_seq B) =>	    seq_colim_sum_rec B (Colimit (sig_seq B))	      (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0)) =>	       inj (sig_seq B) n0 (a0; b))	      (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0)) =>	       glue (sig_seq B) n0 (a0; b)) (seq_colim_sum_to_sum_seq_colim B x))	   (glue (sig_seq B) n a) @	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n a =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n.+1	   (a) ^+ @ ap idmap (glue (sig_seq B) n a)	subgoal 2 (ID 782) is:	 IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 461;
            data = "1 subgoal (ID 872)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	  ap	    (fun x : Colimit (sig_seq B) =>	     seq_colim_sum_rec B (Colimit (sig_seq B))	       (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0))	        => inj (sig_seq B) n0 (a0; b))	       (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0))	        => glue (sig_seq B) n0 (a0; b)) (seq_colim_sum_to_sum_seq_colim B x))	    (glue (sig_seq B) n a) @	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n a =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n.+1	    (a) ^+ @ ap idmap (glue (sig_seq B) n a)	1 subgoal (ID 903)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : sig_seq B n	  ============================	  ap	    (seq_colim_sum_rec B (Colimit (sig_seq B))	       (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0))	        => inj (sig_seq B) n0 (a0; b))	       (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0))	        => colimp n0 n0.+1 1 (a0; b)))	    (ap (seq_colim_sum_to_sum_seq_colim B) (colimp n n.+1 1 a)) =	  colimp n n.+1 1 a	";
            responses[i]=data;
          

            i = 462;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 782)		subgoal 1 (ID 782) is:	 IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 463;
            data = "1 subgoal (ID 782)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  L : {G : {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B) &	      Sect (seq_colim_sum_to_sum_seq_colim B) G}	  ============================	  IsEquiv (seq_colim_sum_to_sum_seq_colim B)	1 subgoal (ID 963)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  L : {G : {x : _ & fib_seq_to_type_fam B x} -> Colimit (sig_seq B) &	      Sect (seq_colim_sum_to_sum_seq_colim B) G}	  ============================	  (fun x : {x : _ & fib_seq_to_type_fam B x} =>	   seq_colim_sum_to_sum_seq_colim B (L.1 x))	  o seq_colim_sum_to_sum_seq_colim B ==	  idmap o seq_colim_sum_to_sum_seq_colim B	";
            responses[i]=data;
          

            i = 464;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 465;
            data = "";
            responses[i]=data;
          

            i = 466;
            data = "<infomsg>equiv_seq_colim_sum_to_sum_seq_colim is defined</infomsg>	";
            responses[i]=data;
          

            i = 467;
            data = "";
            responses[i]=data;
          

            i = 468;
            data = "";
            responses[i]=data;
          

            i = 469;
            data = "";
            responses[i]=data;
          

            i = 470;
            data = "";
            responses[i]=data;
          

            i = 471;
            data = "1 subgoal (ID 808)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  pr1 o seq_colim_sum_to_sum_seq_colim B == seq_colim_sum_to_seq_colim_fst B	";
            responses[i]=data;
          

            i = 472;
            data = "";
            responses[i]=data;
          

            i = 473;
            data = "2 subgoals (ID 842)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (sig_seq B) => (seq_colim_sum_to_sum_seq_colim B x).1)	  o inj (sig_seq B) n == seq_colim_sum_to_seq_colim_fst B o inj (sig_seq B) n		subgoal 2 (ID 844) is:	 forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	 ap (fun x : Colimit (sig_seq B) => (seq_colim_sum_to_sum_seq_colim B x).1)	   (glue (sig_seq B) n a) @ ?h n a =	 ?h n.+1 (a) ^+ @	 ap (seq_colim_sum_to_seq_colim_fst B) (glue (sig_seq B) n a)	";
            responses[i]=data;
          

            i = 474;
            data = "1 subgoal (ID 842)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (sig_seq B) => (seq_colim_sum_to_sum_seq_colim B x).1)	  o inj (sig_seq B) n == seq_colim_sum_to_seq_colim_fst B o inj (sig_seq B) n	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 844)		subgoal 1 (ID 844) is:	 forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	 ap (fun x : Colimit (sig_seq B) => (seq_colim_sum_to_sum_seq_colim B x).1)	   (glue (sig_seq B) n a) @	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n a =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n.+1	   (a) ^+ @ ap (seq_colim_sum_to_seq_colim_fst B) (glue (sig_seq B) n a)	";
            responses[i]=data;
          

            i = 475;
            data = "1 subgoal (ID 844)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	  ap (fun x : Colimit (sig_seq B) => (seq_colim_sum_to_sum_seq_colim B x).1)	    (glue (sig_seq B) n a) @	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n a =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n.+1	    (a) ^+ @ ap (seq_colim_sum_to_seq_colim_fst B) (glue (sig_seq B) n a)	1 subgoal (ID 881)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  ============================	  ap pr1	    (legs_comm	       {|	       legs := fun (n0 : Graph.graph0 sequence_graph) (X : sig_seq B n0) =>	               (inj A n0 X.1; inj (fib_seq_to_seq B (n0; X.1)) 0 X.2);	       legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                      (p : Graph.graph1 sequence_graph n0 m)	                      (x : sig_seq B n0) =>	                    match	                      p as p0 in (_ = y)	                      return	                        ((inj A y (((sig_seq B) _f p0) (x.1; x.2)).1;	                         inj	                           (fib_seq_to_seq B	                              (y; (((sig_seq B) _f p0) (x.1; x.2)).1)) 0	                           (((sig_seq B) _f p0) (x.1; x.2)).2) =	                         (inj A n0 x.1;	                         inj (fib_seq_to_seq B (n0; x.1)) 0 x.2))	                    with	                    | 1 =>	                        Delta (colimp n0 n0.+1 1 x.1)	                          (fib_seq_to_type_fam_beta_glue B n0 x.1)	                          (inj (fib_seq_to_seq B (n0.+1; ((x.1; x.2)) ^+.1))	                             0 ((x.1; x.2)) ^+.2) @	                        ap (exist (fib_seq_to_type_fam B) (inj A n0 x.1))	                          (colimp 0 1 1 x.2)	                    end |} n n.+1 1 (a; b)) =	  legs_comm	    {|	    legs := fun (n0 : Graph.graph0 sequence_graph) (X : sig_seq B n0) =>	            inj A n0 X.1;	    legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                   (p : Graph.graph1 sequence_graph n0 m) 	                   (x : sig_seq B n0) =>	                 match	                   p as p0 in (_ = y)	                   return	                     (inj A y (((sig_seq B) _f p0) (x.1; x.2)).1 =	                      inj A n0 x.1)	                 with	                 | 1 => colimp n0 n0.+1 1 x.1	                 end |} n n.+1 1 (a; b)	";
            responses[i]=data;
          

            i = 476;
            data = "1 subgoal (ID 900)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  ============================	  colimp n n.+1 1 a @	  ap pr1 (ap (exist (fib_seq_to_type_fam B) (inj A n a)) (colimp 0 1 1 b)) =	  legs_comm	    {|	    legs := fun (n0 : Graph.graph0 sequence_graph) (X : sig_seq B n0) =>	            inj A n0 X.1;	    legs_comm := fun (n0 m : Graph.graph0 sequence_graph)	                   (p : Graph.graph1 sequence_graph n0 m) 	                   (x : sig_seq B n0) =>	                 match	                   p as p0 in (_ = y)	                   return	                     (inj A y (((sig_seq B) _f p0) (x.1; x.2)).1 =	                      inj A n0 x.1)	                 with	                 | 1 => colimp n0 n0.+1 1 x.1	                 end |} n n.+1 1 (a; b)	";
            responses[i]=data;
          

            i = 477;
            data = "1 subgoal (ID 960)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  ============================	  ap (fun _ : Colimit (fib_seq_to_seq B (n; a)) => inj A n a)	    (colimp 0 1 1 b) = 1	";
            responses[i]=data;
          

            i = 478;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 479;
            data = "";
            responses[i]=data;
          

            i = 480;
            data = "";
            responses[i]=data;
          

            i = 481;
            data = "";
            responses[i]=data;
          

            i = 482;
            data = "";
            responses[i]=data;
          

            i = 483;
            data = "";
            responses[i]=data;
          

            i = 484;
            data = "<infomsg>path_seq is defined</infomsg>	";
            responses[i]=data;
          

            i = 485;
            data = "1 subgoal (ID 838)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  ============================	  inj A 0 a1 = inj A 0 a2 <~> Colimit (path_seq A a1 a2)	";
            responses[i]=data;
          

            i = 486;
            data = "";
            responses[i]=data;
          

            i = 487;
            data = "1 subgoal (ID 863)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	       fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	       fibSequenceArr := fun x : {x : _ & A x} =>	                         ap (fun a : A x.1 => (a) ^+) |} : 	  FibSequence A	  ============================	  inj A 0 a1 = inj A 0 a2 <~> Colimit (path_seq A a1 a2)	";
            responses[i]=data;
          

            i = 488;
            data = "2 subgoals (ID 877)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	       fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	       fibSequenceArr := fun x : {x : _ & A x} =>	                         ap (fun a : A x.1 => (a) ^+) |} : 	  FibSequence A	  ============================	  inj A 0 a1 = inj A 0 a2 <~> fib_seq_to_type_fam B (inj A 0 a2)		subgoal 2 (ID 879) is:	 fib_seq_to_type_fam B (inj A 0 a2) <~> Colimit (path_seq A a1 a2)	";
            responses[i]=data;
          

            i = 489;
            data = "1 subgoal (ID 877)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	       fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	       fibSequenceArr := fun x : {x : _ & A x} =>	                         ap (fun a : A x.1 => (a) ^+) |} : 	  FibSequence A	  ============================	  inj A 0 a1 = inj A 0 a2 <~> fib_seq_to_type_fam B (inj A 0 a2)	2 subgoals (ID 940)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	       fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	       fibSequenceArr := fun x : {x : _ & A x} =>	                         ap (fun a : A x.1 => (a) ^+) |} : 	  FibSequence A	  ============================	  fib_seq_to_type_fam B (inj A 0 a1)		subgoal 2 (ID 942) is:	 Contr {y : Colimit A & fib_seq_to_type_fam B y}	";
            responses[i]=data;
          

            i = 490;
            data = "1 subgoal (ID 940)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	       fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	       fibSequenceArr := fun x : {x : _ & A x} =>	                         ap (fun a : A x.1 => (a) ^+) |} : 	  FibSequence A	  ============================	  fib_seq_to_type_fam B (inj A 0 a1)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 subgoals (ID 942)		subgoal 1 (ID 942) is:	 Contr {y : Colimit A & fib_seq_to_type_fam B y}	subgoal 2 (ID 879) is:	 fib_seq_to_type_fam B (inj A 0 a2) <~> Colimit (path_seq A a1 a2)	";
            responses[i]=data;
          

            i = 491;
            data = "1 subgoal (ID 942)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	       fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	       fibSequenceArr := fun x : {x : _ & A x} =>	                         ap (fun a : A x.1 => (a) ^+) |} : 	  FibSequence A	  ============================	  Contr {y : Colimit A & fib_seq_to_type_fam B y}	1 subgoal (ID 977)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	       fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	       fibSequenceArr := fun x : {x : _ & A x} =>	                         ap (fun a : A x.1 => (a) ^+) |} : 	  FibSequence A	  ============================	  Contr (Colimit (sig_seq B))	";
            responses[i]=data;
          

            i = 492;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 879)		subgoal 1 (ID 879) is:	 fib_seq_to_type_fam B (inj A 0 a2) <~> Colimit (path_seq A a1 a2)	";
            responses[i]=data;
          

            i = 493;
            data = "1 subgoal (ID 879)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	       fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	       fibSequenceArr := fun x : {x : _ & A x} =>	                         ap (fun a : A x.1 => (a) ^+) |} : 	  FibSequence A	  ============================	  fib_seq_to_type_fam B (inj A 0 a2) <~> Colimit (path_seq A a1 a2)	1 subgoal (ID 1145)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	       fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	       fibSequenceArr := fun x : {x : _ & A x} =>	                         ap (fun a : A x.1 => (a) ^+) |} : 	  FibSequence A	  ============================	  fib_seq_to_seq' B (0; a2) ~d~ path_seq A a1 a2	";
            responses[i]=data;
          

            i = 494;
            data = "2 subgoals (ID 1170)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	       fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	       fibSequenceArr := fun x : {x : _ & A x} =>	                         ap (fun a : A x.1 => (a) ^+) |} : 	  FibSequence A	  ============================	  DiagramMap (fib_seq_to_seq' B (0; a2)) (path_seq A a1 a2)		subgoal 2 (ID 1172) is:	 forall i : Graph.graph0 sequence_graph, IsEquiv (?m i)	";
            responses[i]=data;
          

            i = 495;
            data = "1 subgoal (ID 1170)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	       fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	       fibSequenceArr := fun x : {x : _ & A x} =>	                         ap (fun a : A x.1 => (a) ^+) |} : 	  FibSequence A	  ============================	  DiagramMap (fib_seq_to_seq' B (0; a2)) (path_seq A a1 a2)	2 subgoals (ID 1262)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	       fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	       fibSequenceArr := fun x : {x : _ & A x} =>	                         ap (fun a : A x.1 => (a) ^+) |} : 	  FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph,	  fib_seq_to_seq' B (0; a2) i -> path_seq A a1 a2 i		subgoal 2 (ID 1264) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : fib_seq_to_seq' B (0; a2) i),	 ((path_seq A a1 a2) _f g) (?DiagramMap_obj i x) =	 ?DiagramMap_obj j (((fib_seq_to_seq' B (0; a2)) _f g) x)	";
            responses[i]=data;
          

            i = 496;
            data = "1 subgoal (ID 1262)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	       fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	       fibSequenceArr := fun x : {x : _ & A x} =>	                         ap (fun a : A x.1 => (a) ^+) |} : 	  FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph,	  fib_seq_to_seq' B (0; a2) i -> path_seq A a1 a2 i	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 subgoals (ID 1264)		subgoal 1 (ID 1264) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : fib_seq_to_seq' B (0; a2) i),	 ((path_seq A a1 a2) _f g)	   ((fun n : Graph.graph0 sequence_graph =>	     coe (ap B (seq_shift_pair_from_zero a2 n))) i x) =	 (fun n : Graph.graph0 sequence_graph =>	  coe (ap B (seq_shift_pair_from_zero a2 n))) j	   (((fib_seq_to_seq' B (0; a2)) _f g) x)	subgoal 2 (ID 1172) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	    DiagramMap_obj := fun n : Graph.graph0 sequence_graph =>	                      coe (ap B (seq_shift_pair_from_zero a2 n));	    DiagramMap_comm := ?DiagramMap_comm |} i)	";
            responses[i]=data;
          

            i = 497;
            data = "1 subgoal (ID 1264)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	       fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	       fibSequenceArr := fun x : {x : _ & A x} =>	                         ap (fun a : A x.1 => (a) ^+) |} : 	  FibSequence A	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : fib_seq_to_seq' B (0; a2) i),	  ((path_seq A a1 a2) _f g)	    ((fun n : Graph.graph0 sequence_graph =>	      coe (ap B (seq_shift_pair_from_zero a2 n))) i x) =	  (fun n : Graph.graph0 sequence_graph =>	   coe (ap B (seq_shift_pair_from_zero a2 n))) j	    (((fib_seq_to_seq' B (0; a2)) _f g) x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 subgoal (ID 1172)		subgoal 1 (ID 1172) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	    DiagramMap_obj := fun n : Graph.graph0 sequence_graph =>	                      coe (ap B (seq_shift_pair_from_zero a2 n));	    DiagramMap_comm := fun (n m : Graph.graph0 sequence_graph)	                         (p : Graph.graph1 sequence_graph n m)	                         (b : fib_seq_to_seq' B (0; a2) n) =>	                       match	                         p as p0 in (_ = y)	                         return	                           (((path_seq A a1 a2) _f p0)	                              (coe (ap B (seq_shift_pair_from_zero a2 n)) b) =	                            coe (ap B (seq_shift_pair_from_zero a2 y))	                              (((fib_seq_to_seq' B (0; a2)) _f p0) b))	                       with	                       | 1 =>	                           K seq_pair_shift (fibSequenceArr B)	                             (seq_shift_pair_from_zero a2 n)	                       end |} i)	";
            responses[i]=data;
          

            i = 498;
            data = "1 subgoal (ID 1172)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	       fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	       fibSequenceArr := fun x : {x : _ & A x} =>	                         ap (fun a : A x.1 => (a) ^+) |} : 	  FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph,	  IsEquiv	    ({|	     DiagramMap_obj := fun n : Graph.graph0 sequence_graph =>	                       coe (ap B (seq_shift_pair_from_zero a2 n));	     DiagramMap_comm := fun (n m : Graph.graph0 sequence_graph)	                          (p : Graph.graph1 sequence_graph n m)	                          (b : fib_seq_to_seq' B (0; a2) n) =>	                        match	                          p as p0 in (_ = y)	                          return	                            (((path_seq A a1 a2) _f p0)	                               (coe (ap B (seq_shift_pair_from_zero a2 n)) b) =	                             coe (ap B (seq_shift_pair_from_zero a2 y))	                               (((fib_seq_to_seq' B (0; a2)) _f p0) b))	                        with	                        | 1 =>	                            K seq_pair_shift (fibSequenceArr B)	                              (seq_shift_pair_from_zero a2 n)	                        end |} i)	No more subgoals.	";
            responses[i]=data;
          

            i = 499;
            data = "";
            responses[i]=data;
          

            i = 500;
            data = "";
            responses[i]=data;
          

            i = 501;
            data = "";
            responses[i]=data;
          

            i = 502;
            data = "";
            responses[i]=data;
          

            i = 503;
            data = "";
            responses[i]=data;
          

            i = 504;
            data = "1 subgoal (ID 848)	  	  H : Univalence	  A : Sequence	  n : Graph.graph0 sequence_graph	  a1, a2 : A n	  ============================	  inj A n a1 = inj A n a2 <~> Colimit (path_seq (shift_seq A n) a1 a2)	";
            responses[i]=data;
          

            i = 505;
            data = "";
            responses[i]=data;
          

            i = 506;
            data = "1 subgoal (ID 870)	  	  H : Univalence	  A : Sequence	  n : Graph.graph0 sequence_graph	  a1, a2 : A n	  ============================	  inj (shift_seq A n) 0 a1 = inj (shift_seq A n) 0 a2 <~>	  inj A n a1 = inj A n a2	";
            responses[i]=data;
          

            i = 507;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 508;
            data = "";
            responses[i]=data;
          

            i = 509;
            data = "";
            responses[i]=data;
          

            i = 510;
            data = "";
            responses[i]=data;
          

            i = 511;
            data = "";
            responses[i]=data;
          

            i = 512;
            data = "";
            responses[i]=data;
          

            i = 513;
            data = "";
            responses[i]=data;
          

            i = 514;
            data = "1 subgoal (ID 855)	  	  H : Univalence	  A : Sequence	  k : trunc_index	  ============================	  (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	  IsTrunc k (Colimit A)	";
            responses[i]=data;
          

            i = 515;
            data = "";
            responses[i]=data;
          

            i = 516;
            data = "2 subgoals (ID 861)	  	  H : Univalence	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, Contr (A n)) -> Contr (Colimit A)		subgoal 2 (ID 864) is:	 forall A : Sequence,	 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	 IsTrunc k.+1 (Colimit A)	";
            responses[i]=data;
          

            i = 517;
            data = "1 subgoal (ID 861)	  	  H : Univalence	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, Contr (A n)) -> Contr (Colimit A)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 864)		subgoal 1 (ID 864) is:	 forall A : Sequence,	 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	 IsTrunc k.+1 (Colimit A)	";
            responses[i]=data;
          

            i = 518;
            data = "1 subgoal (ID 864)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  IsTrunc k.+1 (Colimit A)	2 subgoals (ID 896)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : A i),	  (fun w : Colimit A =>	   forall y : Colimit A,	   (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	      match n with	      | -2 => Contr_internal A0	      | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	      end) k (w = y)) (inj A i x)		subgoal 2 (ID 898) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x) (?q j ((A _f g) x)) = 	 ?q i x	";
            responses[i]=data;
          

            i = 519;
            data = "1 subgoal (ID 896)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : A i),	  (fun w : Colimit A =>	   forall y : Colimit A,	   (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	      match n with	      | -2 => Contr_internal A0	      | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	      end) k (w = y)) (inj A i x)	2 subgoals (ID 907)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall (x : A 0%nat) (y : Colimit A),	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	     end) k (inj A 0%nat x = y)		subgoal 2 (ID 910) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	";
            responses[i]=data;
          

            i = 520;
            data = "1 subgoal (ID 907)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall (x : A 0%nat) (y : Colimit A),	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	     end) k (inj A 0%nat x = y)	2 subgoals (ID 931)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : A i),	  (fun w : Colimit A =>	   (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	      match n with	      | -2 => Contr_internal A0	      | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	      end) k (inj A 0%nat a = w)) (inj A i x)		subgoal 2 (ID 933) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	       end) k (inj A 0%nat a = w)) (colimp i j g x) 	   (?q j ((A _f g) x)) = ?q i x	";
            responses[i]=data;
          

            i = 521;
            data = "1 subgoal (ID 931)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : A i),	  (fun w : Colimit A =>	   (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	      match n with	      | -2 => Contr_internal A0	      | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	      end) k (inj A 0%nat a = w)) (inj A i x)	2 subgoals (ID 947)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall a b : A 0%nat,	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A 0%nat b)		subgoal 2 (ID 950) is:	 forall A : Sequence,	 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	 forall (a : A 0%nat) (b : A (m.+1)%nat),	 (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	    match n with	    | -2 => Contr_internal A0	    | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	    end) k (inj A 0%nat a = inj A (m.+1)%nat b)	";
            responses[i]=data;
          

            i = 522;
            data = "1 subgoal (ID 947)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall a b : A 0%nat,	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A 0%nat b)	1 subgoal (ID 954)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a, b : A 0%nat	  ============================	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A 0%nat b)	";
            responses[i]=data;
          

            i = 523;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	4 subgoals (ID 950)		subgoal 1 (ID 950) is:	 forall A : Sequence,	 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	 forall (a : A 0%nat) (b : A (m.+1)%nat),	 (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	    match n with	    | -2 => Contr_internal A0	    | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	    end) k (inj A 0%nat a = inj A (m.+1)%nat b)	subgoal 2 (ID 933) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	       end) k (inj A 0%nat a = w)) (colimp i j g x)	   ((fun (m : Graph.graph0 sequence_graph) (b : A m) =>	     nat_rect	       (fun m0 : nat =>	        forall A0 : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	        forall (a0 : A0 0%nat) (b0 : A0 m0),	        (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a0 = inj A0 m0 b0))	       (fun (A0 : Sequence)	          (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	          (a0 b0 : A0 0%nat) =>	        trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	          (equiv_path_colim 0%nat a0 b0)^-1)	       (fun (m0 : nat)	          (IHm : forall A0 : Sequence,	                 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	                 forall (a0 : A0 0%nat) (b0 : A0 m0),	                 (fix IsTrunc_internal	                    (n : trunc_index) (A1 : Type) {struct n} : Type :=	                    match n with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a0 = inj A0 m0 b0)) =>	        ?Goal0@{m:=m0}) m A trH a b) j ((A _f g) x)) =	 (fun (m : Graph.graph0 sequence_graph) (b : A m) =>	  nat_rect	    (fun m0 : nat =>	     forall A0 : Sequence,	     (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	     forall (a0 : A0 0%nat) (b0 : A0 m0),	     (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A1	        | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	        end) k (inj A0 0%nat a0 = inj A0 m0 b0))	    (fun (A0 : Sequence)	       (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	       (a0 b0 : A0 0%nat) =>	     trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	       (equiv_path_colim 0%nat a0 b0)^-1)	    (fun (m0 : nat)	       (IHm : forall A0 : Sequence,	              (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	              forall (a0 : A0 0%nat) (b0 : A0 m0),	              (fix IsTrunc_internal	                 (n : trunc_index) (A1 : Type) {struct n} : Type :=	                 match n with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a0 = inj A0 m0 b0)) => 	     ?Goal0@{m:=m0}) m A trH a b) i x	subgoal 3 (ID 910) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	subgoal 4 (ID 898) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0)) =>	              ?Goal0@{m:=m0}) m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) => 	        ?Goal@{n:=n0}) n A trH) j ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0)) =>	           ?Goal0@{m:=m0}) m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) => ?Goal@{n:=n0}) n A trH) i x	";
            responses[i]=data;
          

            i = 524;
            data = "1 subgoal (ID 950)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  m : nat	  IHm : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (a : A 0%nat) (b : A m),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	           end) k (inj A 0%nat a = inj A m b)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall (a : A 0%nat) (b : A (m.+1)%nat),	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A (m.+1)%nat b)	1 subgoal (ID 950)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  m : nat	  IHm : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (a : A 0%nat) (b : A m),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	           end) k (inj A 0%nat a = inj A m b)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall (a : A 0%nat) (b : A (m.+1)%nat),	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A (m.+1)%nat b)	1 subgoal (ID 981)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  m : nat	  IHm : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (a : A 0%nat) (b : A m),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	           end) k (inj A 0%nat a = inj A m b)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  b : A (m.+1)%nat	  ============================	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A (m.+1)%nat b)	";
            responses[i]=data;
          

            i = 525;
            data = "1 subgoal (ID 998)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  m : nat	  IHm : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (a : A 0%nat) (b : A m),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	           end) k (inj A 0%nat a = inj A m b)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  b : A (m.+1)%nat	  ============================	  IsTrunc k (inj A 1%nat (a) ^+ = inj A (m.+1)%nat b)	";
            responses[i]=data;
          

            i = 526;
            data = "1 subgoal (ID 1139)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  m : nat	  IHm : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (a : A 0%nat) (b : A m),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	           end) k (inj A 0%nat a = inj A m b)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  b : A (m.+1)%nat	  ============================	  inj (succ_seq A) 0%nat (a) ^+ = inj (succ_seq A) m b <~>	  inj A 1%nat (a) ^+ = inj A (m.+1)%nat b	";
            responses[i]=data;
          

            i = 527;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 subgoals (ID 933)		subgoal 1 (ID 933) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	       end) k (inj A 0%nat a = w)) (colimp i j g x)	   ((fun (m : Graph.graph0 sequence_graph) (b : A m) =>	     nat_rect	       (fun m0 : nat =>	        forall A0 : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	        forall (a0 : A0 0%nat) (b0 : A0 m0),	        (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a0 = inj A0 m0 b0))	       (fun (A0 : Sequence)	          (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	          (a0 b0 : A0 0%nat) =>	        trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	          (equiv_path_colim 0%nat a0 b0)^-1)	       (fun (m0 : nat)	          (IHm : forall A0 : Sequence,	                 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	                 forall (a0 : A0 0%nat) (b0 : A0 m0),	                 (fix IsTrunc_internal	                    (n : trunc_index) (A1 : Type) {struct n} : Type :=	                    match n with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	          (A0 : Sequence)	          (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	          (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	        trunc_equiv' (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	          (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	       trH a b) j ((A _f g) x)) =	 (fun (m : Graph.graph0 sequence_graph) (b : A m) =>	  nat_rect	    (fun m0 : nat =>	     forall A0 : Sequence,	     (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	     forall (a0 : A0 0%nat) (b0 : A0 m0),	     (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A1	        | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	        end) k (inj A0 0%nat a0 = inj A0 m0 b0))	    (fun (A0 : Sequence)	       (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	       (a0 b0 : A0 0%nat) =>	     trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	       (equiv_path_colim 0%nat a0 b0)^-1)	    (fun (m0 : nat)	       (IHm : forall A0 : Sequence,	              (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	              forall (a0 : A0 0%nat) (b0 : A0 m0),	              (fix IsTrunc_internal	                 (n : trunc_index) (A1 : Type) {struct n} : Type :=	                 match n with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	       (A0 : Sequence)	       (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	       (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	     trunc_equiv' (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	       (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	    trH a b) i x	subgoal 2 (ID 910) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	subgoal 3 (ID 898) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) => 	        ?Goal@{n:=n0}) n A trH) j ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	             (b0 : A1 (m0.+1)%nat) =>	           trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	             (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	          m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) => ?Goal@{n:=n0}) n A trH) i x	";
            responses[i]=data;
          

            i = 528;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 subgoals (ID 933)		subgoal 1 (ID 933) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	       end) k (inj A 0%nat a = w)) (colimp i j g x)	   ((fun (m : Graph.graph0 sequence_graph) (b : A m) =>	     nat_rect	       (fun m0 : nat =>	        forall A0 : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	        forall (a0 : A0 0%nat) (b0 : A0 m0),	        (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a0 = inj A0 m0 b0))	       (fun (A0 : Sequence)	          (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	          (a0 b0 : A0 0%nat) =>	        trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	          (equiv_path_colim 0%nat a0 b0)^-1)	       (fun (m0 : nat)	          (IHm : forall A0 : Sequence,	                 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	                 forall (a0 : A0 0%nat) (b0 : A0 m0),	                 (fix IsTrunc_internal	                    (n : trunc_index) (A1 : Type) {struct n} : Type :=	                    match n with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	          (A0 : Sequence)	          (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	          (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	        trunc_equiv' (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	          (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	       trH a b) j ((A _f g) x)) =	 (fun (m : Graph.graph0 sequence_graph) (b : A m) =>	  nat_rect	    (fun m0 : nat =>	     forall A0 : Sequence,	     (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	     forall (a0 : A0 0%nat) (b0 : A0 m0),	     (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A1	        | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	        end) k (inj A0 0%nat a0 = inj A0 m0 b0))	    (fun (A0 : Sequence)	       (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	       (a0 b0 : A0 0%nat) =>	     trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	       (equiv_path_colim 0%nat a0 b0)^-1)	    (fun (m0 : nat)	       (IHm : forall A0 : Sequence,	              (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	              forall (a0 : A0 0%nat) (b0 : A0 m0),	              (fix IsTrunc_internal	                 (n : trunc_index) (A1 : Type) {struct n} : Type :=	                 match n with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	       (A0 : Sequence)	       (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	       (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	     trunc_equiv' (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	       (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	    trH a b) i x	subgoal 2 (ID 910) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	subgoal 3 (ID 898) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) => 	        ?Goal@{n:=n0}) n A trH) j ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	             (b0 : A1 (m0.+1)%nat) =>	           trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	             (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	          m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) => ?Goal@{n:=n0}) n A trH) i x	1 subgoal (ID 933)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : A i),	  transport	    (fun w : Colimit A =>	     (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A0	        | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	        end) k (inj A 0%nat a = w)) (colimp i j g x)	    ((fun (m : Graph.graph0 sequence_graph) (b : A m) =>	      nat_rect	        (fun m0 : nat =>	         forall A0 : Sequence,	         (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	         forall (a0 : A0 0%nat) (b0 : A0 m0),	         (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	              Type :=	            match n with	            | -2 => Contr_internal A1	            | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	            end) k (inj A0 0%nat a0 = inj A0 m0 b0))	        (fun (A0 : Sequence)	           (trH0 : forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) (a0 b0 : A0 0%nat) =>	         trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	           (equiv_path_colim 0%nat a0 b0)^-1)	        (fun (m0 : nat)	           (IHm : forall A0 : Sequence,	                  (forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) ->	                  forall (a0 : A0 0%nat) (b0 : A0 m0),	                  (fix IsTrunc_internal	                     (n : trunc_index) (A1 : Type) {struct n} : Type :=	                     match n with	                     | -2 => Contr_internal A1	                     | n'.+1 =>	                         forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                     end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	           (A0 : Sequence)	           (trH0 : forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) (a0 : A0 0%nat) 	           (b0 : A0 (m0.+1)%nat) =>	         trunc_equiv' (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	           (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m	        A trH a b) j ((A _f g) x)) =	  (fun (m : Graph.graph0 sequence_graph) (b : A m) =>	   nat_rect	     (fun m0 : nat =>	      forall A0 : Sequence,	      (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	      forall (a0 : A0 0%nat) (b0 : A0 m0),	      (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	           Type :=	         match n with	         | -2 => Contr_internal A1	         | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	         end) k (inj A0 0%nat a0 = inj A0 m0 b0))	     (fun (A0 : Sequence)	        (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	        (a0 b0 : A0 0%nat) =>	      trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	        (equiv_path_colim 0%nat a0 b0)^-1)	     (fun (m0 : nat)	        (IHm : forall A0 : Sequence,	               (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	               forall (a0 : A0 0%nat) (b0 : A0 m0),	               (fix IsTrunc_internal	                  (n : trunc_index) (A1 : Type) {struct n} : Type :=	                  match n with	                  | -2 => Contr_internal A1	                  | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                  end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	        (A0 : Sequence)	        (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	        (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	      trunc_equiv' (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	        (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	     trH a b) i x	1 subgoal (ID 933)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : A i),	  transport	    (fun w : Colimit A =>	     (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A0	        | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	        end) k (inj A 0%nat a = w)) (colimp i j g x)	    ((fun (m : Graph.graph0 sequence_graph) (b : A m) =>	      nat_rect	        (fun m0 : nat =>	         forall A0 : Sequence,	         (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	         forall (a0 : A0 0%nat) (b0 : A0 m0),	         (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	              Type :=	            match n with	            | -2 => Contr_internal A1	            | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	            end) k (inj A0 0%nat a0 = inj A0 m0 b0))	        (fun (A0 : Sequence)	           (trH0 : forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) (a0 b0 : A0 0%nat) =>	         trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	           (equiv_path_colim 0%nat a0 b0)^-1)	        (fun (m0 : nat)	           (IHm : forall A0 : Sequence,	                  (forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) ->	                  forall (a0 : A0 0%nat) (b0 : A0 m0),	                  (fix IsTrunc_internal	                     (n : trunc_index) (A1 : Type) {struct n} : Type :=	                     match n with	                     | -2 => Contr_internal A1	                     | n'.+1 =>	                         forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                     end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	           (A0 : Sequence)	           (trH0 : forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) (a0 : A0 0%nat) 	           (b0 : A0 (m0.+1)%nat) =>	         trunc_equiv' (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	           (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m	        A trH a b) j ((A _f g) x)) =	  (fun (m : Graph.graph0 sequence_graph) (b : A m) =>	   nat_rect	     (fun m0 : nat =>	      forall A0 : Sequence,	      (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	      forall (a0 : A0 0%nat) (b0 : A0 m0),	      (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	           Type :=	         match n with	         | -2 => Contr_internal A1	         | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	         end) k (inj A0 0%nat a0 = inj A0 m0 b0))	     (fun (A0 : Sequence)	        (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	        (a0 b0 : A0 0%nat) =>	      trunc_equiv' (Colimit (path_seq (shift_seq A0 0) a0 b0))	        (equiv_path_colim 0%nat a0 b0)^-1)	     (fun (m0 : nat)	        (IHm : forall A0 : Sequence,	               (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	               forall (a0 : A0 0%nat) (b0 : A0 m0),	               (fix IsTrunc_internal	                  (n : trunc_index) (A1 : Type) {struct n} : Type :=	                  match n with	                  | -2 => Contr_internal A1	                  | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                  end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	        (A0 : Sequence)	        (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	        (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	      trunc_equiv' (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	        (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	     trH a b) i x	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 subgoals (ID 910)		subgoal 1 (ID 910) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	subgoal 2 (ID 898) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             m A0 trH0 a b)	          (fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (b : A0 n0) =>	           path_ishprop	             (transport	                (fun w : Colimit A0 =>	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	                ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	                  nat_rect	                    (fun m1 : nat =>	                     forall A1 : Sequence,	                     (forall n1 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n1)) ->	                     forall (a0 : A1 0%nat) (b1 : A1 m1),	                     (fix IsTrunc_internal	                        (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                        match n1 with	                        | -2 => Contr_internal A2	                        | n'.+1 =>	                            forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                        end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (fun (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 b1 : A1 0%nat) =>	                     trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b1))	                       (equiv_path_colim 0%nat a0 b1)^-1)	                    (fun (m1 : nat)	                       (IHm : forall A1 : Sequence,	                              (forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) ->	                              forall (a0 : A1 0%nat) 	                              (b1 : A1 m1),	                              (fix IsTrunc_internal	                                 (n1 : trunc_index) (A2 : Type) {struct n1} :	                                   Type :=	                                 match n1 with	                                 | -2 => Contr_internal A2	                                 | n'.+1 =>	                                     forall x0 y : A2,	                                     IsTrunc_internal n' (x0 = y)	                                 end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                       (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                     trunc_equiv'	                       (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                       (equiv_concat_l (glue A1 0%nat a0)	                          (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                   ((A0 _f p) b)))	             (nat_rect	                (fun m0 : nat =>	                 forall A1 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A1 n1)) ->	                 forall (a0 : A1 0%nat) (b0 : A1 m0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A2	                    | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                    end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (fun (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	                 trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                   (equiv_path_colim 0%nat a0 b0)^-1)	                (fun (m0 : nat)	                   (IHm : forall A1 : Sequence,	                          (forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) ->	                          forall (a0 : A1 0%nat) (b0 : A1 m0),	                          (fix IsTrunc_internal	                             (n1 : trunc_index) (A2 : Type) {struct n1} :	                               Type :=	                             match n1 with	                             | -2 => Contr_internal A2	                             | n'.+1 =>	                                 forall x0 y : A2,	                                 IsTrunc_internal n' (x0 = y)	                             end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                   (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                   (b0 : A1 (m0.+1)%nat) =>	                 trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                   (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	                n0 A0 trH0 a b)))	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) => 	        ?Goal@{n:=n0}) n A trH) j ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	             (b0 : A1 (m0.+1)%nat) =>	           trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	             (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	          m A0 trH0 a b)	       (fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) (b : A0 n0) =>	        path_ishprop	          (transport	             (fun w : Colimit A0 =>	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	             ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	               nat_rect	                 (fun m1 : nat =>	                  forall A1 : Sequence,	                  (forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A1 n1)) ->	                  forall (a0 : A1 0%nat) (b1 : A1 m1),	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A2	                     | n'.+1 =>	                         forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                     end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                 (fun (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 b1 : A1 0%nat) =>	                  trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b1))	                    (equiv_path_colim 0%nat a0 b1)^-1)	                 (fun (m1 : nat)	                    (IHm : forall A1 : Sequence,	                           (forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) ->	                           forall (a0 : A1 0%nat) 	                           (b1 : A1 m1),	                           (fix IsTrunc_internal	                              (n1 : trunc_index) (A2 : Type) {struct n1} :	                                Type :=	                              match n1 with	                              | -2 => Contr_internal A2	                              | n'.+1 =>	                                  forall x0 y : A2,	                                  IsTrunc_internal n' (x0 = y)	                              end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                  trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                    (equiv_concat_l (glue A1 0%nat a0)	                       (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                ((A0 _f p) b)))	          (nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n1)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n1 : trunc_index) (A2 : Type) {struct n1} :	                            Type :=	                          match n1 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             n0 A0 trH0 a b)))	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) => ?Goal@{n:=n0}) n A trH) i x	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 subgoals (ID 910)		subgoal 1 (ID 910) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	subgoal 2 (ID 898) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             m A0 trH0 a b)	          (fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (b : A0 n0) =>	           path_ishprop	             (transport	                (fun w : Colimit A0 =>	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	                ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	                  nat_rect	                    (fun m1 : nat =>	                     forall A1 : Sequence,	                     (forall n1 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n1)) ->	                     forall (a0 : A1 0%nat) (b1 : A1 m1),	                     (fix IsTrunc_internal	                        (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                        match n1 with	                        | -2 => Contr_internal A2	                        | n'.+1 =>	                            forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                        end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (fun (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 b1 : A1 0%nat) =>	                     trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b1))	                       (equiv_path_colim 0%nat a0 b1)^-1)	                    (fun (m1 : nat)	                       (IHm : forall A1 : Sequence,	                              (forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) ->	                              forall (a0 : A1 0%nat) 	                              (b1 : A1 m1),	                              (fix IsTrunc_internal	                                 (n1 : trunc_index) (A2 : Type) {struct n1} :	                                   Type :=	                                 match n1 with	                                 | -2 => Contr_internal A2	                                 | n'.+1 =>	                                     forall x0 y : A2,	                                     IsTrunc_internal n' (x0 = y)	                                 end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                       (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                     trunc_equiv'	                       (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                       (equiv_concat_l (glue A1 0%nat a0)	                          (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                   ((A0 _f p) b)))	             (nat_rect	                (fun m0 : nat =>	                 forall A1 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A1 n1)) ->	                 forall (a0 : A1 0%nat) (b0 : A1 m0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A2	                    | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                    end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (fun (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	                 trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                   (equiv_path_colim 0%nat a0 b0)^-1)	                (fun (m0 : nat)	                   (IHm : forall A1 : Sequence,	                          (forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) ->	                          forall (a0 : A1 0%nat) (b0 : A1 m0),	                          (fix IsTrunc_internal	                             (n1 : trunc_index) (A2 : Type) {struct n1} :	                               Type :=	                             match n1 with	                             | -2 => Contr_internal A2	                             | n'.+1 =>	                                 forall x0 y : A2,	                                 IsTrunc_internal n' (x0 = y)	                             end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                   (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                   (b0 : A1 (m0.+1)%nat) =>	                 trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                   (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	                n0 A0 trH0 a b)))	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) => 	        ?Goal@{n:=n0}) n A trH) j ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	             (b0 : A1 (m0.+1)%nat) =>	           trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	             (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	          m A0 trH0 a b)	       (fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) (b : A0 n0) =>	        path_ishprop	          (transport	             (fun w : Colimit A0 =>	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	             ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	               nat_rect	                 (fun m1 : nat =>	                  forall A1 : Sequence,	                  (forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A1 n1)) ->	                  forall (a0 : A1 0%nat) (b1 : A1 m1),	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A2	                     | n'.+1 =>	                         forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                     end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                 (fun (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 b1 : A1 0%nat) =>	                  trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b1))	                    (equiv_path_colim 0%nat a0 b1)^-1)	                 (fun (m1 : nat)	                    (IHm : forall A1 : Sequence,	                           (forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) ->	                           forall (a0 : A1 0%nat) 	                           (b1 : A1 m1),	                           (fix IsTrunc_internal	                              (n1 : trunc_index) (A2 : Type) {struct n1} :	                                Type :=	                              match n1 with	                              | -2 => Contr_internal A2	                              | n'.+1 =>	                                  forall x0 y : A2,	                                  IsTrunc_internal n' (x0 = y)	                              end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                  trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                    (equiv_concat_l (glue A1 0%nat a0)	                       (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                ((A0 _f p) b)))	          (nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n1)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n1 : trunc_index) (A2 : Type) {struct n1} :	                            Type :=	                          match n1 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             n0 A0 trH0 a b)))	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) => ?Goal@{n:=n0}) n A trH) i x	1 subgoal (ID 910)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  n : nat	  IHn : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (x : A n) (y : Colimit A),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	           end) k (inj A n x = y)	  ============================	  forall A : Sequence,	  (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	  forall (x : A (n.+1)%nat) (y : Colimit A),	  (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	     match n0 with	     | -2 => Contr_internal A0	     | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	     end) k (inj A (n.+1)%nat x = y)	1 subgoal (ID 1215)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  n : nat	  IHn : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (x : A n) (y : Colimit A),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	           end) k (inj A n x = y)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A (n.+1)%nat	  ============================	  forall a0 : Colimit (succ_seq A),	  (fun b : Colimit A =>	   (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	      match n0 with	      | -2 => Contr_internal A0	      | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	      end) k (inj A (n.+1)%nat a = b)) (colim_succ_seq_to_colim_seq A a0)	";
            responses[i]=data;
          

            i = 529;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 898)		subgoal 1 (ID 898) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             m A0 trH0 a b)	          (fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (b : A0 n0) =>	           path_ishprop	             (transport	                (fun w : Colimit A0 =>	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	                ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	                  nat_rect	                    (fun m1 : nat =>	                     forall A1 : Sequence,	                     (forall n1 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n1)) ->	                     forall (a0 : A1 0%nat) (b1 : A1 m1),	                     (fix IsTrunc_internal	                        (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                        match n1 with	                        | -2 => Contr_internal A2	                        | n'.+1 =>	                            forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                        end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (fun (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 b1 : A1 0%nat) =>	                     trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b1))	                       (equiv_path_colim 0%nat a0 b1)^-1)	                    (fun (m1 : nat)	                       (IHm : forall A1 : Sequence,	                              (forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) ->	                              forall (a0 : A1 0%nat) 	                              (b1 : A1 m1),	                              (fix IsTrunc_internal	                                 (n1 : trunc_index) (A2 : Type) {struct n1} :	                                   Type :=	                                 match n1 with	                                 | -2 => Contr_internal A2	                                 | n'.+1 =>	                                     forall x0 y : A2,	                                     IsTrunc_internal n' (x0 = y)	                                 end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                       (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                     trunc_equiv'	                       (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                       (equiv_concat_l (glue A1 0%nat a0)	                          (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                   ((A0 _f p) b)))	             (nat_rect	                (fun m0 : nat =>	                 forall A1 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A1 n1)) ->	                 forall (a0 : A1 0%nat) (b0 : A1 m0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A2	                    | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                    end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (fun (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	                 trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                   (equiv_path_colim 0%nat a0 b0)^-1)	                (fun (m0 : nat)	                   (IHm : forall A1 : Sequence,	                          (forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) ->	                          forall (a0 : A1 0%nat) (b0 : A1 m0),	                          (fix IsTrunc_internal	                             (n1 : trunc_index) (A2 : Type) {struct n1} :	                               Type :=	                             match n1 with	                             | -2 => Contr_internal A2	                             | n'.+1 =>	                                 forall x0 y : A2,	                                 IsTrunc_internal n' (x0 = y)	                             end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                   (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                   (b0 : A1 (m0.+1)%nat) =>	                 trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                   (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	                n0 A0 trH0 a b)))	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) (A0 : Sequence)	          (trH0 : forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) (a : A0 (n0.+1)%nat) =>	        functor_forall_equiv_pb (colim_succ_seq_to_colim_seq A0)	          (fun x0 : Colimit (succ_seq A0) =>	           trunc_equiv' (inj (succ_seq A0) n0 a = x0)	             (equiv_ap (colim_succ_seq_to_colim_seq A0)	                (inj (succ_seq A0) n0 a) x0))) n A trH) j 	      ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	             (b0 : A1 (m0.+1)%nat) =>	           trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	             (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	          m A0 trH0 a b)	       (fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) (b : A0 n0) =>	        path_ishprop	          (transport	             (fun w : Colimit A0 =>	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	             ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	               nat_rect	                 (fun m1 : nat =>	                  forall A1 : Sequence,	                  (forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A1 n1)) ->	                  forall (a0 : A1 0%nat) (b1 : A1 m1),	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A2	                     | n'.+1 =>	                         forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                     end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                 (fun (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 b1 : A1 0%nat) =>	                  trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b1))	                    (equiv_path_colim 0%nat a0 b1)^-1)	                 (fun (m1 : nat)	                    (IHm : forall A1 : Sequence,	                           (forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) ->	                           forall (a0 : A1 0%nat) 	                           (b1 : A1 m1),	                           (fix IsTrunc_internal	                              (n1 : trunc_index) (A2 : Type) {struct n1} :	                                Type :=	                              match n1 with	                              | -2 => Contr_internal A2	                              | n'.+1 =>	                                  forall x0 y : A2,	                                  IsTrunc_internal n' (x0 = y)	                              end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                  trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                    (equiv_concat_l (glue A1 0%nat a0)	                       (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                ((A0 _f p) b)))	          (nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n1)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	              trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n1 : trunc_index) (A2 : Type) {struct n1} :	                            Type :=	                          match n1 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             n0 A0 trH0 a b)))	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) (A0 : Sequence)	       (trH0 : forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1))	       (a : A0 (n0.+1)%nat) =>	     functor_forall_equiv_pb (colim_succ_seq_to_colim_seq A0)	       (fun x0 : Colimit (succ_seq A0) =>	        trunc_equiv' (inj (succ_seq A0) n0 a = x0)	          (equiv_ap (colim_succ_seq_to_colim_seq A0) 	             (inj (succ_seq A0) n0 a) x0))) n A trH) i x	";
            responses[i]=data;
          

            i = 530;
            data = "1 subgoal (ID 898)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : A i),	  transport	    (fun w : Colimit A =>	     forall y : Colimit A,	     (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A0	        | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	        end) k (w = y)) (colimp i j g x)	    ((fun n : Graph.graph0 sequence_graph =>	      nat_rect	        (fun n0 : nat =>	         forall A0 : Sequence,	         (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	         forall (x0 : A0 n0) (y : Colimit A0),	         (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	              Type :=	            match n1 with	            | -2 => Contr_internal A1	            | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	            end) k (inj A0 n0 x0 = y))	        (fun (A0 : Sequence)	           (trH0 : forall n0 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	         Colimit_ind	           (fun w : Colimit A0 =>	            (fix IsTrunc_internal	               (n0 : trunc_index) (A1 : Type) {struct n0} : Type :=	               match n0 with	               | -2 => Contr_internal A1	               | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	               end) k (inj A0 0%nat a = w))	           (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	            nat_rect	              (fun m0 : nat =>	               forall A1 : Sequence,	               (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	               forall (a0 : A1 0%nat) (b0 : A1 m0),	               (fix IsTrunc_internal	                  (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                  match n0 with	                  | -2 => Contr_internal A2	                  | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                  end) k (inj A1 0%nat a0 = inj A1 m0 b0))	              (fun (A1 : Sequence)	                 (trH1 : forall n0 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	               trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                 (equiv_path_colim 0%nat a0 b0)^-1)	              (fun (m0 : nat)	                 (IHm : forall A1 : Sequence,	                        (forall n0 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n0)) ->	                        forall (a0 : A1 0%nat) (b0 : A1 m0),	                        (fix IsTrunc_internal	                           (n0 : trunc_index) (A2 : Type) {struct n0} :	                             Type :=	                           match n0 with	                           | -2 => Contr_internal A2	                           | n'.+1 =>	                               forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                           end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                 (A1 : Sequence)	                 (trH1 : forall n0 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                 (b0 : A1 (m0.+1)%nat) =>	               trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                 (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	              m A0 trH0 a b)	           (fun (n0 m : Graph.graph0 sequence_graph)	              (p : Graph.graph1 sequence_graph n0 m) 	              (b : A0 n0) =>	            path_ishprop	              (transport	                 (fun w : Colimit A0 =>	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A1	                     | n'.+1 =>	                         forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                     end) k (inj A0 0%nat a = w)) 	                 (colimp n0 m p b)	                 ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	                   nat_rect	                     (fun m1 : nat =>	                      forall A1 : Sequence,	                      (forall n1 : Graph.graph0 sequence_graph,	                       IsTrunc k.+1 (A1 n1)) ->	                      forall (a0 : A1 0%nat) (b1 : A1 m1),	                      (fix IsTrunc_internal	                         (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                         match n1 with	                         | -2 => Contr_internal A2	                         | n'.+1 =>	                             forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                         end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                     (fun (A1 : Sequence)	                        (trH1 : forall n1 : Graph.graph0 sequence_graph,	                                IsTrunc k.+1 (A1 n1)) 	                        (a0 b1 : A1 0%nat) =>	                      trunc_equiv'	                        (Colimit (path_seq (shift_seq A1 0) a0 b1))	                        (equiv_path_colim 0%nat a0 b1)^-1)	                     (fun (m1 : nat)	                        (IHm : forall A1 : Sequence,	                               (forall n1 : Graph.graph0 sequence_graph,	                                IsTrunc k.+1 (A1 n1)) ->	                               forall (a0 : A1 0%nat) 	                               (b1 : A1 m1),	                               (fix IsTrunc_internal	                                  (n1 : trunc_index) (A2 : Type) {struct n1} :	                                    Type :=	                                  match n1 with	                                  | -2 => Contr_internal A2	                                  | n'.+1 =>	                                      forall x0 y : A2,	                                      IsTrunc_internal n' (x0 = y)	                                  end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                        (A1 : Sequence)	                        (trH1 : forall n1 : Graph.graph0 sequence_graph,	                                IsTrunc k.+1 (A1 n1)) 	                        (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                      trunc_equiv'	                        (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                        (equiv_concat_l (glue A1 0%nat a0)	                           (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                    ((A0 _f p) b)))	              (nat_rect	                 (fun m0 : nat =>	                  forall A1 : Sequence,	                  (forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A1 n1)) ->	                  forall (a0 : A1 0%nat) (b0 : A1 m0),	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A2	                     | n'.+1 =>	                         forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                     end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                 (fun (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 b0 : A1 0%nat) =>	                  trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                    (equiv_path_colim 0%nat a0 b0)^-1)	                 (fun (m0 : nat)	                    (IHm : forall A1 : Sequence,	                           (forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) ->	                           forall (a0 : A1 0%nat) 	                           (b0 : A1 m0),	                           (fix IsTrunc_internal	                              (n1 : trunc_index) (A2 : Type) {struct n1} :	                                Type :=	                              match n1 with	                              | -2 => Contr_internal A2	                              | n'.+1 =>	                                  forall x0 y : A2,	                                  IsTrunc_internal n' (x0 = y)	                              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                    (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 : A1 0%nat) (b0 : A1 (m0.+1)%nat) =>	                  trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                    (equiv_concat_l (glue A1 0%nat a0)	                       (inj A1 (m0.+1)%nat b0))^-1) n0 A0 trH0 a b)))	        (fun (n0 : nat)	           (IHn : forall A0 : Sequence,	                  (forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n1)) ->	                  forall (x0 : A0 n0) (y : Colimit A0),	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A1	                     | n'.+1 =>	                         forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                     end) k (inj A0 n0 x0 = y)) (A0 : Sequence)	           (trH0 : forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n1)) (a : A0 (n0.+1)%nat) =>	         functor_forall_equiv_pb (colim_succ_seq_to_colim_seq A0)	           (fun x0 : Colimit (succ_seq A0) =>	            trunc_equiv' (inj (succ_seq A0) n0 a = x0)	              (equiv_ap (colim_succ_seq_to_colim_seq A0)	                 (inj (succ_seq A0) n0 a) x0))) n A trH) j 	       ((A _f g) x)) =	  (fun n : Graph.graph0 sequence_graph =>	   nat_rect	     (fun n0 : nat =>	      forall A0 : Sequence,	      (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	      forall (x0 : A0 n0) (y : Colimit A0),	      (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	           Type :=	         match n1 with	         | -2 => Contr_internal A1	         | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	         end) k (inj A0 n0 x0 = y))	     (fun (A0 : Sequence)	        (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	        (a : A0 0%nat) =>	      Colimit_ind	        (fun w : Colimit A0 =>	         (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	              Type :=	            match n0 with	            | -2 => Contr_internal A1	            | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	            end) k (inj A0 0%nat a = w))	        (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	         nat_rect	           (fun m0 : nat =>	            forall A1 : Sequence,	            (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	            forall (a0 : A1 0%nat) (b0 : A1 m0),	            (fix IsTrunc_internal	               (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	               match n0 with	               | -2 => Contr_internal A2	               | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	               end) k (inj A1 0%nat a0 = inj A1 m0 b0))	           (fun (A1 : Sequence)	              (trH1 : forall n0 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	            trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	              (equiv_path_colim 0%nat a0 b0)^-1)	           (fun (m0 : nat)	              (IHm : forall A1 : Sequence,	                     (forall n0 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n0)) ->	                     forall (a0 : A1 0%nat) (b0 : A1 m0),	                     (fix IsTrunc_internal	                        (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                        match n0 with	                        | -2 => Contr_internal A2	                        | n'.+1 =>	                            forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                        end) k (inj A1 0%nat a0 = inj A1 m0 b0))	              (A1 : Sequence)	              (trH1 : forall n0 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	              (b0 : A1 (m0.+1)%nat) =>	            trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	              (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	           m A0 trH0 a b)	        (fun (n0 m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n0 m) 	           (b : A0 n0) =>	         path_ishprop	           (transport	              (fun w : Colimit A0 =>	               (fix IsTrunc_internal	                  (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                  match n1 with	                  | -2 => Contr_internal A1	                  | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                  end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	              ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	                nat_rect	                  (fun m1 : nat =>	                   forall A1 : Sequence,	                   (forall n1 : Graph.graph0 sequence_graph,	                    IsTrunc k.+1 (A1 n1)) ->	                   forall (a0 : A1 0%nat) (b1 : A1 m1),	                   (fix IsTrunc_internal	                      (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                      match n1 with	                      | -2 => Contr_internal A2	                      | n'.+1 =>	                          forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                      end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                  (fun (A1 : Sequence)	                     (trH1 : forall n1 : Graph.graph0 sequence_graph,	                             IsTrunc k.+1 (A1 n1)) 	                     (a0 b1 : A1 0%nat) =>	                   trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b1))	                     (equiv_path_colim 0%nat a0 b1)^-1)	                  (fun (m1 : nat)	                     (IHm : forall A1 : Sequence,	                            (forall n1 : Graph.graph0 sequence_graph,	                             IsTrunc k.+1 (A1 n1)) ->	                            forall (a0 : A1 0%nat) 	                            (b1 : A1 m1),	                            (fix IsTrunc_internal	                               (n1 : trunc_index) (A2 : Type) {struct n1} :	                                 Type :=	                               match n1 with	                               | -2 => Contr_internal A2	                               | n'.+1 =>	                                   forall x0 y : A2,	                                   IsTrunc_internal n' (x0 = y)	                               end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                     (A1 : Sequence)	                     (trH1 : forall n1 : Graph.graph0 sequence_graph,	                             IsTrunc k.+1 (A1 n1)) 	                     (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                   trunc_equiv'	                     (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                     (equiv_concat_l (glue A1 0%nat a0)	                        (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                 ((A0 _f p) b)))	           (nat_rect	              (fun m0 : nat =>	               forall A1 : Sequence,	               (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n1)) ->	               forall (a0 : A1 0%nat) (b0 : A1 m0),	               (fix IsTrunc_internal	                  (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                  match n1 with	                  | -2 => Contr_internal A2	                  | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                  end) k (inj A1 0%nat a0 = inj A1 m0 b0))	              (fun (A1 : Sequence)	                 (trH1 : forall n1 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	               trunc_equiv' (Colimit (path_seq (shift_seq A1 0) a0 b0))	                 (equiv_path_colim 0%nat a0 b0)^-1)	              (fun (m0 : nat)	                 (IHm : forall A1 : Sequence,	                        (forall n1 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n1)) ->	                        forall (a0 : A1 0%nat) (b0 : A1 m0),	                        (fix IsTrunc_internal	                           (n1 : trunc_index) (A2 : Type) {struct n1} :	                             Type :=	                           match n1 with	                           | -2 => Contr_internal A2	                           | n'.+1 =>	                               forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                           end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                 (A1 : Sequence)	                 (trH1 : forall n1 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                 (b0 : A1 (m0.+1)%nat) =>	               trunc_equiv' (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                 (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	              n0 A0 trH0 a b)))	     (fun (n0 : nat)	        (IHn : forall A0 : Sequence,	               (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	               forall (x0 : A0 n0) (y : Colimit A0),	               (fix IsTrunc_internal	                  (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                  match n1 with	                  | -2 => Contr_internal A1	                  | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                  end) k (inj A0 n0 x0 = y)) (A0 : Sequence)	        (trH0 : forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1))	        (a : A0 (n0.+1)%nat) =>	      functor_forall_equiv_pb (colim_succ_seq_to_colim_seq A0)	        (fun x0 : Colimit (succ_seq A0) =>	         trunc_equiv' (inj (succ_seq A0) n0 a = x0)	           (equiv_ap (colim_succ_seq_to_colim_seq A0)	              (inj (succ_seq A0) n0 a) x0))) n A trH) i x	2 subgoals (ID 1359)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  n, m : Graph.graph0 sequence_graph	  p : Graph.graph1 sequence_graph n m	  a : A n	  ============================	  Funext		subgoal 2 (ID 1363) is:	 forall a0 : Colimit A,	 IsHProp	   ((fun a1 : Colimit A =>	     (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} :	          Type :=	        match n0 with	        | -2 => Contr_internal A0	        | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	        end) k (inj A n a = a1)) a0)	";
            responses[i]=data;
          

            i = 531;
            data = "1 subgoal (ID 1359)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  n, m : Graph.graph0 sequence_graph	  p : Graph.graph1 sequence_graph n m	  a : A n	  ============================	  Funext	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal (ID 1363)		subgoal 1 (ID 1363) is:	 forall a0 : Colimit A,	 IsHProp	   ((fun a1 : Colimit A =>	     (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} :	          Type :=	        match n0 with	        | -2 => Contr_internal A0	        | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	        end) k (inj A n a = a1)) a0)	1 subgoal (ID 1363)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  n, m : Graph.graph0 sequence_graph	  p : Graph.graph1 sequence_graph n m	  a : A n	  ============================	  forall a0 : Colimit A,	  IsHProp	    ((fun a1 : Colimit A =>	      (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} :	           Type :=	         match n0 with	         | -2 => Contr_internal A0	         | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	         end) k (inj A n a = a1)) a0)	1 subgoal (ID 1363)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  n, m : Graph.graph0 sequence_graph	  p : Graph.graph1 sequence_graph n m	  a : A n	  ============================	  forall a0 : Colimit A,	  IsHProp	    ((fun a1 : Colimit A =>	      (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} :	           Type :=	         match n0 with	         | -2 => Contr_internal A0	         | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	         end) k (inj A n a = a1)) a0)	No more subgoals.	No more subgoals.	";
            responses[i]=data;
          

            i = 532;
            data = "";
            responses[i]=data;
          

            i = 533;
            data = "";
            responses[i]=data;
          

            i = 534;
            data = "";
            responses[i]=data;
          

            i = 535;
            data = "";
            responses[i]=data;
          

            i = 536;
            data = "";
            responses[i]=data;
          

            i = 537;
            data = "";
            responses[i]=data;
          

            i = 538;
            data = "";
            responses[i]=data;
          

            i = 539;
            data = "";
            responses[i]=data;
          

            i = 540;
            data = "";
            responses[i]=data;
          

            i = 541;
            data = "";
            responses[i]=data;
          

            i = 542;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.Colimits.Sequential</h1>
<div scenenumber="3" class="code"><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
</span></div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
We present a proof of the conjecture that sequential colimits in HoTT apropriately commute with -types. As a corollary, we characterize the path space of a sequential colimit as a sequential colimit of path spaces. For the written account of these results see https://www.cs.cornell.edu/~ks858/papers/sequential_colimits_homotopy.pdf. 
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(10, '0_3_7');
      ">
<br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">Basics</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(11, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">Types</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(12, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#"><span class="id" title="library">Diagrams.Diagram</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(13, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Diagrams.Sequence.html#"><span class="id" title="library">Diagrams.Sequence</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(14, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#"><span class="id" title="library">Diagrams.Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(15, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Colimits.Colimit.html#"><span class="id" title="library">Colimits.Colimit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(16, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Spaces.Nat.html#"><span class="id" title="library">Spaces.Nat</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(17, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.HProp.html#"><span class="id" title="library">HProp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(18, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.PathAny.html#"><span class="id" title="library">PathAny</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(19, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(20, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="coe" class="idref" href="#coe"><span class="id" title="abbreviation">coe</span></a> := (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(21, '0_3_7');
      "><br>
<span class="id" title="keyword">Notation</span> <a id="08eb96ff0845089548bf8ee31b997ae3" class="idref" href="#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">"</span></a>a ^+" := (@<a class="idref" href="HoTT.Diagrams.Diagram.html#arr"><span class="id" title="projection">arr</span></a> <a class="idref" href="HoTT.Diagrams.Sequence.html#sequence_graph"><span class="id" title="definition">sequence_graph</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> 1 <span class="id" title="var">a</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(22, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_shift_from_zero_by" class="idref" href="#seq_shift_from_zero_by"><span class="id" title="definition">seq_shift_from_zero_by</span></a> {<a id="A:1" class="idref" href="#A:1"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="a:2" class="idref" href="#a:2"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:1"><span class="id" title="variable">A</span></a> 0) <a id="k:3" class="idref" href="#k:3"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:1"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:3"><span class="id" title="variable">k</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(23, '0_3_7');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(24, '0_3_7');
      "><br>
<span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">q</span>].</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(25, '0_3_7');
      "><br>
- <span class="id" title="tactic">exact</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(26, '0_3_7');
      "><br>
- <span class="id" title="tactic">exact</span> <span class="id" title="var">q</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(27, '0_3_7');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(28, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="89dcb9d9e23f2b78dc8a1b1571e3a602" class="idref" href="#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">"</span></a>a ^+ k" := (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_shift_from_zero_by"><span class="id" title="definition">seq_shift_from_zero_by</span></a> <span class="id" title="var">a</span> <span class="id" title="var">k</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(29, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
Shiftings; described in the paragraph after Lemma 3.7. 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(33, '0_3_11');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_pair_shift" class="idref" href="#seq_pair_shift"><span class="id" title="definition">seq_pair_shift</span></a> {<a id="A:4" class="idref" href="#A:4"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="x:5" class="idref" href="#x:5"><span class="id" title="binder">x</span></a> : <a class="idref" href="Coq.Init.Specif.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:4"><span class="id" title="variable">A</span></a>) : <a class="idref" href="Coq.Init.Specif.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:4"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(34, '0_3_11');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(35, '0_3_11');
      "><br>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n</span> <span class="id" title="var">a</span>]; <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(36, '0_3_11');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(37, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_pair_shift_by" class="idref" href="#seq_pair_shift_by"><span class="id" title="definition">seq_pair_shift_by</span></a> {<a id="A:6" class="idref" href="#A:6"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="x:7" class="idref" href="#x:7"><span class="id" title="binder">x</span></a> : <a class="idref" href="Coq.Init.Specif.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:6"><span class="id" title="variable">A</span></a>) (<a id="k:8" class="idref" href="#k:8"><span class="id" title="binder">k</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Coq.Init.Specif.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:6"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(38, '0_3_11');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(39, '0_3_11');
      "><br>
<span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(40, '0_3_11');
      "><br>
- <span class="id" title="tactic">exact</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(41, '0_3_11');
      "><br>
- <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift"><span class="id" title="definition">seq_pair_shift</span></a> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(42, '0_3_11');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(43, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="18b94a88d8c66f36461830ed891d1ead" class="idref" href="#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">"</span></a>x ^++" := (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift"><span class="id" title="definition">seq_pair_shift</span></a> <span class="id" title="var">x</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(44, '0_3_11');
      "><br>
<span class="id" title="keyword">Notation</span> <a id="9bb4541bd65c2f34599b9513bda9dddb" class="idref" href="#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">"</span></a>x ^++ k" := (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift_by"><span class="id" title="definition">seq_pair_shift_by</span></a> <span class="id" title="var">x</span> <span class="id" title="var">k</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(45, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_pair_shift_assoc" class="idref" href="#seq_pair_shift_assoc"><span class="id" title="definition">seq_pair_shift_assoc</span></a> {<a id="A:9" class="idref" href="#A:9"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="x:10" class="idref" href="#x:10"><span class="id" title="binder">x</span></a> : <a class="idref" href="Coq.Init.Specif.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:9"><span class="id" title="variable">A</span></a>) (<a id="k:11" class="idref" href="#k:11"><span class="id" title="binder">k</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br>
: <a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:10"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">)^++</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:11"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:10"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">^++(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:11"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(46, '0_3_11');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(47, '0_3_11');
      "><br>
<span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">q</span>].</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(48, '0_3_11');
      "><br>
- <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(49, '0_3_11');
      "><br>
- <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift"><span class="id" title="definition">seq_pair_shift</span></a> <span class="id" title="var">q</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(50, '0_3_11');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(51, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_shift_pair_from_zero" class="idref" href="#seq_shift_pair_from_zero"><span class="id" title="definition">seq_shift_pair_from_zero</span></a> {<a id="A:12" class="idref" href="#A:12"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="a:13" class="idref" href="#a:13"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:12"><span class="id" title="variable">A</span></a> 0) <a id="k:14" class="idref" href="#k:14"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a>0<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:13"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">^++</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:14"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:14"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:13"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:14"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(52, '0_3_11');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(53, '0_3_11');
      "><br>
<span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">q</span>].</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(54, '0_3_11');
      "><br>
- <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(55, '0_3_11');
      "><br>
- <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift"><span class="id" title="definition">seq_pair_shift</span></a> <span class="id" title="var">q</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(56, '0_3_11');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(57, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="inj" class="idref" href="#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">A</span> := (@<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.colim"><span class="id" title="constructor">colim</span></a> <a class="idref" href="HoTT.Diagrams.Sequence.html#sequence_graph"><span class="id" title="definition">sequence_graph</span></a> <span class="id" title="var">A</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(58, '0_3_11');
      "><br>
<span class="id" title="keyword">Notation</span> <a id="glue" class="idref" href="#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span> := (<span class="id" title="keyword">fun</span> <a id="n:15" class="idref" href="#n:15"><span class="id" title="binder">n</span></a>  @<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.colimp"><span class="id" title="axiom">colimp</span></a> <a class="idref" href="HoTT.Diagrams.Sequence.html#sequence_graph"><span class="id" title="definition">sequence_graph</span></a> <span class="id" title="var">A</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:15"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:15"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> 1).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(59, '0_3_11');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
The uniqueness principle for sequential colimits; Lemma 3.3. 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(63, '0_3_15');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colimit_uniq" class="idref" href="#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a> {<a id="A:16" class="idref" href="#A:16"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} <a id="E:17" class="idref" href="#E:17"><span class="id" title="binder">E</span></a> (<a id="F:18" class="idref" href="#F:18"><span class="id" title="binder">F</span></a> <a id="G:19" class="idref" href="#G:19"><span class="id" title="binder">G</span></a> : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:16"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#E:17"><span class="id" title="variable">E</span></a>)<br>
(<a id="h:21" class="idref" href="#h:21"><span class="id" title="binder">h</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="n:20" class="idref" href="#n:20"><span class="id" title="binder">n</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:18"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:16"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:20"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:19"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:16"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:20"><span class="id" title="variable">n</span></a>)<br>
(<a id="H:24" class="idref" href="#H:24"><span class="id" title="binder">H</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="n:22" class="idref" href="#n:22"><span class="id" title="binder">n</span></a> <a id="a:23" class="idref" href="#a:23"><span class="id" title="binder">a</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:18"><span class="id" title="variable">F</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:16"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:22"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:23"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#h:21"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:22"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:23"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#h:21"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:22"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:23"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:19"><span class="id" title="variable">G</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:16"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:22"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:23"><span class="id" title="variable">a</span></a>))<br>
: <a class="idref" href="HoTT.Colimits.Sequential.html#F:18"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:19"><span class="id" title="variable">G</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(64, '0_3_15');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(65, '0_3_15');
      "><br>
<span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a> <span class="id" title="var">_</span> <span class="id" title="var">h</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(66, '0_3_15');
      "><br>
<span class="id" title="tactic">generalize</span> (<span class="id" title="var">H</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>); <span class="id" title="tactic">generalize</span> (<span class="id" title="var">h</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>); <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(67, '0_3_15');
      "><br>
<span class="id" title="tactic">intros</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span>; <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>); <span class="id" title="var">srefine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">)</span></a>); <span class="id" title="tactic">exact</span> <span class="id" title="var">q</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(68, '0_3_15');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(69, '0_3_15');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
The successor sequence from Lemma 3.6. 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(73, '0_3_19');
      ">
<span class="id" title="keyword">Definition</span> <a id="succ_seq" class="idref" href="#succ_seq"><span class="id" title="definition">succ_seq</span></a> (<a id="A:25" class="idref" href="#A:25"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>) : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a><br>
:= <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a> (<span class="id" title="keyword">fun</span> <a id="k:28" class="idref" href="#k:28"><span class="id" title="binder">k</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#A:25"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:28"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a>) (<span class="id" title="keyword">fun</span> <a id="k:26" class="idref" href="#k:26"><span class="id" title="binder">k</span></a> <a id="a:27" class="idref" href="#a:27"><span class="id" title="binder">a</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#a:27"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(74, '0_3_19');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
<div class="doc" scenenumber="21">
The shifted sequence from Lemma 3.7. 
</div>
<div scenenumber="23" class="code">
<span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(78, '0_3_23');
      ">
<span class="id" title="keyword">Definition</span> <a id="shift_seq" class="idref" href="#shift_seq"><span class="id" title="definition">shift_seq</span></a> (<a id="A:29" class="idref" href="#A:29"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>) <a id="n:30" class="idref" href="#n:30"><span class="id" title="binder">n</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a><br>
:= <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a> (<span class="id" title="keyword">fun</span> <a id="k:33" class="idref" href="#k:33"><span class="id" title="binder">k</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#A:29"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#k:33"><span class="id" title="variable">k</span></a><a class="idref" href="Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:30"><span class="id" title="variable">n</span></a>)%<span class="id" title="var">nat</span>) (<span class="id" title="keyword">fun</span> <a id="k:31" class="idref" href="#k:31"><span class="id" title="binder">k</span></a> <a id="a:32" class="idref" href="#a:32"><span class="id" title="binder">a</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#a:32"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(79, '0_3_23');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_23"><pre><span></span></pre></div>
<div class="doc" scenenumber="25">
The canonical equivalence between the colimit of the succesor sequence and the colimit of the original sequence; Lemma 3.6. 
</div>
<div scenenumber="27" class="code">
<span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(83, '0_3_27');
      ">
<span class="id" title="keyword">Definition</span> <a id="colim_succ_seq_to_colim_seq" class="idref" href="#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <a id="A:34" class="idref" href="#A:34"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:34"><span class="id" title="variable">A</span></a>) <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:34"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(84, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(85, '0_3_27');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(86, '0_3_27');
      "><br>
+ <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:37" class="idref" href="#n:37"><span class="id" title="binder">n</span></a> <a id="a:38" class="idref" href="#a:38"><span class="id" title="binder">a</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:35"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:36"><span class="id" title="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(87, '0_3_27');
      "><br>
+ <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(88, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(89, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="colim_succ_seq_to_colim_seq_beta_glue" class="idref" href="#colim_succ_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_succ_seq_to_colim_seq_beta_glue</span></a> <a id="A:39" class="idref" href="#A:39"><span class="id" title="binder">A</span></a> <a id="n:40" class="idref" href="#n:40"><span class="id" title="binder">n</span></a> <a id="a:41" class="idref" href="#a:41"><span class="id" title="binder">a</span></a><br>
: <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:39"><span class="id" title="variable">A</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:39"><span class="id" title="variable">A</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:40"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:41"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:39"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#n:40"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#a:41"><span class="id" title="variable">a</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(90, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(91, '0_3_27');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(92, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(93, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="colim_succ_seq_to_colim_seq_ap_inj" class="idref" href="#colim_succ_seq_to_colim_seq_ap_inj"><span class="id" title="definition">colim_succ_seq_to_colim_seq_ap_inj</span></a> <a id="A:42" class="idref" href="#A:42"><span class="id" title="binder">A</span></a> <a id="n:43" class="idref" href="#n:43"><span class="id" title="binder">n</span></a> (<a id="a1:44" class="idref" href="#a1:44"><span class="id" title="binder">a1</span></a> <a id="a2:45" class="idref" href="#a2:45"><span class="id" title="binder">a2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:42"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:43"><span class="id" title="variable">n</span></a>) (<a id="p:46" class="idref" href="#p:46"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#a1:44"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:45"><span class="id" title="variable">a2</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:42"><span class="id" title="variable">A</span></a>) (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:43"><span class="id" title="variable">n</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:46"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:43"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:46"><span class="id" title="variable">p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(94, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(95, '0_3_27');
      "><br>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(96, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(97, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a id="isequiv_colim_succ_seq_to_colim_seq" class="idref" href="#isequiv_colim_succ_seq_to_colim_seq"><span class="id" title="instance">isequiv_colim_succ_seq_to_colim_seq</span></a> <a id="A:47" class="idref" href="#A:47"><span class="id" title="binder">A</span></a><br>
: <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:47"><span class="id" title="variable">A</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(98, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(99, '0_3_27');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_adjointify"><span class="id" title="definition">isequiv_adjointify</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(100, '0_3_27');
      "><br>
+ <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(101, '0_3_27');
      "><br>
 <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:50" class="idref" href="#n:50"><span class="id" title="binder">n</span></a> <a id="a:51" class="idref" href="#a:51"><span class="id" title="binder">a</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <span class="id" title="var">A</span>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:48"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:49"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(102, '0_3_27');
      "><br>
 <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <span class="id" title="var">A</span>) <span class="id" title="var">n</span> <span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(103, '0_3_27');
      "><br>
+ <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(104, '0_3_27');
      "><br>
 <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:54" class="idref" href="#n:54"><span class="id" title="binder">n</span></a> <a id="a:55" class="idref" href="#a:55"><span class="id" title="binder">a</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:52"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:53"><span class="id" title="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(105, '0_3_27');
      "><br>
 <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a>, <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(106, '0_3_27');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_succ_seq_to_colim_seq_beta_glue</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(107, '0_3_27');
      "><br>
+ <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(108, '0_3_27');
      "><br>
 <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:58" class="idref" href="#n:58"><span class="id" title="binder">n</span></a> <a id="a:59" class="idref" href="#a:59"><span class="id" title="binder">a</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:56"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:57"><span class="id" title="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(109, '0_3_27');
      "><br>
 <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a>, <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(110, '0_3_27');
      "><br>
<span class="id" title="tactic">rewrite</span> (@<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a> <span class="id" title="var">_</span> <span class="id" title="var">A</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> 1); <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(111, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(112, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_colim_succ_seq_to_colim_seq" class="idref" href="#equiv_colim_succ_seq_to_colim_seq"><span class="id" title="definition">equiv_colim_succ_seq_to_colim_seq</span></a> <a id="A:60" class="idref" href="#A:60"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:60"><span class="id" title="variable">A</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:60"><span class="id" title="variable">A</span></a><br>
:= <a class="idref" href="HoTT.Basics.Overture.html#Build_Equiv"><span class="id" title="constructor">Build_Equiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:60"><span class="id" title="variable">A</span></a>) <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(113, '0_3_27');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_27"><pre><span></span></pre></div>
<div class="doc" scenenumber="29">
The canonical equivalence between the colimit of the shifted sequence and the colimit of the original sequence; Lemma 3.6. 
</div>
<div scenenumber="31" class="code">
<span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(117, '0_3_31');
      ">
<span class="id" title="keyword">Definition</span> <a id="colim_shift_seq_to_colim_seq" class="idref" href="#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <a id="A:61" class="idref" href="#A:61"><span class="id" title="binder">A</span></a> <a id="n:62" class="idref" href="#n:62"><span class="id" title="binder">n</span></a> : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:61"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:62"><span class="id" title="variable">n</span></a>) <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:61"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(118, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(119, '0_3_31');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(120, '0_3_31');
      "><br>
+ <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="k:65" class="idref" href="#k:65"><span class="id" title="binder">k</span></a> <a id="a:66" class="idref" href="#a:66"><span class="id" title="binder">a</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">A</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#k:63"><span class="id" title="variable">k</span></a><a class="idref" href="Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><span class="id" title="var">n</span>)%<span class="id" title="var">nat</span> <a class="idref" href="HoTT.Colimits.Sequential.html#a:64"><span class="id" title="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(121, '0_3_31');
      "><br>
+ <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">l</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span> (<span class="id" title="var">k</span><a class="idref" href="Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><span class="id" title="var">n</span>)%<span class="id" title="var">nat</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(122, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(123, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="colim_shift_seq_to_colim_seq_beta_glue" class="idref" href="#colim_shift_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_shift_seq_to_colim_seq_beta_glue</span></a> <a id="A:67" class="idref" href="#A:67"><span class="id" title="binder">A</span></a> <a id="n:68" class="idref" href="#n:68"><span class="id" title="binder">n</span></a> <a id="k:69" class="idref" href="#k:69"><span class="id" title="binder">k</span></a> <a id="a:70" class="idref" href="#a:70"><span class="id" title="binder">a</span></a><br>
: <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:67"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:68"><span class="id" title="variable">n</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:67"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:68"><span class="id" title="variable">n</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#k:69"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:70"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:67"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#k:69"><span class="id" title="variable">k</span></a><a class="idref" href="Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:68"><span class="id" title="variable">n</span></a>)%<span class="id" title="var">nat</span> <a class="idref" href="HoTT.Colimits.Sequential.html#a:70"><span class="id" title="variable">a</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(124, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(125, '0_3_31');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(126, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(127, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="colim_shift_seq_to_colim_seq_ap_inj" class="idref" href="#colim_shift_seq_to_colim_seq_ap_inj"><span class="id" title="definition">colim_shift_seq_to_colim_seq_ap_inj</span></a> <a id="A:71" class="idref" href="#A:71"><span class="id" title="binder">A</span></a> <a id="n:72" class="idref" href="#n:72"><span class="id" title="binder">n</span></a> <a id="k:73" class="idref" href="#k:73"><span class="id" title="binder">k</span></a> (<a id="a1:74" class="idref" href="#a1:74"><span class="id" title="binder">a1</span></a> <a id="a2:75" class="idref" href="#a2:75"><span class="id" title="binder">a2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:71"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:72"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:73"><span class="id" title="variable">k</span></a>) (<a id="p:76" class="idref" href="#p:76"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#a1:74"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:75"><span class="id" title="variable">a2</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:71"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:72"><span class="id" title="variable">n</span></a>) (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#k:73"><span class="id" title="variable">k</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:76"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#k:73"><span class="id" title="variable">k</span></a><a class="idref" href="Coq.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:72"><span class="id" title="variable">n</span></a>)%<span class="id" title="var">nat</span>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:76"><span class="id" title="variable">p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(128, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(129, '0_3_31');
      "><br>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(130, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(131, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="J" class="idref" href="#J"><span class="id" title="definition">J</span></a> {<a id="X:77" class="idref" href="#X:77"><span class="id" title="binder">X</span></a> <a id="Y:78" class="idref" href="#Y:78"><span class="id" title="binder">Y</span></a> <a id="Z:79" class="idref" href="#Z:79"><span class="id" title="binder">Z</span></a>} {<a id="x1:80" class="idref" href="#x1:80"><span class="id" title="binder">x1</span></a> <a id="x2:81" class="idref" href="#x2:81"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:77"><span class="id" title="variable">X</span></a>} {<a id="y:82" class="idref" href="#y:82"><span class="id" title="binder">y</span></a>} {<a id="I:84" class="idref" href="#I:84"><span class="id" title="binder">I</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="x:83" class="idref" href="#x:83"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:78"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:83"><span class="id" title="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:79"><span class="id" title="variable">Z</span></a>} (<a id="p:85" class="idref" href="#p:85"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:80"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:81"><span class="id" title="variable">x2</span></a>)<br>
: <a class="idref" href="HoTT.Colimits.Sequential.html#I:84"><span class="id" title="variable">I</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:81"><span class="id" title="variable">x2</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:82"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#I:84"><span class="id" title="variable">I</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x1:80"><span class="id" title="variable">x1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:78"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:85"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#y:82"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(132, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(133, '0_3_31');
      "><br>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(134, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(135, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="K" class="idref" href="#K"><span class="id" title="definition">K</span></a> {<a id="X:86" class="idref" href="#X:86"><span class="id" title="binder">X</span></a> <a id="Y:87" class="idref" href="#Y:87"><span class="id" title="binder">Y</span></a>} {<a id="x1:88" class="idref" href="#x1:88"><span class="id" title="binder">x1</span></a> <a id="x2:89" class="idref" href="#x2:89"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:86"><span class="id" title="variable">X</span></a>} {<a id="y:90" class="idref" href="#y:90"><span class="id" title="binder">y</span></a>} <a id="F:91" class="idref" href="#F:91"><span class="id" title="binder">F</span></a> <a id="G:92" class="idref" href="#G:92"><span class="id" title="binder">G</span></a> (<a id="p:93" class="idref" href="#p:93"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:88"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:89"><span class="id" title="variable">x2</span></a>) :<br>
<a class="idref" href="HoTT.Colimits.Sequential.html#G:92"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:89"><span class="id" title="variable">x2</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:87"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:93"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#y:90"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:87"><span class="id" title="variable">Y</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:91"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:93"><span class="id" title="variable">p</span></a>)) (<a class="idref" href="HoTT.Colimits.Sequential.html#G:92"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x1:88"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:90"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(136, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(137, '0_3_31');
      "><br>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(138, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(139, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="L" class="idref" href="#L"><span class="id" title="definition">L</span></a> {<a id="X:94" class="idref" href="#X:94"><span class="id" title="binder">X</span></a> <a id="Y:95" class="idref" href="#Y:95"><span class="id" title="binder">Y</span></a> <a id="Z:96" class="idref" href="#Z:96"><span class="id" title="binder">Z</span></a>} {<a id="x1:97" class="idref" href="#x1:97"><span class="id" title="binder">x1</span></a> <a id="x2:98" class="idref" href="#x2:98"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:94"><span class="id" title="variable">X</span></a>} {<a id="y:99" class="idref" href="#y:99"><span class="id" title="binder">y</span></a>} {<a id="F:100" class="idref" href="#F:100"><span class="id" title="binder">F</span></a> <a id="G:101" class="idref" href="#G:101"><span class="id" title="binder">G</span></a>} {<a id="I:103" class="idref" href="#I:103"><span class="id" title="binder">I</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="x:102" class="idref" href="#x:102"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:95"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:102"><span class="id" title="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:96"><span class="id" title="variable">Z</span></a>} {<a id="p:104" class="idref" href="#p:104"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:97"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:98"><span class="id" title="variable">x2</span></a>}<br>
(<a id="Q:107" class="idref" href="#Q:107"><span class="id" title="binder">Q</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="x:105" class="idref" href="#x:105"><span class="id" title="binder">x</span></a> <a id="y:106" class="idref" href="#y:106"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#I:103"><span class="id" title="variable">I</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#F:100"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:105"><span class="id" title="variable">x</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#G:101"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:105"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:106"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#I:103"><span class="id" title="variable">I</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:105"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:106"><span class="id" title="variable">y</span></a>)<br>
: <a class="idref" href="HoTT.Colimits.Sequential.html#Q:107"><span class="id" title="variable">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:98"><span class="id" title="variable">x2</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:99"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#J"><span class="id" title="definition">J</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:104"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
<a class="idref" href="HoTT.Colimits.Sequential.html#J"><span class="id" title="definition">J</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:100"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:104"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#I:103"><span class="id" title="variable">I</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#F:100"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x1:97"><span class="id" title="variable">x1</span></a>)) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#K"><span class="id" title="definition">K</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:100"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:101"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:104"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:95"><span class="id" title="variable">Y</span></a>) (<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:100"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:104"><span class="id" title="variable">p</span></a>))) (<a class="idref" href="HoTT.Colimits.Sequential.html#G:101"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:98"><span class="id" title="variable">x2</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:99"><span class="id" title="variable">y</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a><br>
<a class="idref" href="HoTT.Colimits.Sequential.html#Q:107"><span class="id" title="variable">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x1:97"><span class="id" title="variable">x1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:95"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:104"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#y:99"><span class="id" title="variable">y</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(140, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(141, '0_3_31');
      "><br>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">rewrite</span> !<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(142, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(143, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a id="isequiv_colim_shift_seq_to_colim_seq" class="idref" href="#isequiv_colim_shift_seq_to_colim_seq"><span class="id" title="instance">isequiv_colim_shift_seq_to_colim_seq</span></a> `{<a id="H:108" class="idref" href="#H:108"><span class="id" title="binder">Funext</span></a>} <a id="A:109" class="idref" href="#A:109"><span class="id" title="binder">A</span></a> <a id="n:110" class="idref" href="#n:110"><span class="id" title="binder">n</span></a><br>
: <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:109"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:110"><span class="id" title="variable">n</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(144, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(145, '0_3_31');
      "><br>
<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">e</span>]; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_homotopic'"><span class="id" title="definition">isequiv_homotopic'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(146, '0_3_31');
      "><br>
- <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#equiv_functor_colimit"><span class="id" title="definition">equiv_functor_colimit</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_diagram_equiv"><span class="id" title="constructor">Build_diagram_equiv</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(147, '0_3_31');
      "><br>
+ <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_DiagramMap"><span class="id" title="constructor">Build_DiagramMap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(148, '0_3_31');
      "><br>
 <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="k:112" class="idref" href="#k:112"><span class="id" title="binder">k</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">A</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.Nat.html#nat_plus_n_O"><span class="id" title="lemma">nat_plus_n_O</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:111"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(149, '0_3_31');
      "><br>
 <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">l</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#K"><span class="id" title="definition">K</span></a> <a class="idref" href="Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<span class="id" title="keyword">fun</span> <a id="n:115" class="idref" href="#n:115"><span class="id" title="binder">n</span></a> <a id="a:116" class="idref" href="#a:116"><span class="id" title="binder">a</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#a:114"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.Nat.html#nat_plus_n_O"><span class="id" title="lemma">nat_plus_n_O</span></a> <span class="id" title="var">k</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(150, '0_3_31');
      "><br>
<span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)))).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(151, '0_3_31');
      "><br>
+ <span class="id" title="tactic">intro</span> <span class="id" title="var">k</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Types.Universe.html#isequiv_path"><span class="id" title="instance">isequiv_path</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(152, '0_3_31');
      "><br>
- <span class="id" title="tactic">symmetry</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(153, '0_3_31');
      "><br>
+ <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#J"><span class="id" title="definition">J</span></a> (<a class="idref" href="HoTT.Spaces.Nat.html#nat_plus_n_O"><span class="id" title="lemma">nat_plus_n_O</span></a> <span class="id" title="var">k</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(154, '0_3_31');
      "><br>
+ <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> !<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#L"><span class="id" title="definition">L</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(155, '0_3_31');
      "><br>
- <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(156, '0_3_31');
      "><br>
+ <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#equiv_functor_colimit"><span class="id" title="definition">equiv_functor_colimit</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_diagram_equiv"><span class="id" title="constructor">Build_diagram_equiv</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(157, '0_3_31');
      "><br>
 <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_DiagramMap"><span class="id" title="constructor">Build_DiagramMap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(158, '0_3_31');
      "><br>
{ <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="k:118" class="idref" href="#k:118"><span class="id" title="binder">k</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">A</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.Nat.html#nat_plus_n_Sm"><span class="id" title="lemma">nat_plus_n_Sm</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:117"><span class="id" title="variable">k</span></a> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>)). }</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(159, '0_3_31');
      "><br>
{ <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">l</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="var">rapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#K"><span class="id" title="definition">K</span></a> <a class="idref" href="Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<span class="id" title="keyword">fun</span> <a id="n:121" class="idref" href="#n:121"><span class="id" title="binder">n</span></a> <a id="a:122" class="idref" href="#a:122"><span class="id" title="binder">a</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#a:120"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.Nat.html#nat_plus_n_Sm"><span class="id" title="lemma">nat_plus_n_Sm</span></a> <span class="id" title="var">k</span> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(160, '0_3_31');
      "><br>
<span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)))). }</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(161, '0_3_31');
      "><br>
 <span class="id" title="tactic">intro</span> <span class="id" title="var">k</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Types.Universe.html#isequiv_path"><span class="id" title="instance">isequiv_path</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(162, '0_3_31');
      "><br>
+ <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transitivity"><span class="id" title="definition">transitivity</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#equiv_colim_succ_seq_to_colim_seq"><span class="id" title="definition">equiv_colim_succ_seq_to_colim_seq</span></a> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Basics.Overture.html#Build_Equiv"><span class="id" title="constructor">Build_Equiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(163, '0_3_31');
      "><br>
- <span class="id" title="tactic">symmetry</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(164, '0_3_31');
      "><br>
+ <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#J"><span class="id" title="definition">J</span></a> (<a class="idref" href="HoTT.Spaces.Nat.html#nat_plus_n_Sm"><span class="id" title="lemma">nat_plus_n_Sm</span></a> <span class="id" title="var">k</span> <span class="id" title="var">n</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(165, '0_3_31');
      "><br>
+ <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(166, '0_3_31');
      "><br>
<span class="id" title="tactic">rewrite</span> 2(<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose'"><span class="id" title="definition">ap_compose'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <span class="id" title="var">k</span> <span class="id" title="var">a</span>)), <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>, 2<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_pp"><span class="id" title="definition">ap_pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(167, '0_3_31');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq_ap_inj"><span class="id" title="definition">colim_succ_seq_to_colim_seq_ap_inj</span></a>, <a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq_ap_inj"><span class="id" title="definition">colim_shift_seq_to_colim_seq_ap_inj</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(168, '0_3_31');
      "><br>
<span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_succ_seq_to_colim_seq_beta_glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(169, '0_3_31');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_shift_seq_to_colim_seq_beta_glue</span></a>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#L"><span class="id" title="definition">L</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(170, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(171, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_colim_shift_seq_to_colim_seq" class="idref" href="#equiv_colim_shift_seq_to_colim_seq"><span class="id" title="definition">equiv_colim_shift_seq_to_colim_seq</span></a> `{<a id="H:123" class="idref" href="#H:123"><span class="id" title="binder">Funext</span></a>} <a id="A:124" class="idref" href="#A:124"><span class="id" title="binder">A</span></a> <a id="n:125" class="idref" href="#n:125"><span class="id" title="binder">n</span></a><br>
: <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:124"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:125"><span class="id" title="variable">n</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:124"><span class="id" title="variable">A</span></a><br>
:= <a class="idref" href="HoTT.Basics.Overture.html#Build_Equiv"><span class="id" title="constructor">Build_Equiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:124"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:125"><span class="id" title="variable">n</span></a>) <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(172, '0_3_31');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_31"><pre><span></span></pre></div>
<div class="doc" scenenumber="33">
Corollary 7.7.1 for k := -2; implies Lemma 7.2. 
</div>
<div scenenumber="35" class="code">
<span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(176, '0_3_35');
      ">
<span class="id" title="keyword">Definition</span> <a id="contr_colim_contr_seq" class="idref" href="#contr_colim_contr_seq"><span class="id" title="definition">contr_colim_contr_seq</span></a> `{<a id="H:126" class="idref" href="#H:126"><span class="id" title="binder">Funext</span></a>} (<a id="A:127" class="idref" href="#A:127"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>)<br>
: <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="k:128" class="idref" href="#k:128"><span class="id" title="binder">k</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Contr"><span class="id" title="abbreviation">Contr</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#A:127"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:128"><span class="id" title="variable">k</span></a>)<a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Basics.Overture.html#Contr"><span class="id" title="abbreviation">Contr</span></a> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:127"><span class="id" title="variable">A</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(177, '0_3_35');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(178, '0_3_35');
      "><br>
<span class="id" title="tactic">intro</span> <span class="id" title="var">h_seqcontr</span>; <span class="id" title="tactic">pose</span> (<span class="id" title="var">unit_seq</span> := <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span>  <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>  <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(179, '0_3_35');
      "><br>
<span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#contr_equiv'"><span class="id" title="definition">contr_equiv'</span></a> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <span class="id" title="var">unit_seq</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(180, '0_3_35');
      "><br>
- <span class="id" title="tactic">symmetry</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#equiv_functor_colimit"><span class="id" title="definition">equiv_functor_colimit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(181, '0_3_35');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_diagram_equiv"><span class="id" title="constructor">Build_diagram_equiv</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_DiagramMap"><span class="id" title="constructor">Build_DiagramMap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(182, '0_3_35');
      "><br>
 <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>  <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(183, '0_3_35');
      "><br>
 <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(184, '0_3_35');
      "><br>
- <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#Build_Contr"><span class="id" title="constructor">Build_Contr</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">unit_seq</span> 0 <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)); <span class="id" title="tactic">intro</span> <span class="id" title="var">y</span>; <span class="id" title="tactic">symmetry</span>; <span class="id" title="var">revert</span> <span class="id" title="var">y</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(185, '0_3_35');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(186, '0_3_35');
      "><br>
 <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">r</span>].</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(187, '0_3_35');
      "><br>
+ <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(188, '0_3_35');
      "><br>
+ <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">unit_seq</span> <span class="id" title="var">n</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">r</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(189, '0_3_35');
      "><br>
 <span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_const"><span class="id" title="definition">ap_const</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(190, '0_3_35');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(191, '0_3_35');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_35"><pre><span></span></pre></div>
<div class="doc" scenenumber="37">
Fibered sequences; Section 4. 
</div>
<div scenenumber="39" class="code">
<span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(195, '0_3_39');
      ">
<span class="id" title="keyword">Record</span> <a id="FibSequence" class="idref" href="#FibSequence"><span class="id" title="record">FibSequence</span></a> (<a id="A:129" class="idref" href="#A:129"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>) := {<br>
<a id="fibSequence" class="idref" href="#fibSequence"><span class="id" title="projection">fibSequence</span></a> : <a class="idref" href="Coq.Init.Specif.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:129"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <span class="id" title="keyword">Type</span>;<br>
<a id="fibSequenceArr" class="idref" href="#fibSequenceArr"><span class="id" title="projection">fibSequenceArr</span></a> <a id="x:132" class="idref" href="#x:132"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence:131"><span class="id" title="method">fibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:132"><span class="id" title="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence:131"><span class="id" title="method">fibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:132"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a><br>
}.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(196, '0_3_39');
      "><br>
<br>
<span class="id" title="keyword">Coercion</span> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">fibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">:</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">&gt;-&gt;</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">Funclass</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(197, '0_3_39');
      "><br>
<br>
<span class="id" title="var">Arguments</span> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">fibSequence</span></a> {<span class="id" title="var">A</span>}.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(198, '0_3_39');
      "><br>
<span class="id" title="var">Arguments</span> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequenceArr"><span class="id" title="projection">fibSequenceArr</span></a> {<span class="id" title="var">A</span>}.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(199, '0_3_39');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="be7681fc4f0bf4f2eee9cf7f11f6ac16" class="idref" href="#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">"</span></a>b ^+f" := (<a class="idref" href="HoTT.Colimits.Sequential.html#fibSequenceArr"><span class="id" title="projection">fibSequenceArr</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">b</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(200, '0_3_39');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_39"><pre><span></span></pre></div>
<div class="doc" scenenumber="41">
The Sigma of a fibered type sequence; Definition 4.3. 
</div>
<div scenenumber="43" class="code">
<span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(204, '0_3_43');
      ">
<span class="id" title="keyword">Definition</span> <a id="sig_seq" class="idref" href="#sig_seq"><span class="id" title="definition">sig_seq</span></a> {<a id="A:134" class="idref" href="#A:134"><span class="id" title="binder">A</span></a>} (<a id="B:135" class="idref" href="#B:135"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:134"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(205, '0_3_43');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(206, '0_3_43');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(207, '0_3_43');
      "><br>
- <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:138" class="idref" href="#n:138"><span class="id" title="binder">n</span></a>  <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="a:139" class="idref" href="#a:139"><span class="id" title="binder">a</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <span class="id" title="var">A</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:136"><span class="id" title="variable">n</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:136"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:137"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a><a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(208, '0_3_43');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> [<span class="id" title="var">a</span> <span class="id" title="var">b</span>]; <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <span class="id" title="var">b</span><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">f</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(209, '0_3_43');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(210, '0_3_43');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_43"><pre><span></span></pre></div>
<div class="doc" scenenumber="45">
The canonical projection from the sequential colimit of Sigmas to the sequential colimit of the first component; Definition 4.3. 
</div>
<div scenenumber="47" class="code">
<span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(214, '0_3_47');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_to_seq_colim_fst" class="idref" href="#seq_colim_sum_to_seq_colim_fst"><span class="id" title="definition">seq_colim_sum_to_seq_colim_fst</span></a> {<a id="A:140" class="idref" href="#A:140"><span class="id" title="binder">A</span></a>} (<a id="B:141" class="idref" href="#B:141"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:140"><span class="id" title="variable">A</span></a>)<br>
: <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:141"><span class="id" title="variable">B</span></a>) <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:140"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(215, '0_3_47');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(216, '0_3_47');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(217, '0_3_47');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> [<span class="id" title="var">a</span> <span class="id" title="var">_</span>]; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(218, '0_3_47');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> [<span class="id" title="var">a</span> <span class="id" title="var">b</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(219, '0_3_47');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(220, '0_3_47');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_47"><pre><span></span></pre></div>
<div class="doc" scenenumber="49">
Given a sequence fibered over A, aach point x : sig A induces a new type sequence; Section 4. 
</div>
<div scenenumber="51" class="code">
<span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(224, '0_3_51');
      ">
<span class="id" title="keyword">Definition</span> <a id="fib_seq_to_seq" class="idref" href="#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> {<a id="A:142" class="idref" href="#A:142"><span class="id" title="binder">A</span></a>} (<a id="B:143" class="idref" href="#B:143"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:142"><span class="id" title="variable">A</span></a>) (<a id="x:144" class="idref" href="#x:144"><span class="id" title="binder">x</span></a> : <a class="idref" href="Coq.Init.Specif.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:142"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(225, '0_3_51');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(226, '0_3_51');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a>; <span class="id" title="tactic">intro</span> <span class="id" title="var">k</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">h</span>].</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(227, '0_3_51');
      "><br>
 <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:146" class="idref" href="#x:146"><span class="id" title="binder">x</span></a>  <span class="id" title="var">B</span> <a class="idref" href="HoTT.Colimits.Sequential.html#x:145"><span class="id" title="variable">x</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(228, '0_3_51');
      "><br>
 <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:148" class="idref" href="#x:148"><span class="id" title="binder">x</span></a>  <span class="id" title="var">h</span> <a class="idref" href="HoTT.Colimits.Sequential.html#x:147"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(229, '0_3_51');
      "><br>
 <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:151" class="idref" href="#x:151"><span class="id" title="binder">x</span></a> <a id="b:152" class="idref" href="#b:152"><span class="id" title="binder">b</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#b:150"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">f</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(230, '0_3_51');
      "><br>
 <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:154" class="idref" href="#x:154"><span class="id" title="binder">x</span></a>  <span class="id" title="var">h</span> <a class="idref" href="HoTT.Colimits.Sequential.html#x:153"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(231, '0_3_51');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(232, '0_3_51');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_51"><pre><span></span></pre></div>
<div class="doc" scenenumber="53">
The induced sequence can be equivalently described by using shifting; Lemma 7.1. 
</div>
<div scenenumber="55" class="code">
<span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(236, '0_3_55');
      ">
<span class="id" title="keyword">Definition</span> <a id="fib_seq_to_seq'" class="idref" href="#fib_seq_to_seq'"><span class="id" title="definition">fib_seq_to_seq'</span></a> {<a id="A:155" class="idref" href="#A:155"><span class="id" title="binder">A</span></a>} (<a id="B:156" class="idref" href="#B:156"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:155"><span class="id" title="variable">A</span></a>) (<a id="x:157" class="idref" href="#x:157"><span class="id" title="binder">x</span></a> : <a class="idref" href="Coq.Init.Specif.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:155"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a><br>
:= <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a> (<span class="id" title="keyword">fun</span> <a id="k:160" class="idref" href="#k:160"><span class="id" title="binder">k</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#B:156"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:157"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">^++</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:160"><span class="id" title="variable">k</span></a>) (<span class="id" title="keyword">fun</span> <a id="k:158" class="idref" href="#k:158"><span class="id" title="binder">k</span></a> <a id="b:159" class="idref" href="#b:159"><span class="id" title="binder">b</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#b:159"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">f</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(237, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_fib_seq_to_seq" class="idref" href="#equiv_fib_seq_to_seq"><span class="id" title="definition">equiv_fib_seq_to_seq</span></a> {<a id="A:161" class="idref" href="#A:161"><span class="id" title="binder">A</span></a>} (<a id="B:162" class="idref" href="#B:162"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:161"><span class="id" title="variable">A</span></a>) (<a id="x:163" class="idref" href="#x:163"><span class="id" title="binder">x</span></a> : <a class="idref" href="Coq.Init.Specif.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:161"><span class="id" title="variable">A</span></a>)<br>
: <a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:162"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:163"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Diagrams.Diagram.html#19674d50802deb812a81f7a836f35199"><span class="id" title="notation"></span></a><a class="idref" href="HoTT.Diagrams.Diagram.html#19674d50802deb812a81f7a836f35199"><span class="id" title="notation">d</span></a><a class="idref" href="HoTT.Diagrams.Diagram.html#19674d50802deb812a81f7a836f35199"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq'"><span class="id" title="definition">fib_seq_to_seq'</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:162"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:163"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(238, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(239, '0_3_55');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_diagram_equiv"><span class="id" title="constructor">Build_diagram_equiv</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(240, '0_3_55');
      "><br>
+ <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_DiagramMap"><span class="id" title="constructor">Build_DiagramMap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(241, '0_3_55');
      "><br>
 <span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">e</span>].</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(242, '0_3_55');
      "><br>
- <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span>  <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(243, '0_3_55');
      "><br>
- <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:165" class="idref" href="#x:165"><span class="id" title="binder">x</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">B</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift_assoc"><span class="id" title="definition">seq_pair_shift_assoc</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:164"><span class="id" title="variable">x</span></a> <span class="id" title="var">n</span>)) <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <span class="id" title="var">e</span> <a class="idref" href="HoTT.Colimits.Sequential.html#x:164"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(244, '0_3_55');
      "><br>
 <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">p</span>].</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(245, '0_3_55');
      "><br>
- <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>  <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(246, '0_3_55');
      "><br>
- <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:168" class="idref" href="#x:168"><span class="id" title="binder">x</span></a> <a id="b:169" class="idref" href="#b:169"><span class="id" title="binder">b</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#K"><span class="id" title="definition">K</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">p</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#x:166"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#b:167"><span class="id" title="variable">b</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(247, '0_3_55');
      "><br>
+ <span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">e</span>].</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(248, '0_3_55');
      "><br>
 <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span>  <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_idmap"><span class="id" title="instance">isequiv_idmap</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(249, '0_3_55');
      "><br>
 <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_compose"><span class="id" title="instance">isequiv_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(250, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(251, '0_3_55');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_55"><pre><span></span></pre></div>
<div class="doc" scenenumber="57">
A fibered type sequence defines a type family; Section 4. 
</div>
<div scenenumber="59" class="code">
<span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(255, '0_3_59');
      ">
<span class="id" title="keyword">Definition</span> <a id="fib_seq_to_type_fam" class="idref" href="#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> `{<a id="H:170" class="idref" href="#H:170"><span class="id" title="binder">Univalence</span></a>} {<a id="A:171" class="idref" href="#A:171"><span class="id" title="binder">A</span></a>} (<a id="B:172" class="idref" href="#B:172"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:171"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:171"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <span class="id" title="keyword">Type</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(256, '0_3_59');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(257, '0_3_59');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(258, '0_3_59');
      "><br>
- <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:175" class="idref" href="#n:175"><span class="id" title="binder">n</span></a> <a id="a:176" class="idref" href="#a:176"><span class="id" title="binder">a</span></a>  <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:173"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:174"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(259, '0_3_59');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Universe.html#path_universe_uncurried"><span class="id" title="definition">path_universe_uncurried</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(260, '0_3_59');
      "><br>
<span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#equiv_colim_succ_seq_to_colim_seq"><span class="id" title="definition">equiv_colim_succ_seq_to_colim_seq</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(261, '0_3_59');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(262, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="fib_seq_to_type_fam_beta_glue" class="idref" href="#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> `{<a id="H:177" class="idref" href="#H:177"><span class="id" title="binder">Univalence</span></a>} {<a id="A:178" class="idref" href="#A:178"><span class="id" title="binder">A</span></a>} <a id="B:179" class="idref" href="#B:179"><span class="id" title="binder">B</span></a> <a id="n:180" class="idref" href="#n:180"><span class="id" title="binder">n</span></a> <a id="a:181" class="idref" href="#a:181"><span class="id" title="binder">a</span></a> :<br>
<a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:179"><span class="id" title="variable">B</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:178"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:180"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:181"><span class="id" title="variable">a</span></a>))<a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:179"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:180"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:181"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(263, '0_3_59');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(264, '0_3_59');
      "><br>
<span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(265, '0_3_59');
      "><br>
<span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Types.Universe.html#transport_idmap_path_universe_uncurried"><span class="id" title="definition">transport_idmap_path_universe_uncurried</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(266, '0_3_59');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(267, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Delta" class="idref" href="#Delta"><span class="id" title="definition">Delta</span></a> {<a id="X:182" class="idref" href="#X:182"><span class="id" title="binder">X</span></a> <a id="Y:183" class="idref" href="#Y:183"><span class="id" title="binder">Y</span></a>} {<a id="x1:184" class="idref" href="#x1:184"><span class="id" title="binder">x1</span></a> <a id="x2:185" class="idref" href="#x2:185"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:182"><span class="id" title="variable">X</span></a>} {<a id="F:186" class="idref" href="#F:186"><span class="id" title="binder">F</span></a>} (<a id="p:187" class="idref" href="#p:187"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:184"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:185"><span class="id" title="variable">x2</span></a>) (<a id="psi:188" class="idref" href="#psi:188"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:183"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:187"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:186"><span class="id" title="variable">F</span></a>) <a id="y:189" class="idref" href="#y:189"><span class="id" title="binder">y</span></a><br>
: <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x1:184"><span class="id" title="variable">x1</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:189"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x2:185"><span class="id" title="variable">x2</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#F:186"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:189"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(268, '0_3_59');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(269, '0_3_59');
      "><br>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">psi</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(270, '0_3_59');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(271, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Delta_proj" class="idref" href="#Delta_proj"><span class="id" title="definition">Delta_proj</span></a> {<a id="X:190" class="idref" href="#X:190"><span class="id" title="binder">X</span></a> <a id="Y:191" class="idref" href="#Y:191"><span class="id" title="binder">Y</span></a>} {<a id="x1:192" class="idref" href="#x1:192"><span class="id" title="binder">x1</span></a> <a id="x2:193" class="idref" href="#x2:193"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:190"><span class="id" title="variable">X</span></a>} {<a id="F:194" class="idref" href="#F:194"><span class="id" title="binder">F</span></a>} (<a id="p:195" class="idref" href="#p:195"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:192"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:193"><span class="id" title="variable">x2</span></a>) (<a id="psi:196" class="idref" href="#psi:196"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:191"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:195"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:194"><span class="id" title="variable">F</span></a>) <a id="y:197" class="idref" href="#y:197"><span class="id" title="binder">y</span></a><br>
: <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:195"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:196"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:197"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:195"><span class="id" title="variable">p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(272, '0_3_59');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(273, '0_3_59');
      "><br>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">psi</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(274, '0_3_59');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(275, '0_3_59');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_59"><pre><span></span></pre></div>
<div class="doc" scenenumber="61">
The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits; Definition 5.1. 
</div>
<div scenenumber="63" class="code">
<span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(279, '0_3_63');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_to_sum_seq_colim" class="idref" href="#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> `{<a id="H:198" class="idref" href="#H:198"><span class="id" title="binder">Univalence</span></a>} {<a id="A:199" class="idref" href="#A:199"><span class="id" title="binder">A</span></a>} (<a id="B:200" class="idref" href="#B:200"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:199"><span class="id" title="variable">A</span></a>)<br>
: <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:200"><span class="id" title="variable">B</span></a>) <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <a class="idref" href="Coq.Init.Specif.html#sig"><span class="id" title="record">sig</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:200"><span class="id" title="variable">B</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(280, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(281, '0_3_63');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(282, '0_3_63');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> [<span class="id" title="var">a</span> <span class="id" title="var">b</span>]; <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) 0 <span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(283, '0_3_63');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> [<span class="id" title="var">a</span> <span class="id" title="var">b</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="var">srefine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) 0 <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(284, '0_3_63');
      "><br>
<span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <span class="id" title="var">B</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(285, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(286, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_to_sum_seq_colim_beta_glue" class="idref" href="#seq_colim_sum_to_sum_seq_colim_beta_glue"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim_beta_glue</span></a> `{<a id="H:201" class="idref" href="#H:201"><span class="id" title="binder">Univalence</span></a>} {<a id="A:202" class="idref" href="#A:202"><span class="id" title="binder">A</span></a>} <a id="B:203" class="idref" href="#B:203"><span class="id" title="binder">B</span></a> <a id="n:204" class="idref" href="#n:204"><span class="id" title="binder">n</span></a> <a id="a:205" class="idref" href="#a:205"><span class="id" title="binder">a</span></a> <a id="b:206" class="idref" href="#b:206"><span class="id" title="binder">b</span></a> :<br>
<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:203"><span class="id" title="variable">B</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:203"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:204"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:205"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:206"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:203"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:204"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:205"><span class="id" title="variable">a</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a><br>
<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="Coq.Init.Specif.html#exist"><span class="id" title="constructor">exist</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:202"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:204"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:205"><span class="id" title="variable">a</span></a>)) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) 0 <a class="idref" href="HoTT.Colimits.Sequential.html#b:206"><span class="id" title="variable">b</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(287, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(288, '0_3_63');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(289, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(290, '0_3_63');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_63"><pre><span></span></pre></div>
<div class="doc" scenenumber="65">
An alternative induction principle for the sum of colimits; Lemma 5.2 and Section 6. 
</div>
<div scenenumber="67" class="code">
<span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(294, '0_3_67');
      ">
<span class="id" title="keyword">Section</span> <a id="SeqColimitSumInd" class="idref" href="#SeqColimitSumInd"><span class="id" title="section">SeqColimitSumInd</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(295, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Context</span> `{<a id="H:207" class="idref" href="#H:207"><span class="id" title="binder">Univalence</span></a>} {<a id="A:208" class="idref" href="#A:208"><span class="id" title="binder">A</span></a>} (<a id="B:209" class="idref" href="#B:209"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:208"><span class="id" title="variable">A</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(296, '0_3_67');
      "><br>
<span class="id" title="keyword">Context</span> (<a id="E:210" class="idref" href="#E:210"><span class="id" title="binder">E</span></a> : <a class="idref" href="Coq.Init.Specif.html#sig"><span class="id" title="record">sig</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <span class="id" title="keyword">Type</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(297, '0_3_67');
      "><br>
<span class="id" title="keyword">Context</span> (<a id="e:214" class="idref" href="#e:214"><span class="id" title="binder">e</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="n:211" class="idref" href="#n:211"><span class="id" title="binder">n</span></a> <a id="a:212" class="idref" href="#a:212"><span class="id" title="binder">a</span></a> <a id="b:213" class="idref" href="#b:213"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:211"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:212"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:213"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(298, '0_3_67');
      "><br>
<span class="id" title="keyword">Context</span> (<a id="t:218" class="idref" href="#t:218"><span class="id" title="binder">t</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="n:215" class="idref" href="#n:215"><span class="id" title="binder">n</span></a> <a id="a:216" class="idref" href="#a:216"><span class="id" title="binder">a</span></a> <a id="b:217" class="idref" href="#b:217"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:215"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:216"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:217"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)<br>
<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:215"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#a:216"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#b:217"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">f</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:215"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:216"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:217"><span class="id" title="variable">b</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(299, '0_3_67');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_67"><pre><span></span></pre></div>
<div class="doc" scenenumber="69">
The point-point case of the nested induction; corresponds to "h" in the paper. 
</div>
<div scenenumber="71" class="code">
<span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(303, '0_3_71');
      ">
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Q" class="idref" href="#Q"><span class="id" title="definition">Q</span></a> <a id="k:219" class="idref" href="#k:219"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="n:220" class="idref" href="#n:220"><span class="id" title="binder">n</span></a> <a id="a:221" class="idref" href="#a:221"><span class="id" title="binder">a</span></a> <a id="b:222" class="idref" href="#b:222"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:220"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:221"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#k:219"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:222"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(304, '0_3_71');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(305, '0_3_71');
      "><br>
<span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">h</span>].</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(306, '0_3_71');
      "><br>
- <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.e"><span class="id" title="variable">e</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(307, '0_3_71');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>) <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <span class="id" title="var">h</span> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> (<span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(308, '0_3_71');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(309, '0_3_71');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_71"><pre><span></span></pre></div>
<div class="doc" scenenumber="73">
The path-point case of the nested induction is just reflexivity; corresponds to "mu" in the paper. 
</div>
<div scenenumber="75" class="code">
<span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(313, '0_3_75');
      ">
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Eta" class="idref" href="#Eta"><span class="id" title="definition">Eta</span></a> {<a id="X:223" class="idref" href="#X:223"><span class="id" title="binder">X</span></a> <a id="Y:224" class="idref" href="#Y:224"><span class="id" title="binder">Y</span></a> <a id="Z:225" class="idref" href="#Z:225"><span class="id" title="binder">Z</span></a>} {<a id="x:226" class="idref" href="#x:226"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:223"><span class="id" title="variable">X</span></a>} {<a id="y1:227" class="idref" href="#y1:227"><span class="id" title="binder">y1</span></a> <a id="y2:228" class="idref" href="#y2:228"><span class="id" title="binder">y2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#Y:224"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:226"><span class="id" title="variable">x</span></a>} {<a id="z:229" class="idref" href="#z:229"><span class="id" title="binder">z</span></a> : <a class="idref" href="Coq.Init.Specif.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:224"><span class="id" title="variable">Y</span></a>} {<a id="p:230" class="idref" href="#p:230"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#y1:227"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:228"><span class="id" title="variable">y2</span></a>}<br>
{<a id="q1:231" class="idref" href="#q1:231"><span class="id" title="binder">q1</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#z:229"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:226"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y1:227"><span class="id" title="variable">y1</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>} {<a id="q2:232" class="idref" href="#q2:232"><span class="id" title="binder">q2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#z:229"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:226"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y2:228"><span class="id" title="variable">y2</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>} (<a id="theta:233" class="idref" href="#theta:233"><span class="id" title="binder">theta</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#q2:232"><span class="id" title="variable">q2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q1:231"><span class="id" title="variable">q1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#p:230"><span class="id" title="variable">p</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Z:225"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="Coq.Init.Specif.html#exist"><span class="id" title="constructor">exist</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:224"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:226"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:230"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:225"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q1:231"><span class="id" title="variable">q1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:225"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q2:232"><span class="id" title="variable">q2</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(314, '0_3_75');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(315, '0_3_75');
      "><br>
<span class="id" title="tactic">symmetry</span> <span class="id" title="tactic">in</span> <span class="id" title="var">theta</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">theta</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">q1</span>. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(316, '0_3_75');
      "><span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(317, '0_3_75');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(318, '0_3_75');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Epsilon" class="idref" href="#Epsilon"><span class="id" title="definition">Epsilon</span></a> {<a id="X:234" class="idref" href="#X:234"><span class="id" title="binder">X</span></a> <a id="Y:235" class="idref" href="#Y:235"><span class="id" title="binder">Y</span></a> <a id="Z:236" class="idref" href="#Z:236"><span class="id" title="binder">Z</span></a>} {<a id="x1:237" class="idref" href="#x1:237"><span class="id" title="binder">x1</span></a> <a id="x2:238" class="idref" href="#x2:238"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:234"><span class="id" title="variable">X</span></a>} {<a id="y1:239" class="idref" href="#y1:239"><span class="id" title="binder">y1</span></a> <a id="y2:240" class="idref" href="#y2:240"><span class="id" title="binder">y2</span></a>} {<a id="F:241" class="idref" href="#F:241"><span class="id" title="binder">F</span></a>} (<a id="p:242" class="idref" href="#p:242"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:237"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:238"><span class="id" title="variable">x2</span></a>) {<a id="q:243" class="idref" href="#q:243"><span class="id" title="binder">q</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#y1:239"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:240"><span class="id" title="variable">y2</span></a>}<br>
{<a id="psi:244" class="idref" href="#psi:244"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:235"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:242"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:241"><span class="id" title="variable">F</span></a>} {<a id="r:245" class="idref" href="#r:245"><span class="id" title="binder">r</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#F:241"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y1:239"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:241"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:240"><span class="id" title="variable">y2</span></a>} (<a id="theta:246" class="idref" href="#theta:246"><span class="id" title="binder">theta</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:241"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q:243"><span class="id" title="variable">q</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#r:245"><span class="id" title="variable">r</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Z:236"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="Coq.Init.Specif.html#exist"><span class="id" title="constructor">exist</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:235"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:238"><span class="id" title="variable">x2</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#r:245"><span class="id" title="variable">r</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:236"><span class="id" title="variable">Z</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:242"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:244"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y1:239"><span class="id" title="variable">y1</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a><br>
<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:236"><span class="id" title="variable">Z</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:242"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:244"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:240"><span class="id" title="variable">y2</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Z:236"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="Coq.Init.Specif.html#exist"><span class="id" title="constructor">exist</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:235"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x1:237"><span class="id" title="variable">x1</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#q:243"><span class="id" title="variable">q</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(319, '0_3_75');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(320, '0_3_75');
      "><br>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">theta</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">q</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(321, '0_3_75');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(322, '0_3_75');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_75"><pre><span></span></pre></div>
<div class="doc" scenenumber="77">
The point-path case of the nested induction; corresponds to "H" in the paper. 
</div>
<div scenenumber="79" class="code">
<span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(326, '0_3_79');
      ">
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="R" class="idref" href="#R"><span class="id" title="definition">R</span></a> <a id="k:247" class="idref" href="#k:247"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="n:248" class="idref" href="#n:248"><span class="id" title="binder">n</span></a> <a id="a:249" class="idref" href="#a:249"><span class="id" title="binder">a</span></a> <a id="b:250" class="idref" href="#b:250"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="Coq.Init.Specif.html#exist"><span class="id" title="constructor">exist</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:248"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:249"><span class="id" title="variable">a</span></a>)) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#k:247"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:250"><span class="id" title="variable">b</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:247"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:248"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:249"><span class="id" title="variable">a</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#b:250"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>)) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:247"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:248"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:249"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:250"><span class="id" title="variable">b</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(327, '0_3_79');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(328, '0_3_79');
      "><br>
<span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">h</span>].</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(329, '0_3_79');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="var">srapply</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.t"><span class="id" title="variable">t</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(330, '0_3_79');
      "><br>
<span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Eta"><span class="id" title="definition">Eta</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim_beta_glue"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(331, '0_3_79');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="var">srefine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">h</span> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> (<span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(332, '0_3_79');
      "><br>
<span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Epsilon"><span class="id" title="definition">Epsilon</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.A"><span class="id" title="variable">A</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>) (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_succ_seq_to_colim_seq_beta_glue</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(333, '0_3_79');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(334, '0_3_79');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_79"><pre><span></span></pre></div>
<div class="doc" scenenumber="81">
The point case of the nested induction; corresponds to "g" in the paper. 
</div>
<div scenenumber="83" class="code">
<span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(338, '0_3_83');
      ">
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="F" class="idref" href="#F"><span class="id" title="definition">F</span></a> <a id="n:251" class="idref" href="#n:251"><span class="id" title="binder">n</span></a> <a id="a:252" class="idref" href="#a:252"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="x:253" class="idref" href="#x:253"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:251"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:252"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:253"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(339, '0_3_83');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(340, '0_3_83');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(341, '0_3_83');
      "><br>
- <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="k:255" class="idref" href="#k:255"><span class="id" title="binder">k</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:254"><span class="id" title="variable">k</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(342, '0_3_83');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">l</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#R"><span class="id" title="definition">R</span></a> <span class="id" title="var">k</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(343, '0_3_83');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(344, '0_3_83');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="F_beta_glue" class="idref" href="#F_beta_glue"><span class="id" title="definition">F_beta_glue</span></a> <a id="n:256" class="idref" href="#n:256"><span class="id" title="binder">n</span></a> <a id="a:257" class="idref" href="#a:257"><span class="id" title="binder">a</span></a> <a id="b:258" class="idref" href="#b:258"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:256"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:257"><span class="id" title="variable">a</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> 0 <a class="idref" href="HoTT.Colimits.Sequential.html#b:258"><span class="id" title="variable">b</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#R"><span class="id" title="definition">R</span></a> 0 <a class="idref" href="HoTT.Colimits.Sequential.html#n:256"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:257"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:258"><span class="id" title="variable">b</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(345, '0_3_83');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(346, '0_3_83');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind_beta_colimp"><span class="id" title="axiom">Colimit_ind_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(347, '0_3_83');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(348, '0_3_83');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Phi" class="idref" href="#Phi"><span class="id" title="definition">Phi</span></a> {<a id="X:259" class="idref" href="#X:259"><span class="id" title="binder">X</span></a> <a id="Y:260" class="idref" href="#Y:260"><span class="id" title="binder">Y</span></a> <a id="Z:261" class="idref" href="#Z:261"><span class="id" title="binder">Z</span></a>} {<a id="x1:262" class="idref" href="#x1:262"><span class="id" title="binder">x1</span></a> <a id="x2:263" class="idref" href="#x2:263"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:259"><span class="id" title="variable">X</span></a>} {<a id="y1:264" class="idref" href="#y1:264"><span class="id" title="binder">y1</span></a> <a id="y2:265" class="idref" href="#y2:265"><span class="id" title="binder">y2</span></a>} {<a id="F:266" class="idref" href="#F:266"><span class="id" title="binder">F</span></a>} (<a id="p:267" class="idref" href="#p:267"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:262"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:263"><span class="id" title="variable">x2</span></a>) {<a id="q:268" class="idref" href="#q:268"><span class="id" title="binder">q</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#y1:264"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:265"><span class="id" title="variable">y2</span></a>}<br>
{<a id="psi:269" class="idref" href="#psi:269"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:260"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:267"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:266"><span class="id" title="variable">F</span></a>} {<a id="G1:271" class="idref" href="#G1:271"><span class="id" title="binder">G1</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="y:270" class="idref" href="#y:270"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:261"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x1:262"><span class="id" title="variable">x1</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:270"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>} {<a id="G2:273" class="idref" href="#G2:273"><span class="id" title="binder">G2</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="y:272" class="idref" href="#y:272"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:261"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x2:263"><span class="id" title="variable">x2</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:272"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>}<br>
{<a id="r:274" class="idref" href="#r:274"><span class="id" title="binder">r</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#F:266"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y1:264"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:266"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:265"><span class="id" title="variable">y2</span></a>} (<a id="theta:275" class="idref" href="#theta:275"><span class="id" title="binder">theta</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:266"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q:268"><span class="id" title="variable">q</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#r:274"><span class="id" title="variable">r</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="u1:276" class="idref" href="#u1:276"><span class="id" title="binder">u1</span></a> <a id="u2:277" class="idref" href="#u2:277"><span class="id" title="binder">u2</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G2:273"><span class="id" title="variable">G2</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#r:274"><span class="id" title="variable">r</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#u2:277"><span class="id" title="variable">u2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#r:274"><span class="id" title="variable">r</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#u1:276"><span class="id" title="variable">u1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Epsilon"><span class="id" title="definition">Epsilon</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:267"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#theta:275"><span class="id" title="variable">theta</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#G1:271"><span class="id" title="variable">G1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y1:264"><span class="id" title="variable">y1</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a><br>
<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:261"><span class="id" title="variable">Z</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:267"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:269"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:265"><span class="id" title="variable">y2</span></a>)) (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G1:271"><span class="id" title="variable">G1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q:268"><span class="id" title="variable">q</span></a>)<br>
<a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="y:278" class="idref" href="#y:278"><span class="id" title="binder">y</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#G2:273"><span class="id" title="variable">G2</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#F:266"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:278"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:267"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:269"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:278"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G1:271"><span class="id" title="variable">G1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:278"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#q:268"><span class="id" title="variable">q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#u1:276"><span class="id" title="variable">u1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#u2:277"><span class="id" title="variable">u2</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(349, '0_3_83');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(350, '0_3_83');
      "><br>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">theta</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">q</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">u1</span> <span class="id" title="var">u2</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>, !<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(351, '0_3_83');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(352, '0_3_83');
      "><br>
<span class="id" title="tactic">intro</span> <span class="id" title="var">s</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">s</span>; <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(353, '0_3_83');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(354, '0_3_83');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_83"><pre><span></span></pre></div>
<div class="doc" scenenumber="85">
The path case of the nested induction; corresponds to "omega" in the paper. 
</div>
<div scenenumber="87" class="code">
<span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(358, '0_3_87');
      ">
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="G" class="idref" href="#G"><span class="id" title="definition">G</span></a> <a id="n:279" class="idref" href="#n:279"><span class="id" title="binder">n</span></a> <a id="a:280" class="idref" href="#a:280"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="y:281" class="idref" href="#y:281"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
<a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:279"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:280"><span class="id" title="variable">a</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:279"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:280"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#y:281"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:279"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#a:280"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#y:281"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(359, '0_3_87');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(360, '0_3_87');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(361, '0_3_87');
      "><br>
- <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="k:284" class="idref" href="#k:284"><span class="id" title="binder">k</span></a> <a id="b:285" class="idref" href="#b:285"><span class="id" title="binder">b</span></a>  <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(362, '0_3_87');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">l</span> <span class="id" title="var">p</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(363, '0_3_87');
      "><br>
<span class="id" title="var">snrapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Phi"><span class="id" title="definition">Phi</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.A"><span class="id" title="variable">A</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>) (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_succ_seq_to_colim_seq_beta_glue</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(364, '0_3_87');
      "><br>
<span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind_beta_colimp"><span class="id" title="axiom">Colimit_ind_beta_colimp</span></a> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <a id="k:288" class="idref" href="#k:288"><span class="id" title="binder">k</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:286"><span class="id" title="variable">k</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(365, '0_3_87');
      "><br>
<span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind_beta_colimp"><span class="id" title="axiom">Colimit_ind_beta_colimp</span></a> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <a id="k:291" class="idref" href="#k:291"><span class="id" title="binder">k</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:289"><span class="id" title="variable">k</span></a> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> <span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(366, '0_3_87');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(367, '0_3_87');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(368, '0_3_87');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="I" class="idref" href="#I"><span class="id" title="definition">I</span></a> {<a id="X:292" class="idref" href="#X:292"><span class="id" title="binder">X</span></a> <a id="Y:293" class="idref" href="#Y:293"><span class="id" title="binder">Y</span></a> <a id="Z:294" class="idref" href="#Z:294"><span class="id" title="binder">Z</span></a>} {<a id="x1:295" class="idref" href="#x1:295"><span class="id" title="binder">x1</span></a> <a id="x2:296" class="idref" href="#x2:296"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:292"><span class="id" title="variable">X</span></a>} {<a id="p:297" class="idref" href="#p:297"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:295"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:296"><span class="id" title="variable">x2</span></a>} {<a id="F:298" class="idref" href="#F:298"><span class="id" title="binder">F</span></a>} (<a id="psi:299" class="idref" href="#psi:299"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:293"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:297"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:298"><span class="id" title="variable">F</span></a>) {<a id="G1:300" class="idref" href="#G1:300"><span class="id" title="binder">G1</span></a> <a id="G2:301" class="idref" href="#G2:301"><span class="id" title="binder">G2</span></a>}<br>
: <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="x:302" class="idref" href="#x:302"><span class="id" title="binder">x</span></a>  <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="y:303" class="idref" href="#y:303"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:294"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:302"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:303"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:297"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G1:300"><span class="id" title="variable">G1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G2:301"><span class="id" title="variable">G2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a><br>
<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="y:304" class="idref" href="#y:304"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G2:301"><span class="id" title="variable">G2</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#F:298"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:304"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:297"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:299"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:304"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G1:300"><span class="id" title="variable">G1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:304"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(369, '0_3_87');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(370, '0_3_87');
      "><br>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">psi</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(371, '0_3_87');
      "><br>
<span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transitivity"><span class="id" title="definition">transitivity</span></a> (<a class="idref" href="HoTT.Types.Paths.html#equiv_path_inverse"><span class="id" title="definition">equiv_path_inverse</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Types.Forall.html#equiv_apD10"><span class="id" title="definition">equiv_apD10</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(372, '0_3_87');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(373, '0_3_87');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_87"><pre><span></span></pre></div>
<div class="doc" scenenumber="89">
The alternative induction rule in curried form; corresponds to curried "G" in
      the paper. 
</div>
<div scenenumber="91" class="code">
<span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(377, '0_3_91');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_ind_cur" class="idref" href="#seq_colim_sum_ind_cur"><span class="id" title="definition">seq_colim_sum_ind_cur</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="x:305" class="idref" href="#x:305"><span class="id" title="binder">x</span></a> <a id="y:306" class="idref" href="#y:306"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:305"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:306"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(378, '0_3_91');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(379, '0_3_91');
      "><br>
<span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a>); <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(380, '0_3_91');
      "><br>
<span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#I"><span class="id" title="definition">I</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>)<a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">)^-1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(381, '0_3_91');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(382, '0_3_91');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_91"><pre><span></span></pre></div>
<div class="doc" scenenumber="93">
The computation rule for the alternative induction rule in curried form. 
</div>
<div scenenumber="95" class="code">
<span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(386, '0_3_95');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_ind_cur_beta_glue" class="idref" href="#seq_colim_sum_ind_cur_beta_glue"><span class="id" title="definition">seq_colim_sum_ind_cur_beta_glue</span></a> <a id="n:307" class="idref" href="#n:307"><span class="id" title="binder">n</span></a> <a id="a:308" class="idref" href="#a:308"><span class="id" title="binder">a</span></a> :<br>
<a class="idref" href="HoTT.Colimits.Sequential.html#I"><span class="id" title="definition">I</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:307"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:308"><span class="id" title="variable">a</span></a>) (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind_cur"><span class="id" title="definition">seq_colim_sum_ind_cur</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:307"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:308"><span class="id" title="variable">a</span></a>)) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G"><span class="id" title="definition">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:307"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:308"><span class="id" title="variable">a</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(387, '0_3_95');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(388, '0_3_95');
      "><br>
<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#moveR_equiv_M"><span class="id" title="definition">moveR_equiv_M</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind_beta_colimp"><span class="id" title="axiom">Colimit_ind_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(389, '0_3_95');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(390, '0_3_95');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_95"><pre><span></span></pre></div>
<div class="doc" scenenumber="97">
The alternative induction rule; corresponds to "G" in the paper. 
</div>
<div scenenumber="99" class="code">
<span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(394, '0_3_99');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_ind" class="idref" href="#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="x:309" class="idref" href="#x:309"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:309"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(395, '0_3_99');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(396, '0_3_99');
      "><br>
<span class="id" title="tactic">intros</span> [<span class="id" title="var">x</span> <span class="id" title="var">y</span>]; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind_cur"><span class="id" title="definition">seq_colim_sum_ind_cur</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(397, '0_3_99');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(398, '0_3_99');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Xi" class="idref" href="#Xi"><span class="id" title="definition">Xi</span></a> {<a id="X:310" class="idref" href="#X:310"><span class="id" title="binder">X</span></a> <a id="Y:311" class="idref" href="#Y:311"><span class="id" title="binder">Y</span></a> <a id="Z:312" class="idref" href="#Z:312"><span class="id" title="binder">Z</span></a>} <a id="G:313" class="idref" href="#G:313"><span class="id" title="binder">G</span></a> {<a id="x:314" class="idref" href="#x:314"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:310"><span class="id" title="variable">X</span></a>} {<a id="y1:315" class="idref" href="#y1:315"><span class="id" title="binder">y1</span></a> <a id="y2:316" class="idref" href="#y2:316"><span class="id" title="binder">y2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#Y:311"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:314"><span class="id" title="variable">x</span></a>} {<a id="z:317" class="idref" href="#z:317"><span class="id" title="binder">z</span></a> : <a class="idref" href="Coq.Init.Specif.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:311"><span class="id" title="variable">Y</span></a>} {<a id="p:318" class="idref" href="#p:318"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#y1:315"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:316"><span class="id" title="variable">y2</span></a>}<br>
{<a id="q1:319" class="idref" href="#q1:319"><span class="id" title="binder">q1</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#z:317"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:314"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y1:315"><span class="id" title="variable">y1</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>} {<a id="q2:320" class="idref" href="#q2:320"><span class="id" title="binder">q2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#z:317"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:314"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y2:316"><span class="id" title="variable">y2</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>} (<a id="theta:321" class="idref" href="#theta:321"><span class="id" title="binder">theta</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#q2:320"><span class="id" title="variable">q2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q1:319"><span class="id" title="variable">q1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#p:318"><span class="id" title="variable">p</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#G:313"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="Coq.Init.Specif.html#exist"><span class="id" title="constructor">exist</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:311"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:314"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:318"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Z:312"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="Coq.Init.Specif.html#exist"><span class="id" title="constructor">exist</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:311"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:314"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:318"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:313"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q1:319"><span class="id" title="variable">q1</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Eta"><span class="id" title="definition">Eta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#theta:321"><span class="id" title="variable">theta</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#G:313"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#z:317"><span class="id" title="variable">z</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:313"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q2:320"><span class="id" title="variable">q2</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(399, '0_3_99');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(400, '0_3_99');
      "><br>
<span class="id" title="var">revert</span> <span class="id" title="var">theta</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ind"><span class="id" title="definition">equiv_ind</span></a> (<a class="idref" href="HoTT.Types.Paths.html#equiv_path_inverse"><span class="id" title="definition">equiv_path_inverse</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(401, '0_3_99');
      "><span class="id" title="tactic">intro</span> <span class="id" title="var">s</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">s</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(402, '0_3_99');
      "><br>
<span class="id" title="var">revert</span> <span class="id" title="var">q1</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ind"><span class="id" title="definition">equiv_ind</span></a> (<a class="idref" href="HoTT.Types.Paths.html#equiv_path_inverse"><span class="id" title="definition">equiv_path_inverse</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)); <span class="id" title="tactic">intro</span> <span class="id" title="var">s</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">s</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(403, '0_3_99');
      "><br>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(404, '0_3_99');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(405, '0_3_99');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Mu" class="idref" href="#Mu"><span class="id" title="definition">Mu</span></a> {<a id="X:322" class="idref" href="#X:322"><span class="id" title="binder">X</span></a> <a id="Y:323" class="idref" href="#Y:323"><span class="id" title="binder">Y</span></a> <a id="Z:324" class="idref" href="#Z:324"><span class="id" title="binder">Z</span></a>} {<a id="x1:325" class="idref" href="#x1:325"><span class="id" title="binder">x1</span></a> <a id="x2:326" class="idref" href="#x2:326"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:322"><span class="id" title="variable">X</span></a>} (<a id="p:327" class="idref" href="#p:327"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:325"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:326"><span class="id" title="variable">x2</span></a>) {<a id="F:328" class="idref" href="#F:328"><span class="id" title="binder">F</span></a>} (<a id="G:330" class="idref" href="#G:330"><span class="id" title="binder">G</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="z:329" class="idref" href="#z:329"><span class="id" title="binder">z</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:324"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#z:329"><span class="id" title="variable">z</span></a>)<br>
{<a id="psi:331" class="idref" href="#psi:331"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:323"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:327"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:328"><span class="id" title="variable">F</span></a>} {<a id="q:332" class="idref" href="#q:332"><span class="id" title="binder">q</span></a>} (<a id="theta:335" class="idref" href="#theta:335"><span class="id" title="binder">theta</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#I"><span class="id" title="definition">I</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:331"><span class="id" title="variable">psi</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<span class="id" title="keyword">fun</span> <a id="x:333" class="idref" href="#x:333"><span class="id" title="binder">x</span></a> <a id="y:334" class="idref" href="#y:334"><span class="id" title="binder">y</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#G:330"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:333"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:334"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:327"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q:332"><span class="id" title="variable">q</span></a>) <a id="y:336" class="idref" href="#y:336"><span class="id" title="binder">y</span></a><br>
: <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:330"><span class="id" title="variable">G</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:327"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:331"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:336"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#q:332"><span class="id" title="variable">q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:336"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(406, '0_3_99');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(407, '0_3_99');
      "><br>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">psi</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">theta</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(408, '0_3_99');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(409, '0_3_99');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_99"><pre><span></span></pre></div>
<div class="doc" scenenumber="101">
The computation rule for the alternative induction rule. 
</div>
<div scenenumber="103" class="code">
<span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(413, '0_3_103');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_ind_beta_glue" class="idref" href="#seq_colim_sum_ind_beta_glue"><span class="id" title="definition">seq_colim_sum_ind_beta_glue</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="n:337" class="idref" href="#n:337"><span class="id" title="binder">n</span></a> <a id="a:338" class="idref" href="#a:338"><span class="id" title="binder">a</span></a> <a id="b:339" class="idref" href="#b:339"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:337"><span class="id" title="variable">n</span></a> <span class="id" title="var">_</span>)) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
<a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.t"><span class="id" title="variable">t</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:337"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:338"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:339"><span class="id" title="variable">b</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(414, '0_3_103');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(415, '0_3_103');
      "><br>
<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">pose</span> (<span class="id" title="var">h</span> := <a class="idref" href="HoTT.Colimits.Sequential.html#F_beta_glue"><span class="id" title="definition">F_beta_glue</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(416, '0_3_103');
      "><br>
<span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Xi"><span class="id" title="definition">Xi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim_beta_glue"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(417, '0_3_103');
      "><br>
<span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Mu"><span class="id" title="definition">Mu</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>) <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind_cur_beta_glue"><span class="id" title="definition">seq_colim_sum_ind_cur_beta_glue</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(418, '0_3_103');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">h</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#cancelL"><span class="id" title="definition">cancelL</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(419, '0_3_103');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(420, '0_3_103');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd"><span class="id" title="section">SeqColimitSumInd</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(421, '0_3_103');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_103"><pre><span></span></pre></div>
<div class="doc" scenenumber="105">
An alternative recursion principle for the sum of colimits; Lemma 5.3. 
</div>
<div scenenumber="107" class="code">
<span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(425, '0_3_107');
      ">
<span class="id" title="keyword">Section</span> <a id="SeqColimitSumRec" class="idref" href="#SeqColimitSumRec"><span class="id" title="section">SeqColimitSumRec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(426, '0_3_107');
      "><br>
<br>
<span class="id" title="keyword">Context</span> `{<a id="H:340" class="idref" href="#H:340"><span class="id" title="binder">Univalence</span></a>} {<a id="A:341" class="idref" href="#A:341"><span class="id" title="binder">A</span></a>} (<a id="B:342" class="idref" href="#B:342"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:341"><span class="id" title="variable">A</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(427, '0_3_107');
      "><br>
<span class="id" title="keyword">Context</span> <a id="E:343" class="idref" href="#E:343"><span class="id" title="binder">E</span></a> (<a id="e:346" class="idref" href="#e:346"><span class="id" title="binder">e</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="n:344" class="idref" href="#n:344"><span class="id" title="binder">n</span></a> <a id="a:345" class="idref" href="#a:345"><span class="id" title="binder">a</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:344"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:345"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#E:343"><span class="id" title="variable">E</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(428, '0_3_107');
      "><br>
<span class="id" title="keyword">Context</span> (<a id="t:350" class="idref" href="#t:350"><span class="id" title="binder">t</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="n:347" class="idref" href="#n:347"><span class="id" title="binder">n</span></a> <a id="a:348" class="idref" href="#a:348"><span class="id" title="binder">a</span></a> (<a id="b:349" class="idref" href="#b:349"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:347"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:348"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:347"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#a:348"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#b:349"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">f</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:347"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:348"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:349"><span class="id" title="variable">b</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(429, '0_3_107');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_rec" class="idref" href="#seq_colim_sum_rec"><span class="id" title="definition">seq_colim_sum_rec</span></a> : <a class="idref" href="Coq.Init.Specif.html#sig"><span class="id" title="record">sig</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a>)<a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.E"><span class="id" title="variable">E</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(430, '0_3_107');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(431, '0_3_107');
      "><br>
<span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.e"><span class="id" title="variable">e</span></a> (<span class="id" title="keyword">fun</span> <a id="n:354" class="idref" href="#n:354"><span class="id" title="binder">n</span></a> <a id="a:355" class="idref" href="#a:355"><span class="id" title="binder">a</span></a> <a id="b:356" class="idref" href="#b:356"><span class="id" title="binder">b</span></a>  <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.t"><span class="id" title="variable">t</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:351"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:352"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:353"><span class="id" title="variable">b</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(432, '0_3_107');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(433, '0_3_107');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_rec_beta_glue" class="idref" href="#seq_colim_sum_rec_beta_glue"><span class="id" title="definition">seq_colim_sum_rec_beta_glue</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="n:357" class="idref" href="#n:357"><span class="id" title="binder">n</span></a> <a id="a:358" class="idref" href="#a:358"><span class="id" title="binder">a</span></a> <a id="b:359" class="idref" href="#b:359"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_rec"><span class="id" title="definition">seq_colim_sum_rec</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:357"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:358"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:359"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
<a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.t"><span class="id" title="variable">t</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:357"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:358"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:359"><span class="id" title="variable">b</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(434, '0_3_107');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(435, '0_3_107');
      "><br>
<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#cancelL"><span class="id" title="definition">cancelL</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#apD_const"><span class="id" title="lemma">apD_const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(436, '0_3_107');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind_beta_glue"><span class="id" title="definition">seq_colim_sum_ind_beta_glue</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(437, '0_3_107');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(438, '0_3_107');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec"><span class="id" title="section">SeqColimitSumRec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(439, '0_3_107');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_107"><pre><span></span></pre></div>
<div class="doc" scenenumber="109">
Lemma 5.4. 
</div>
<div scenenumber="111" class="code">
<span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(443, '0_3_111');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colimit_sum_uniq" class="idref" href="#seq_colimit_sum_uniq"><span class="id" title="definition">seq_colimit_sum_uniq</span></a> `{<a id="H:360" class="idref" href="#H:360"><span class="id" title="binder">Univalence</span></a>} {<a id="A:361" class="idref" href="#A:361"><span class="id" title="binder">A</span></a>} (<a id="B:362" class="idref" href="#B:362"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:361"><span class="id" title="variable">A</span></a>) <a id="E:363" class="idref" href="#E:363"><span class="id" title="binder">E</span></a><br>
(<a id="F:364" class="idref" href="#F:364"><span class="id" title="binder">F</span></a> <a id="G:365" class="idref" href="#G:365"><span class="id" title="binder">G</span></a> : <a class="idref" href="Coq.Init.Specif.html#sig"><span class="id" title="record">sig</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:362"><span class="id" title="variable">B</span></a>) <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#E:363"><span class="id" title="variable">E</span></a>)<br>
: <a class="idref" href="HoTT.Colimits.Sequential.html#F:364"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:362"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:365"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:362"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a><br>
<a class="idref" href="HoTT.Colimits.Sequential.html#F:364"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:365"><span class="id" title="variable">G</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(444, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(445, '0_3_111');
      "><br>
<span class="id" title="tactic">intro</span> <span class="id" title="var">h</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> <span class="id" title="var">B</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>  <span class="id" title="var">h</span> <span class="id" title="var">_</span>)); <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(446, '0_3_111');
      "><br>
<span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_compose"><span class="id" title="lemma">transport_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>); <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <span class="id" title="var">B</span>) <span class="id" title="var">n</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(447, '0_3_111');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(448, '0_3_111');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_111"><pre><span></span></pre></div>
<div class="doc" scenenumber="113">
The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits is an equivalence; Theorem 5.1. 
</div>
<div scenenumber="115" class="code">
<span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(452, '0_3_115');
      ">
<span class="id" title="keyword">Global Instance</span> <a id="isequiv_seq_colim_sum_to_sum_seq_colim" class="idref" href="#isequiv_seq_colim_sum_to_sum_seq_colim"><span class="id" title="instance">isequiv_seq_colim_sum_to_sum_seq_colim</span></a> `{<a id="H:366" class="idref" href="#H:366"><span class="id" title="binder">Univalence</span></a>} {<a id="A:367" class="idref" href="#A:367"><span class="id" title="binder">A</span></a>} (<a id="B:368" class="idref" href="#B:368"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:367"><span class="id" title="variable">A</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:368"><span class="id" title="variable">B</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(453, '0_3_115');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(454, '0_3_115');
      "><br>
<span class="id" title="tactic">assert</span> (<span class="id" title="var">L</span> : <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="G:370" class="idref" href="#G:370"><span class="id" title="binder">G</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <span class="id" title="var">_</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Sect"><span class="id" title="definition">Sect</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <span class="id" title="var">B</span>) <a class="idref" href="HoTT.Colimits.Sequential.html#G:369"><span class="id" title="variable">G</span></a><a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(455, '0_3_115');
      "><br>
- <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(456, '0_3_115');
      "><br>
+ <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_rec"><span class="id" title="definition">seq_colim_sum_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(457, '0_3_115');
      "><br>
 <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:374" class="idref" href="#n:374"><span class="id" title="binder">n</span></a> <a id="a:375" class="idref" href="#a:375"><span class="id" title="binder">a</span></a> <a id="b:376" class="idref" href="#b:376"><span class="id" title="binder">b</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <span class="id" title="var">B</span>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:371"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:372"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:373"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(458, '0_3_115');
      "><br>
 <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:380" class="idref" href="#n:380"><span class="id" title="binder">n</span></a> <a id="a:381" class="idref" href="#a:381"><span class="id" title="binder">a</span></a> <a id="b:382" class="idref" href="#b:382"><span class="id" title="binder">b</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <span class="id" title="var">B</span>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:377"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:378"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:379"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(459, '0_3_115');
      "><br>
+ <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(460, '0_3_115');
      "><br>
 <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:385" class="idref" href="#n:385"><span class="id" title="binder">n</span></a> <a id="a:386" class="idref" href="#a:386"><span class="id" title="binder">a</span></a>  <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(461, '0_3_115');
      "><br>
 <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(462, '0_3_115');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_rec_beta_glue"><span class="id" title="definition">seq_colim_sum_rec_beta_glue</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(463, '0_3_115');
      "><br>
- <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_adjointify"><span class="id" title="definition">isequiv_adjointify</span></a> <span class="id" title="var">_</span> <span class="id" title="var">L</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a> <span class="id" title="var">_</span> <span class="id" title="var">L</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a>); <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_sum_uniq"><span class="id" title="definition">seq_colimit_sum_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(464, '0_3_115');
      "><br>
<span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">L</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(465, '0_3_115');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(466, '0_3_115');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_seq_colim_sum_to_sum_seq_colim" class="idref" href="#equiv_seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">equiv_seq_colim_sum_to_sum_seq_colim</span></a> `{<a id="H:387" class="idref" href="#H:387"><span class="id" title="binder">Univalence</span></a>} {<a id="A:388" class="idref" href="#A:388"><span class="id" title="binder">A</span></a>} (<a id="B:389" class="idref" href="#B:389"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:388"><span class="id" title="variable">A</span></a>)<br>
: <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:389"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="Coq.Init.Specif.html#sig"><span class="id" title="record">sig</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:389"><span class="id" title="variable">B</span></a>)<br>
:= <a class="idref" href="HoTT.Basics.Overture.html#Build_Equiv"><span class="id" title="constructor">Build_Equiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#isequiv_seq_colim_sum_to_sum_seq_colim"><span class="id" title="instance">isequiv_seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:389"><span class="id" title="variable">B</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(467, '0_3_115');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_115"><pre><span></span></pre></div>
<div class="doc" scenenumber="117">
The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits commutes with the first projection; Theorem 5.1. 
</div>
<div scenenumber="119" class="code">
<span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(471, '0_3_119');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_to_sum_seq_colim_fst" class="idref" href="#seq_colim_sum_to_sum_seq_colim_fst"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim_fst</span></a> `{<a id="H:390" class="idref" href="#H:390"><span class="id" title="binder">Univalence</span></a>} {<a id="A:391" class="idref" href="#A:391"><span class="id" title="binder">A</span></a>} (<a id="B:392" class="idref" href="#B:392"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:391"><span class="id" title="variable">A</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:392"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_seq_colim_fst"><span class="id" title="definition">seq_colim_sum_to_seq_colim_fst</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:392"><span class="id" title="variable">B</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(472, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(473, '0_3_119');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(474, '0_3_119');
      "><br>
- <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:395" class="idref" href="#n:395"><span class="id" title="binder">n</span></a> <a id="a:396" class="idref" href="#a:396"><span class="id" title="binder">a</span></a>  <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(475, '0_3_119');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> [<span class="id" title="var">a</span> <span class="id" title="var">b</span>]; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a>, !<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(476, '0_3_119');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_pp"><span class="id" title="definition">ap_pp</span></a>, (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta_proj"><span class="id" title="definition">Delta_proj</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <span class="id" title="var">B</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(477, '0_3_119');
      "><br>
<span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#whiskerL"><span class="id" title="definition">whiskerL</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a> <span class="id" title="var">_</span>); <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(478, '0_3_119');
      "><br>
<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_const"><span class="id" title="definition">ap_const</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(479, '0_3_119');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(480, '0_3_119');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_119"><pre><span></span></pre></div>
<div class="doc" scenenumber="121">
The characterization of path spaces in sequential colimits; Theorem 7.4, first part. 
</div>
<div scenenumber="123" class="code">
<span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(484, '0_3_123');
      ">
<span class="id" title="keyword">Definition</span> <a id="path_seq" class="idref" href="#path_seq"><span class="id" title="definition">path_seq</span></a> (<a id="A:397" class="idref" href="#A:397"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>) (<a id="a1:398" class="idref" href="#a1:398"><span class="id" title="binder">a1</span></a> <a id="a2:399" class="idref" href="#a2:399"><span class="id" title="binder">a2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:397"><span class="id" title="variable">A</span></a> 0)<br>
:= <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a> (<span class="id" title="keyword">fun</span> <a id="k:403" class="idref" href="#k:403"><span class="id" title="binder">k</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#a1:398"><span class="id" title="variable">a1</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:403"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:399"><span class="id" title="variable">a2</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:403"><span class="id" title="variable">k</span></a>) (<span class="id" title="keyword">fun</span> <a id="k:400" class="idref" href="#k:400"><span class="id" title="binder">k</span></a> <a id="p:401" class="idref" href="#p:401"><span class="id" title="binder">p</span></a>  <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="a:402" class="idref" href="#a:402"><span class="id" title="binder">a</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#a:402"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:401"><span class="id" title="variable">p</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(485, '0_3_123');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_path_colim_zero" class="idref" href="#equiv_path_colim_zero"><span class="id" title="definition">equiv_path_colim_zero</span></a> `{<a id="H:404" class="idref" href="#H:404"><span class="id" title="binder">Univalence</span></a>} {<a id="A:405" class="idref" href="#A:405"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="a1:406" class="idref" href="#a1:406"><span class="id" title="binder">a1</span></a> <a id="a2:407" class="idref" href="#a2:407"><span class="id" title="binder">a2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:405"><span class="id" title="variable">A</span></a> 0) :<br>
<a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:405"><span class="id" title="variable">A</span></a> 0 <a class="idref" href="HoTT.Colimits.Sequential.html#a1:406"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:405"><span class="id" title="variable">A</span></a> 0 <a class="idref" href="HoTT.Colimits.Sequential.html#a2:407"><span class="id" title="variable">a2</span></a><a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#path_seq"><span class="id" title="definition">path_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:405"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a1:406"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:407"><span class="id" title="variable">a2</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(486, '0_3_123');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(487, '0_3_123');
      "><br>
<span class="id" title="tactic">pose</span> (<span class="id" title="var">B</span> := <a class="idref" href="HoTT.Colimits.Sequential.html#Build_FibSequence"><span class="id" title="constructor">Build_FibSequence</span></a> <span class="id" title="var">A</span> (<span class="id" title="keyword">fun</span> <a id="x:413" class="idref" href="#x:413"><span class="id" title="binder">x</span></a>  <span class="id" title="var">a1</span><a class="idref" href="HoTT.Colimits.Sequential.html#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">^+(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:410"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:410"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a>) (<span class="id" title="keyword">fun</span> <a id="x:411" class="idref" href="#x:411"><span class="id" title="binder">x</span></a>  <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="a:412" class="idref" href="#a:412"><span class="id" title="binder">a</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#a:409"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(488, '0_3_123');
      "><br>
<span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <span class="id" title="var">B</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">A</span> 0 <span class="id" title="var">a2</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(489, '0_3_123');
      "><br>
+ <span class="id" title="tactic">symmetry</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.PathAny.html#equiv_path_from_contr"><span class="id" title="definition">equiv_path_from_contr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(490, '0_3_123');
      "><br>
- <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a>0<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">a1</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>) 0 <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(491, '0_3_123');
      "><br>
- <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#contr_equiv"><span class="id" title="lemma">contr_equiv</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <span class="id" title="var">B</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(492, '0_3_123');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#contr_colim_contr_seq"><span class="id" title="definition">contr_colim_contr_seq</span></a>; <span class="id" title="tactic">intro</span> <span class="id" title="var">k</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Contractible.html#contr_basedpaths"><span class="id" title="instance">contr_basedpaths</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(493, '0_3_123');
      "><br>
+ <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#equiv_functor_colimit"><span class="id" title="definition">equiv_functor_colimit</span></a>; <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transitivity"><span class="id" title="definition">transitivity</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#equiv_fib_seq_to_seq"><span class="id" title="definition">equiv_fib_seq_to_seq</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a>0<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">a2</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(494, '0_3_123');
      "><br>
<span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_diagram_equiv"><span class="id" title="constructor">Build_diagram_equiv</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(495, '0_3_123');
      "><br>
 <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_DiagramMap"><span class="id" title="constructor">Build_DiagramMap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(496, '0_3_123');
      "><br>
- <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:415" class="idref" href="#n:415"><span class="id" title="binder">n</span></a>  <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">B</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_shift_pair_from_zero"><span class="id" title="definition">seq_shift_pair_from_zero</span></a> <span class="id" title="var">a2</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:414"><span class="id" title="variable">n</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(497, '0_3_123');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#K"><span class="id" title="definition">K</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_shift_pair_from_zero"><span class="id" title="definition">seq_shift_pair_from_zero</span></a> <span class="id" title="var">a2</span> <span class="id" title="var">n</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(498, '0_3_123');
      "><br>
 <span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Types.Universe.html#isequiv_path"><span class="id" title="instance">isequiv_path</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(499, '0_3_123');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(500, '0_3_123');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_123"><pre><span></span></pre></div>
<div class="doc" scenenumber="125">
The characterization of path spaces in sequential colimits; Theorem 7.4, second part. 
</div>
<div scenenumber="127" class="code">
<span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(504, '0_3_127');
      ">
<span class="id" title="keyword">Definition</span> <a id="equiv_path_colim" class="idref" href="#equiv_path_colim"><span class="id" title="definition">equiv_path_colim</span></a> `{<a id="H:416" class="idref" href="#H:416"><span class="id" title="binder">Univalence</span></a>} {<a id="A:417" class="idref" href="#A:417"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} <a id="n:418" class="idref" href="#n:418"><span class="id" title="binder">n</span></a> (<a id="a1:419" class="idref" href="#a1:419"><span class="id" title="binder">a1</span></a> <a id="a2:420" class="idref" href="#a2:420"><span class="id" title="binder">a2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:417"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:418"><span class="id" title="variable">n</span></a>) :<br>
<a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:417"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:418"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a1:419"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:417"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:418"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:420"><span class="id" title="variable">a2</span></a><a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#path_seq"><span class="id" title="definition">path_seq</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:417"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:418"><span class="id" title="variable">n</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#a1:419"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:420"><span class="id" title="variable">a2</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(505, '0_3_127');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(506, '0_3_127');
      "><br>
<span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transitivity"><span class="id" title="definition">transitivity</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#equiv_path_colim_zero"><span class="id" title="definition">equiv_path_colim_zero</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)); <span class="id" title="tactic">symmetry</span>.</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(507, '0_3_127');
      "><br>
<span class="id" title="var">srapply</span> (@<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ap"><span class="id" title="definition">equiv_ap</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(508, '0_3_127');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(509, '0_3_127');
      "><br>
<br>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">trunc_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(510, '0_3_127');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_127"><pre><span></span></pre></div>
<div class="doc" scenenumber="129">
Corollary 7.7.1, second part. 
</div>
<div scenenumber="131" class="code">
<span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(514, '0_3_131');
      ">
<span class="id" title="keyword">Global Instance</span> <a id="trunc_seq_colim" class="idref" href="#trunc_seq_colim"><span class="id" title="instance">trunc_seq_colim</span></a> `{<a id="H:421" class="idref" href="#H:421"><span class="id" title="binder">Univalence</span></a>} {<a id="A:422" class="idref" href="#A:422"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} <a id="k:423" class="idref" href="#k:423"><span class="id" title="binder">k</span></a> :<br>
<a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation"></span></a> <a id="n:424" class="idref" href="#n:424"><span class="id" title="binder">n</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:423"><span class="id" title="variable">k</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#A:422"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:424"><span class="id" title="variable">n</span></a>)<a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation"></span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:423"><span class="id" title="variable">k</span></a> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit"><span class="id" title="inductive">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:422"><span class="id" title="variable">A</span></a>) | 100.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(515, '0_3_131');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(516, '0_3_131');
      "><br>
<span class="id" title="var">revert</span> <span class="id" title="var">A</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">IHk</span>].</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(517, '0_3_131');
      "><br>
- <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#contr_colim_contr_seq"><span class="id" title="definition">contr_colim_contr_seq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(518, '0_3_131');
      "><br>
- <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">trH</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(519, '0_3_131');
      "><br>
+ <span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>; <span class="id" title="var">revert</span> <span class="id" title="var">trH</span>; <span class="id" title="var">revert</span> <span class="id" title="var">A</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">IHn</span>].</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(520, '0_3_131');
      "><br>
 <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">trH</span> <span class="id" title="var">a</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit.Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(521, '0_3_131');
      "><br>
{ <span class="id" title="tactic">intros</span> <span class="id" title="var">m</span> <span class="id" title="var">b</span>; <span class="id" title="var">revert</span> <span class="id" title="var">b</span>; <span class="id" title="var">revert</span> <span class="id" title="var">a</span>; <span class="id" title="var">revert</span> <span class="id" title="var">trH</span>; <span class="id" title="var">revert</span> <span class="id" title="var">A</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">m</span> <span class="id" title="var">IHm</span>].</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(522, '0_3_131');
      "><br>
{ <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">trH</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(523, '0_3_131');
      "><br>
<span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Trunc.html#trunc_equiv'"><span class="id" title="definition">trunc_equiv'</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_inverse"><span class="id" title="lemma">equiv_inverse</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#equiv_path_colim"><span class="id" title="definition">equiv_path_colim</span></a> <span class="id" title="var">_</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>))). }</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(524, '0_3_131');
      "><br>
{ <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">trH</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(525, '0_3_131');
      "><br>
<span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Trunc.html#trunc_equiv'"><span class="id" title="definition">trunc_equiv'</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_inverse"><span class="id" title="lemma">equiv_inverse</span></a> (<a class="idref" href="HoTT.Types.Paths.html#equiv_concat_l"><span class="id" title="definition">equiv_concat_l</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span> <span class="id" title="var">_</span> <span class="id" title="var">a</span>) <span class="id" title="var">_</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(526, '0_3_131');
      "><br>
<span class="id" title="var">srapply</span> (@<a class="idref" href="HoTT.Basics.Trunc.html#trunc_equiv'"><span class="id" title="definition">trunc_equiv'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">k</span> (<span class="id" title="var">IHm</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <span class="id" title="var">A</span>) <span class="id" title="var">_</span> (@<a class="idref" href="HoTT.Diagrams.Diagram.html#arr"><span class="id" title="projection">arr</span></a> <span class="id" title="var">_</span> <span class="id" title="var">A</span> 0%<span class="id" title="var">nat</span> <span class="id" title="var">_</span> 1%<span class="id" title="var">path</span> <span class="id" title="var">a</span>) <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(527, '0_3_131');
      "><br>
<span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ap"><span class="id" title="definition">equiv_ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <span class="id" title="var">A</span>)). }}</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(528, '0_3_131');
      "><br>
{ <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">b</span>; <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>; <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Basics.Trunc.html#ishprop_istrunc"><span class="id" title="instance">ishprop_istrunc</span></a>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>. }<br>
 <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">trH</span> <span class="id" title="var">a</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Types.Forall.html#functor_forall_equiv_pb"><span class="id" title="definition">functor_forall_equiv_pb</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <span class="id" title="var">A</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(529, '0_3_131');
      "><br>
<span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="var">srapply</span> (@<a class="idref" href="HoTT.Basics.Trunc.html#trunc_equiv'"><span class="id" title="definition">trunc_equiv'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">k</span> (<span class="id" title="var">IHn</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <span class="id" title="var">A</span>) <span class="id" title="var">_</span> <span class="id" title="var">a</span> <span class="id" title="var">x</span>)); <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ap"><span class="id" title="definition">equiv_ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(530, '0_3_131');
      "><br>
+ <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>; <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Types.Forall.html#trunc_forall"><span class="id" title="instance">trunc_forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(531, '0_3_131');
      "><br>
{ <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>. }<br>
{ <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Trunc.html#ishprop_istrunc"><span class="id" title="instance">ishprop_istrunc</span></a>. }<br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(532, '0_3_131');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_131"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
